// Generated by CoffeeScript 1.12.7
(function() {
  var BaseClass, Binary, WriteStream, XbdDictionary, binary, inspect, log, ref, stream,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), log = ref.log, inspect = ref.inspect;

  Binary = require('art-binary');

  binary = Binary.binary, WriteStream = Binary.WriteStream, stream = Binary.stream;

  BaseClass = require('art-class-system').BaseClass;

  module.exports = XbdDictionary = (function(superClass) {
    extend(XbdDictionary, superClass);

    XbdDictionary.parse = function(stream, name) {
      var encodedDictionary, i, len, lengths, strings;
      encodedDictionary = stream.readAsiString();
      lengths = (function() {
        var j, ref1, results;
        results = [];
        for (i = j = 0, ref1 = encodedDictionary.readAsi(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          results.push(encodedDictionary.readAsi());
        }
        return results;
      })();
      strings = (function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = lengths.length; j < len1; j++) {
          len = lengths[j];
          results.push(encodedDictionary.read(len));
        }
        return results;
      })();
      return new XbdDictionary(strings, name);
    };

    function XbdDictionary(strings1, name1) {
      this.strings = strings1;
      this.name = name1;
    }


    /*
    IN: string: any legal input to binary()
    OUT: index/id for string
    EFFECT:
      string = binary string
      strings was added OR, if already present, nothing changed
     */

    XbdDictionary.prototype.add = function(string) {
      var index;
      string = binary(string);
      if (0 <= (index = this._indexOf(string))) {
        return index;
      } else {
        this.strings.push(string);
        return this.strings.length;
      }
    };


    /*
    IN: string: any legal input to binary()
      NOTE: string is converted to a BinaryString for comparisions
    OUT: returns index of first match in @strings
     */

    XbdDictionary.prototype.get = function(string) {
      var index;
      string = binary(string);
      if (0 <= (index = this._indexOf(string))) {
        return index;
      } else {
        throw new Error("string not found in dictionary: " + (inspect(string)));
      }
    };

    XbdDictionary.prototype.readString = function(stream) {
      var id, string;
      id = stream.readAsi();
      string = this.strings[id];
      if (!string) {
        throw "string id(" + id + ") not in " + this.name + " dictionary. keys = '" + (Object.keys(this.strings)) + "'";
      }
      return string;
    };

    XbdDictionary.getter({
      binaryStringPromise: function() {
        var j, k, len1, len2, normalizedStrings, s, string, writeStream;
        writeStream = new WriteStream;
        normalizedStrings = this._getNormalizeStrings();
        writeStream.writeAsi(normalizedStrings.length);
        for (j = 0, len1 = normalizedStrings.length; j < len1; j++) {
          s = normalizedStrings[j];
          writeStream.writeAsi(s.length);
        }
        for (k = 0, len2 = normalizedStrings.length; k < len2; k++) {
          string = normalizedStrings[k];
          writeStream.write(string);
        }
        return writeStream.binaryStringPromise;
      }
    });

    XbdDictionary.prototype.writeWithPromise = function(writeStream) {
      return this.binaryStringPromise.then(function(binaryString) {
        return writeStream.writeAsiString(binaryString);
      });
    };

    XbdDictionary.prototype._getNormalizeStrings = function() {
      var j, len1, ref1, results, s;
      ref1 = this.strings;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        s = ref1[j];
        results.push(binary(s));
      }
      return results;
    };

    XbdDictionary.prototype._indexOf = function(binaryString) {
      var i, j, len1, ref1, s;
      ref1 = this.strings;
      for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
        s = ref1[i];
        if (s.eq(binaryString)) {
          return i;
        }
      }
      return -1;
    };

    return XbdDictionary;

  })(BaseClass);

}).call(this);
