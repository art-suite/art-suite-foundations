"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "assert", "mergeWithoutNulls", "merge", "mergeInto", "mergeIntoUnless", "pureMerge", "deepMerge"], [global, require('../StandardImport')], (describe, test, assert, mergeWithoutNulls, merge, mergeInto, mergeIntoUnless, pureMerge, deepMerge) => {return describe({mergeWithoutNulls: function() {return test("vs normal merge", () => {assert.eq({a: 1, c: 3}, mergeWithoutNulls({a: 1, b: 2}, {b: null, c: 3})); return assert.eq({a: 1, b: null, c: 3}, merge({a: 1, b: 2}, {b: null, c: 3}));});}, merge: function() {test("merge a, b", () => {let a, b, res; a = {foo: 1}; b = {bar: 2}; res = merge(a, b); assert.eq(res, {foo: 1, bar: 2}); assert.eq(a, {foo: 1}); assert.eq(b, {bar: 2}); assert.neq(a, res); return assert.neq(b, res);}); test("merge a, b, c", () => {let a, b, c, res; a = {foo: 1}; b = {foo: 2}; c = {foo: 3}; res = merge(a, b, c); return assert.eq(res, {foo: 3});}); test("merge a, [b, c]", () => {let a, b, c, res; a = {foo: 1}; b = {foo: 2}; c = {foo: 3}; res = merge(a, [b, c]); return assert.eq(res, {foo: 3});}); test("merge a, null, c", () => {let a, b, c, res; a = {foo: 1}; b = null; c = {foo: 3}; res = merge(a, b, c); return assert.eq(res, {foo: 3});}); test("merge()", () => {let res; res = merge(); return assert.eq(res, {});}); test("merge [a, b]", () => {let a, b, res; a = {foo: 1}; b = {bar: 2}; res = merge([a, b]); return assert.eq(res, {foo: 1, bar: 2});}); return test("merge a:123, {a: undefined}", () => assert.eq({a: 123}, merge({a: 123}, {a: undefined})));}, mergeInto: function() {test("mergeInto()", () => assert.eq(null, mergeInto())); test("mergeInto null, b", () => assert.eq({bar: 2}, mergeInto(null, {bar: 2}))); return test("mergeInto a, b", () => {let a, b, res; a = {foo: 1}; b = {bar: 2}; res = mergeInto(a, b); assert.eq(res, {foo: 1, bar: 2}); assert.eq(a, res); return assert.eq(b, {bar: 2});});}, mergeIntoUnless: function() {test("{a: undefined}, a: 123", () => {let out, v; out = mergeIntoUnless(v = {a: undefined}, {a: 123}); assert.equal(v, out); return assert.eq(v, {a: 123});}); test("{a: 456}, a: 123", () => {let out, v; out = mergeIntoUnless(v = {a: 456}, {a: 123}); assert.equal(v, out); return assert.eq(v, {a: 456});}); return test("{a: 456}, b: 123", () => {let out, v; out = mergeIntoUnless(v = {a: 456}, {b: 123}); assert.equal(v, out); return assert.eq(v, {a: 456, b: 123});});}, pureMerge: function() {test("pureMerge()", () => assert.eq(null, pureMerge())); test("pureMerge a", () => {let a, res; a = {foo: 1}; res = pureMerge(a); return assert.eq(true, res === a);}); test("pureMerge(a, b) when b shadows a", () => {let a, b, res; a = {foo: 1}; b = {foo: 2}; res = pureMerge(a, b); return assert.eq(true, res === b);}); return test("pureMerge(a, b) when b doesn't shadow a", () => {let a, b, res; a = {foo: 1}; b = {bar: 2}; res = pureMerge(a, b); assert.eq(res, {foo: 1, bar: 2}); assert.neq(a, res); return assert.neq(b, res);});}, deepMerge: function() {test("same as merge", () => {let a, b; a = {foo: 1, bar: 2}; b = {bar: 3, baz: 4}; return assert.eq(deepMerge(a, b), merge(a, b));}); test("nested objects with the same key get merged", () => {let a, b, c; a = {foo: 1, bar: {one: 1, two: 2}}; b = {bad: "wolf"}; c = {bar: {two: 200, three: 3}, baz: 4}; assert.neq(deepMerge(a, b, c), merge(a, b, c)); return assert.eq(deepMerge(a, b, c), {foo: 1, bar: {one: 1, two: 200, three: 3}, baz: 4, bad: "wolf"});}); return test("three level test", () => {let a, b, c; a = {bad: "wolf"}; b = {foo: 1, bar: {baz: {a: 123}}}; c = {foo: 1, bar: {baz: {b: 123}}}; assert.neq(deepMerge(a, b, c), merge(a, b, c)); return assert.eq(deepMerge(a, b, c), {bad: "wolf", foo: 1, bar: {baz: {a: 123, b: 123}}});});}});});});
//# sourceMappingURL=Merge.test.js.map
