"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "formattedInspect", "isArray", "assert", "arrayBeforeEach", "arrayAfterEach", "arrayBetweenEach", "arrayWithoutValue", "arrayWithout", "inspectForTestString", "moveArrayElement", "arrayWithElementMoved", "arrayWithElementValueMoved", "compact", "flatten", "Array", "insert", "withInserted", "longestCommonSubsequence", "minimumOrderedOverlappingMerge", "stableSort", "leftOfIndex", "rightOfIndex", "leftOf", "rightOf", "splitArray", "findSortedFirst", "w", "a"], [global, require('./StandardImport')], (describe, test, formattedInspect, isArray, assert, arrayBeforeEach, arrayAfterEach, arrayBetweenEach, arrayWithoutValue, arrayWithout, inspectForTestString, moveArrayElement, arrayWithElementMoved, arrayWithElementValueMoved, compact, flatten, Array, insert, withInserted, longestCommonSubsequence, minimumOrderedOverlappingMerge, stableSort, leftOfIndex, rightOfIndex, leftOf, rightOf, splitArray, findSortedFirst, w, a) => {let oneTwoTree, testEq; oneTwoTree = [1, 2, 3]; testEq = function(f, input, output) {return test(`${Caf.toString(f.name)} ${Caf.toString(formattedInspect(input))} >> ${Caf.toString(formattedInspect(output))}`, () => isArray(input) ? assert.eq(output, f(...input)) : assert.eq(output, f(input)));}; return describe({insertAndRemoveValues: function() {test("arrayBeforeEach", () => assert.eq(arrayBeforeEach(oneTwoTree, 0), [0, 1, 0, 2, 0, 3])); test("arrayAfterEach", () => assert.eq(arrayAfterEach(oneTwoTree, 0), [1, 0, 2, 0, 3, 0])); test("arrayBetweenEach", () => assert.eq(arrayBetweenEach(oneTwoTree, 0), [1, 0, 2, 0, 3])); test("arrayWithoutValue", () => {assert.eq(arrayWithoutValue(oneTwoTree, 2), [1, 3]); assert.eq(arrayWithoutValue(oneTwoTree, 4), oneTwoTree); return assert.eq(arrayWithoutValue(), []);}); return test("arrayWithout", () => {assert.eq(arrayWithout(oneTwoTree, 2), [1, 2]); return assert.eq(arrayWithout(), []);});}, move: function() {let moveArrayElementTest, largeMoveArrayElementTest; moveArrayElementTest = (inArray, _from, _to, outArray) => test(`moveArrayElement ${Caf.toString(inspectForTestString(inArray))}, ${Caf.toString(_from)}, ${Caf.toString(_to)} >>> ${Caf.toString(inspectForTestString(outArray))}`, () => assert.eq(outArray, moveArrayElement(inArray, _from, _to))); moveArrayElementTest([1, 2, 3], 0, 0, [1, 2, 3]); moveArrayElementTest([1, 2, 3], 0, 1, [2, 1, 3]); moveArrayElementTest([1, 2, 3], 0, 2, [2, 3, 1]); moveArrayElementTest([1, 2, 3], 1, 0, [2, 1, 3]); moveArrayElementTest([1, 2, 3], 1, 1, [1, 2, 3]); moveArrayElementTest([1, 2, 3], 1, 2, [1, 3, 2]); moveArrayElementTest([1, 2, 3], 2, 0, [3, 1, 2]); moveArrayElementTest([1, 2, 3], 2, 1, [1, 3, 2]); moveArrayElementTest([1, 2, 3], 2, 2, [1, 2, 3]); largeMoveArrayElementTest = (_from, _to, tests) => test(`large moveArrayElement from:${Caf.toString(_from)}, to:${Caf.toString(_to)}`, () => {let a, largeArray, into, i; a = (into = [], i = 0, (() => {while (i < 1000) {let v; v = i; into.push(v); i++;};})(), into); assert.eq(a.length, 1000); assert.eq(a[0], 0); assert.eq(a[999], 999); largeArray = moveArrayElement(a, _from, _to); assert.eq(largeArray.length, 1000); return Caf.each2(tests, (v, k) => {let index; index = k | 0; return assert.eq(largeArray[index], v, `largeArray[${Caf.toString(index)}] should == ${Caf.toString(v)}`);});}); largeMoveArrayElementTest(999, 0, {0: 999, 1: 0, 998: 997, 999: 998}); largeMoveArrayElementTest(0, 999, {0: 1, 1: 2, 998: 999, 999: 0}); test("arrayWithElementMoved [1,2,3], 2, 0", () => assert.eq([3, 1, 2], arrayWithElementMoved([1, 2, 3], 2, 0))); return test("arrayWithElementValueMoved [1,2,3], 3, 0", () => assert.eq([3, 1, 2], arrayWithElementValueMoved([1, 2, 3], 3, 0)));}, compact: function() {test("compact", () => {assert.eq(compact([1, 2, 3, null, 4]), [1, 2, 3, 4]); assert.eq(compact([1, 2, 3, null]), [1, 2, 3]); return assert.eq(compact([null, 1, 2, 3]), [1, 2, 3]);}); test("compact doesn't remove false", () => assert.eq(["child2", "child3", false, "child4"], compact([undefined, "child2", null, "child3", false, "child4"]))); test("compact not needed returns exactly the input array", () => {let a; a = [1, 3, 4]; return assert.equal(a, compact(a));}); return test("compact with custom keepTester", () => {let structure; structure = [0, false, 1, 2, null, 3, 4, undefined, 5]; assert.eq(compact(structure), [0, false, 1, 2, 3, 4, 5]); return assert.eq(compact(structure, (a) => !!a), [1, 2, 3, 4, 5]);});}, flatten: function() {test("flatten empty array", () => assert.eq(flatten([]), [])); test("flatten not needed returns exactly the input array", () => {let a; a = [1, 3, 4]; return assert.equal(a, flatten(a));}); test("flatten args returns array", () => assert.eq(flatten(1, 2, 3).constructor, Array)); test("flatten() => []", () => assert.eq([], flatten())); test("flatten [] => []", () => assert.eq([], flatten([]))); test("flatten 1 => [1]", () => assert.eq([1], flatten(1))); test("flatten [1] => [1]", () => assert.eq([1], flatten([1]))); test("flatten 1, 2 => [1, 2]", () => assert.eq([1, 2], flatten(1, 2))); test("flatten [1], 2 => [1, 2]", () => assert.eq([1, 2], flatten([1], 2))); test("flatten 1, [2] => [1, 2]", () => assert.eq([1, 2], flatten(1, [2]))); test("flatten [1, 2] => [1, 2]", () => assert.eq([1, 2], flatten([1, 2]))); test("flatten already flat array returns untouched input", () => {let b, a; b = flatten(a = [1, 2, 3, 4, 5]); return assert.eq(true, a === b);}); test("flatten keeps nulls, undefineds, falses and 0s", () => assert.eq(flatten([null, undefined, false, 0]), [null, undefined, false, 0])); test("flatten array with one sub-array", () => assert.eq(flatten([1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5])); test("flatten array lots of direct nesting", () => {assert.eq(flatten([[[1]]]), [1]); return assert.eq(flatten([[[]]]), []);}); test("flatten array with random nesting", () => assert.eq(flatten([[0, [1, 2], 3], [4, [5, [6, 7]]]]), [0, 1, 2, 3, 4, 5, 6, 7])); return test("flatten array with nested []", () => assert.eq(flatten([[], 1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5]));}, insert: function() {test("insert 0", () => assert.eq(insert([1, 2, 3], 0, 999), [999, 1, 2, 3])); test("insert 3", () => assert.eq(insert([1, 2, 3], 3, 999), [1, 2, 3, 999])); test("insert -1", () => assert.eq(insert([1, 2, 3], -1, 999), [1, 2, 3, 999])); test("insert -2", () => assert.eq(insert([1, 2, 3], -2, 999), [1, 2, 999, 3])); return test("withInserted 0", () => {let a, b; a = [1, 2, 3]; b = withInserted(a, 0, 999); assert.eq(a, [1, 2, 3]); return assert.eq(b, [999, 1, 2, 3]);});}, longestCommonSubsequence: function() {test("longestCommonSubsequence [2], [2]", () => {let c; c = longestCommonSubsequence([2], [2]); return assert.eq(c, [2]);}); test("longestCommonSubsequence [2], [2, 1]", () => {let c; c = longestCommonSubsequence([2], [2, 1]); return assert.eq(c, [2]);}); test("longestCommonSubsequence [2, 1], [2, 1]", () => {let c; c = longestCommonSubsequence([2, 1], [2, 1]); return assert.eq(c, [2, 1]);}); test("longestCommonSubsequence [2, 1, 2], [2, 1]", () => {let c; c = longestCommonSubsequence([2, 1, 2], [2, 1]); return assert.eq(c, [2, 1]);}); test("longestCommonSubsequence [1, 2], [2, 1]", () => {let c; c = longestCommonSubsequence([1, 2], [2, 1]); return assert.eq(c, [1]);}); test("longestCommonSubsequence [1], [2, 1, 4]", () => {let c; c = longestCommonSubsequence([1], [2, 1, 4]); return assert.eq(c, [1]);}); test("minimumOrderedOverlappingMerge [1,2], [2, 1]", () => {let c; c = minimumOrderedOverlappingMerge([1, 2], [2, 1]); return assert.eq(c, [2, 1]);}); test("minimumOrderedOverlappingMerge [1,3], [2, 1]", () => {let c; c = minimumOrderedOverlappingMerge([1, 3], [2, 1]); return assert.eq(c, [2, 1, 3]);}); return test("minimumOrderedOverlappingMerge [1], [2, 1, 4]", () => {let c; c = minimumOrderedOverlappingMerge([1], [2, 1, 4]); return assert.eq(c, [2, 1, 4]);});}, stableSort: function() {test("stableSort works like sort (except for stability)", () => {let arrays; arrays = [[1, 2, 3, 4], [4, 3, 2, 1], [3, 1, 2, 4], [], [1], [2, 1], [1, 2, 3], [1, 1], [2, 3, 1, 1, 4]]; return Caf.each2(arrays, (a) => assert.eq(a.sort(), stableSort(a)));}); return test("stableSort maintains order of 'same' elements", () => {let list, stableSortedList, sortFunciton; list = [[2, "a"], [1, "b"], [1, "c"], [0, "f"], [1, "d"], [1, "e"]]; stableSortedList = [[0, "f"], [1, "b"], [1, "c"], [1, "d"], [1, "e"], [2, "a"]]; sortFunciton = (a, b) => a[0] - b[0]; return assert.eq(stableSortedList, stableSort(list, sortFunciton));});}, "slice helpers": function() {test("leftOfIndex null array", () => assert.eq(null, leftOfIndex(null, 0))); test("rightOfIndex null array", () => assert.eq(null, rightOfIndex(null, 0))); test("leftOfIndex 0", () => assert.eq([], leftOfIndex([1, 2, 3, 4, 5, 6], 0))); test("rightOfIndex 0", () => assert.eq([2, 3, 4, 5, 6], rightOfIndex([1, 2, 3, 4, 5, 6], 0))); test("leftOfIndex -2", () => assert.eq([1, 2, 3, 4], leftOfIndex([1, 2, 3, 4, 5, 6], -2))); test("rightOfIndex -2", () => assert.eq([6], rightOfIndex([1, 2, 3, 4, 5, 6], -2))); test("leftOfIndex -1", () => assert.eq([1, 2, 3, 4, 5], leftOfIndex([1, 2, 3, 4, 5, 6], -1))); test("rightOfIndex -1", () => assert.eq([], rightOfIndex([1, 2, 3, 4, 5, 6], -1))); test("leftOfIndex 3", () => assert.eq([1, 2, 3], leftOfIndex([1, 2, 3, 4, 5, 6], 3))); test("rightOfIndex 3", () => assert.eq([5, 6], rightOfIndex([1, 2, 3, 4, 5, 6], 3))); test("leftOfIndex 5", () => assert.eq([1, 2, 3, 4, 5], leftOfIndex([1, 2, 3, 4, 5, 6], 5))); test("rightOfIndex 5", () => assert.eq([], rightOfIndex([1, 2, 3, 4, 5, 6], 5))); test("leftOfIndex 6", () => assert.eq([1, 2, 3, 4, 5, 6], leftOfIndex([1, 2, 3, 4, 5, 6], 6))); test("rightOfIndex 6", () => assert.eq([], rightOfIndex([1, 2, 3, 4, 5, 6], 6))); test("leftOfIndex 7", () => assert.eq([1, 2, 3, 4, 5, 6], leftOfIndex([1, 2, 3, 4, 5, 6], 7))); test("rightOfIndex 7", () => assert.eq([], rightOfIndex([1, 2, 3, 4, 5, 6], 7))); test("leftOf one match", () => assert.eq([1, 2, 3], leftOf([1, 2, 3, 4, 5, 6], 4))); test("rightOf one match ", () => assert.eq([5, 6], rightOf([1, 2, 3, 4, 5, 6], 4))); test("leftOf no match", () => assert.eq([1, 2, 3, 4, 5, 6], leftOf([1, 2, 3, 4, 5, 6], 400))); test("rightOf no match ", () => assert.eq([], rightOf([1, 2, 3, 4, 5, 6], 400))); test("leftOf two matches", () => assert.eq([1], leftOf([1, 4, 3, 4, 5, 6], 4))); test("rightOf two matches", () => assert.eq([3, 4, 5, 6], rightOf([1, 4, 3, 4, 5, 6], 4))); return test("splitArray", () => assert.eq([[1, 2], [4, 5, 6]], splitArray([1, 2, 3, 4, 5, 6], 3)));}, findSortedFirst: function() {test("empty or null/undefined array returns undefined", () => {assert.eq(undefined, findSortedFirst([])); assert.eq(undefined, findSortedFirst(null)); return assert.eq(undefined, findSortedFirst(undefined));}); test("numbers", () => {assert.eq(1, findSortedFirst([3, 1, 2])); assert.eq(1, findSortedFirst([1, 2, 3])); return assert.eq(1, findSortedFirst([1, 3, 2]));}); return test("custom compareFunction with numbers", () => {assert.eq(3, findSortedFirst([3, 1, 2], (a, b) => b - a)); assert.eq(3, findSortedFirst([1, 2, 3], (a, b) => b - a)); return assert.eq(3, findSortedFirst([1, 3, 2], (a, b) => b - a));});}, w: function() {testEq(w, "this", ["this"]); testEq(w, "this ~!@#$%^&*()_+{}|:<>? stinks", ["this", "~!@#$%^&*()_+{}|:<>?", "stinks"]); testEq(w, "this is it", ["this", "is", "it"]); testEq(w, ["this is", "it also"], ["this", "is", "it", "also"]); return testEq(w, [123, "it also", {foo: ["baz it", ["keep together"]]}], [123, "it", "also", {foo: ["baz it", ["keep together"]]}]);}, a: function() {testEq(a, [], []); testEq(a, [null], [null]); testEq(a, [undefined], [undefined]); testEq(a, [0], [0]); testEq(a, [false], [false]); testEq(a, [1, 2, 3], [1, 2, 3]); return testEq(a, [1, [2, 3]], [1, [2, 3]]);}});});});
//# sourceMappingURL=ArrayExtensions.test.js.map
