// Generated by CoffeeScript 1.12.7
(function() {
  var Merge, compactFlatten, isPlainObject,
    slice = [].slice;

  compactFlatten = require("./ArrayCompactFlatten").compactFlatten;

  isPlainObject = require('./Types').isPlainObject;

  module.exports = Merge = (function() {
    var _deepMerge, deepMerge, merge, mergeInto, mergeIntoWithNullDeletes, pureMerge;

    function Merge() {}


    /*
    
    merge "flattens" its args and then adds all keys from all objects in
    the list into a new object which is returned.
    
    return: new object
    
    The first object's keys are added first. If two or more objects have the same
    keys, the value set in the result is the last object's in the list with that key.
     */

    Merge.merge = merge = function() {
      var all;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return mergeInto({}, all);
    };

    Merge.mergeWithoutNulls = function() {
      var all;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return mergeIntoWithNullDeletes({}, all);
    };

    Merge.mergeWith = function() {
      var all;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return mergeInto({}, this, all);
    };

    Merge.mergeWithSelf = Merge.mergeWith;


    /*
    The same as 'merge' with one difference:
    
    Instead of a new object, all objects are merged into the first object in the list.
    
    return: first object in the flattened list
    return: null if no source objects
     */

    Merge.mergeInto = mergeInto = function() {
      var all, j, k, len, result, source, sources, v;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      result = sources[0] || {};
      for (j = 0, len = sources.length; j < len; j++) {
        source = sources[j];
        if (source !== result) {
          for (k in source) {
            v = source[k];
            if (v !== void 0) {
              result[k] = v;
            }
          }
        }
      }
      return result;
    };

    Merge.mergeIntoWithNullDeletes = mergeIntoWithNullDeletes = function() {
      var all, j, k, len, result, source, sources, v;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      result = sources[0] || {};
      for (j = 0, len = sources.length; j < len; j++) {
        source = sources[j];
        if (source !== result) {
          for (k in source) {
            v = source[k];
            switch (false) {
              case v == null:
                result[k] = v;
                break;
              case v !== null:
                delete result[k];
            }
          }
        }
      }
      return result;
    };


    /*
    Just like mergeInfo except only merge into the result object
    UNLESS 'result' already has that property with a non-undefined value.
    
    if
      mergeInfo a, b is just like merge a, b except it modifies and returns a instead of returning a new object
    then
      mergeIntoUnless b, a is just like merge a, b except it modifies and returns b instead of returning a new object
    
    Note: mergeIntoUnless a, b, c, d, e, f is like merge f, e, d, c, b, a
     */

    Merge.mergeIntoUnless = function() {
      var all, i, j, k, ref, result, source, sources, v;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      result = sources[0] || {};
      for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
        source = sources[i];
        for (k in source) {
          v = source[k];
          if (result[k] === void 0) {
            result[k] = v;
          }
        }
      }
      return result;
    };

    Merge.deepMerge = deepMerge = function() {
      var all, array, k, out, ref, v, val;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ref = out = merge(array = compactFlatten(all));
      for (k in ref) {
        v = ref[k];
        if (isPlainObject(v)) {
          out[k] = _deepMerge((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = array.length; j < len; j++) {
              val = array[j];
              results.push(val[k]);
            }
            return results;
          })());
        }
      }
      return out;
    };

    _deepMerge = function(array) {
      var k, out, ref, v, val;
      ref = out = merge(array = compactFlatten(array));
      for (k in ref) {
        v = ref[k];
        if (isPlainObject(v)) {
          out[k] = _deepMerge((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = array.length; j < len; j++) {
              val = array[j];
              results.push(val[k]);
            }
            return results;
          })());
        }
      }
      return out;
    };

    Merge.hasAllProps = function(o1, o2) {
      var k, v;
      for (k in o1) {
        v = o1[k];
        if (!o2.hasOwnProperty(k)) {
          return false;
        }
      }
      return true;
    };

    Merge.pureMerge = pureMerge = function() {
      var all, j, last, len, source, sources;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      if (sources.length === 1) {
        return sources[0];
      }
      last = sources[sources.length - 1];
      for (j = 0, len = sources.length; j < len; j++) {
        source = sources[j];
        if (source !== last) {
          if (!Merge.hasAllProps(source, last)) {
            return Merge.merge(sources);
          }
        }
      }
      return last;
    };


    /*
    I might consider adding "o" - which works like Object-Tree constructors:
      First, it compact-flattens args
      Second, it gathers up and merges all plain-objects in its args list
      Last, all remaining items get added to the "children" list
    The question is, what does it return? Options:
    
      OPTION: If only plain-objects after compact-flatten, just return the merged object ELSE:
    
    Options if both objects and non-object values are present:
      a. return compactFlatten [plainObject, nonObjectValues]
      b. return merge plainObject, children: nonObjectValues
      c. return new MClass plainObject, nonObjectValues
        class MClass extends BaseObject
          @properties "props children"
          constructor: (@props, @children) ->
     */

    Merge.m = pureMerge;

    return Merge;

  })();

}).call(this);

//# sourceMappingURL=Merge.js.map
