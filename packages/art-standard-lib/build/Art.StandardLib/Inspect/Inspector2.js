// Generated by CoffeeScript 1.12.7
(function() {
  var Inspected, Inspector2, Map, MinimalBaseObject, escapeJavascriptString, isArray, isBrowserObject, isClass, isDate, isFunction, isHTMLImageElement, isObject, isPlainObject, isRegExp, isString, objectName, parentString, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  MinimalBaseObject = require("../MinimalBaseObject");

  Map = require("../Map");

  Inspected = require("./Inspected");

  escapeJavascriptString = require('../StringExtensions').escapeJavascriptString;

  ref = require('../TypesExtended'), isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isPlainObject = ref.isPlainObject, isClass = ref.isClass, isDate = ref.isDate, isRegExp = ref.isRegExp, objectName = ref.objectName, isBrowserObject = ref.isBrowserObject;

  isHTMLImageElement = self.HTMLImageElement ? function(obj) {
    return obj instanceof HTMLImageElement;
  } : function() {
    return false;
  };

  parentString = (function(_this) {
    return function(distance) {
      switch (distance) {
        case 0:
          return "parent";
        case 1:
          return "grandparent";
        case 2:
          return "great grandparent";
        default:
          return "great^" + (distance - 1) + " grandparent";
      }
    };
  })(this);

  module.exports = Inspector2 = (function(superClass) {
    extend(Inspector2, superClass);

    function Inspector2(options) {
      if (options == null) {
        options = {};
      }
      this.inspectObject = bind(this.inspectObject, this);
      this.inspectWithToImage = bind(this.inspectWithToImage, this);
      this.inspectHTMLImageElement = bind(this.inspectHTMLImageElement, this);
      this.inspectArray = bind(this.inspectArray, this);
      this.withImages = options.withImages;
      this.maxLength = options.maxLength || 1000;
      this.allowCustomInspectors = !options.noCustomInspectors;
      this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
      this.outArray = [];
      this.length = 0;
      this.depth = 0;
      this.inspectingMap = new Map;
    }

    Inspector2.prototype.inspectArray = function(array) {
      var a;
      return new Inspected.Array((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = array.length; i < len; i++) {
          a = array[i];
          results.push(this.inspectInternal(a));
        }
        return results;
      }).call(this));
    };

    Inspector2.prototype.inspectHTMLImageElement = function(obj) {
      var res;
      res = new Inspected.Object({}, "HTMLImageElement", obj);
      if (!(res.image = obj).complete) {
        this.addPendingTask();
        obj.onload = (function(_this) {
          return function() {
            return _this.completePendingTask();
          };
        })(this);
      }
      return res;
    };

    Inspector2.prototype.inspectWithToImage = function(obj) {
      var name, res;
      name = objectName(obj);
      if (typeof obj.classPathName === "string") {
        name = obj.classPathName;
      }
      if (name === "Object") {
        name = null;
      }
      res = new Inspected.Object({}, name, obj);
      this.addPendingTask();
      obj.toImage().then((function(_this) {
        return function(image) {
          res.image = image;
          return _this.completePendingTask();
        };
      })(this));
      return res;
    };

    Inspector2.prototype.inspectObject = function(obj, recurse) {
      var attributes, i, k, keys, len, name, res, result;
      if (recurse == null) {
        recurse = true;
      }
      attributes = [];
      keys = Object.keys(obj);
      name = objectName(obj);
      if (isFunction(obj) && keys.length === 0) {
        return new Inspected.Core(name + "()");
      } else {
        if (typeof obj.classPathName === "string") {
          name = obj.classPathName;
        }
        if (name === "Object") {
          name = null;
        }
        result = {};
        if (recurse) {
          for (i = 0, len = keys.length; i < len; i++) {
            k = keys[i];
            result[k] = this.inspectInternal(obj[k]);
          }
        }
        res = new Inspected.Object(result, name, obj);
        if (isFunction(obj.inspect)) {
          res.inspected = obj.inspect();
        }
        return res;
      }
    };

    Inspector2.prototype.addPendingTask = function() {
      return this.pendingTasks++;
    };

    Inspector2.prototype.completePendingTask = function() {
      this.pendingTasks--;
      if (this.pendingTasks === 0) {
        return this.completionCallBack();
      }
    };

    Inspector2.prototype.inspectByType = function(obj) {
      if (isFunction(obj != null ? obj.getInspectedObjects : void 0)) {
        obj = obj.getInspectedObjects();
      }
      if (obj === null || obj === void 0 || obj === true || obj === false || typeof obj === "number") {
        return new Inspected.Core(obj);
      } else if (obj === self) {
        return new Inspected.Core("self");
      } else if (isRegExp(obj)) {
        return new Inspected.Core(obj.toString());
      } else if (isString(obj)) {
        return new Inspected.String(obj);
      } else if (isArray(obj)) {
        return this.inspectArray(obj);
      } else if (isClass(obj)) {
        return new Inspected.Core(objectName(obj));
      } else if (isHTMLImageElement(obj)) {
        return this.inspectHTMLImageElement(obj);
      } else if (isDate(obj)) {
        return new Inspected.Core(obj.toString());
      } else if (isBrowserObject(obj)) {
        return new Inspected.Core(objectName(obj));
      } else if (this.withImages && typeof obj.toImage === "function" && !isFunction(obj)) {
        return this.inspectWithToImage(obj);
      } else if (isPlainObject(obj) || isFunction(obj)) {
        return this.inspectObject(obj);
      } else if (isObject(obj)) {
        return this.inspectObject(obj, false);
      } else {
        return new Inspected.Core(objectName(obj));
      }
    };

    Inspector2.prototype.inspectInternal = function(obj) {
      var objDepth, res;
      if (objDepth = this.inspectingMap.get(obj)) {
        return new Inspected.Core("<" + (parentString(this.depth - objDepth)) + ">");
      } else if (this.depth >= this.maxDepth) {
        return new Inspected.Core("<maxDepth reached: " + this.maxDepth + ">");
      } else {
        this.depth++;
        this.inspectingMap.set(obj, this.depth);
        res = this.inspectByType(obj);
        this.inspectingMap["delete"](obj);
        this.depth--;
        return res;
      }
    };

    Inspector2.prototype.inspect = function(obj, callBack) {
      var res;
      this.pendingTasks = 0;
      if (this.withImages && typeof callBack !== "function") {
        throw new Error("callBack required if withImages requested");
      }
      this.completionCallBack = (function(_this) {
        return function() {
          return callBack && callBack(res);
        };
      })(this);
      res = this.inspectInternal(obj);
      if (this.pendingTasks === 0) {
        this.completionCallBack();
      }
      return res;
    };

    return Inspector2;

  })(MinimalBaseObject);

}).call(this);

//# sourceMappingURL=Inspector2.js.map
