// Generated by CoffeeScript 1.12.7
(function() {
  var ArrayExtensions, bound, exactlyOneWordRegex, intRand, isFunction, isNumber, isString, max, modulo, ref, ref1, ref2, wordsRegex,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  ref = require("./MathExtensions"), bound = ref.bound, max = ref.max, intRand = ref.intRand, modulo = ref.modulo;

  ref1 = require('./TypesExtended'), isFunction = ref1.isFunction, isNumber = ref1.isNumber, isString = ref1.isString;

  ref2 = require('./RegExpExtensions'), wordsRegex = ref2.wordsRegex, exactlyOneWordRegex = ref2.exactlyOneWordRegex;

  module.exports = ArrayExtensions = (function() {
    var _moveArrayElementLargeArray, _moveArrayElementSmallArray, a, arrayWithElementMoved, arrayWithInsertedValue, basicCompareFunction, indexOfOrLength, keepAll, keepIfRubyTrue, leftOfIndex, longestCommonSubsequence, moveArrayElement, randomElement, randomSortInPlace, rightOfIndex, w;

    function ArrayExtensions() {}


    /*
    Useful compact and compactFlatten keepTester functions
     */

    ArrayExtensions.keepAll = keepAll = function() {
      return true;
    };

    ArrayExtensions.keepIfRubyTrue = keepIfRubyTrue = function(a) {
      return a !== void 0 && a !== null && a !== false;
    };

    ArrayExtensions.reverseForEach = function(array, f) {
      var p, v;
      for (p = array.length - 1; p >= 0; p += -1) {
        v = array[p];
        f(v);
      }
      return array;
    };

    ArrayExtensions.arrayToTruthMap = function(array) {
      var a, len1, p, res;
      res = {};
      for (p = 0, len1 = array.length; p < len1; p++) {
        a = array[p];
        res[a] = true;
      }
      return res;
    };

    ArrayExtensions.arrayToFalseMap = function(array) {
      var a, len1, p, res;
      res = {};
      for (p = 0, len1 = array.length; p < len1; p++) {
        a = array[p];
        res[a] = false;
      }
      return res;
    };

    ArrayExtensions.arrayAfterEach = function(array, value) {
      var len1, out, p, v;
      out = [];
      for (p = 0, len1 = array.length; p < len1; p++) {
        v = array[p];
        out.push(v);
        out.push(value);
      }
      return out;
    };

    ArrayExtensions.arrayBeforeEach = function(array, value) {
      var len1, out, p, v;
      out = [];
      for (p = 0, len1 = array.length; p < len1; p++) {
        v = array[p];
        out.push(value);
        out.push(v);
      }
      return out;
    };

    ArrayExtensions.arrayBetweenEach = function(array, value) {
      var i, len1, out, p, v;
      out = [];
      for (i = p = 0, len1 = array.length; p < len1; i = ++p) {
        v = array[i];
        if (i > 0) {
          out.push(value);
        }
        out.push(v);
      }
      return out;
    };

    ArrayExtensions.concatInto = function(array, b) {
      return array.push.apply(array, b);
    };

    ArrayExtensions.uniqueValues = function(sortedArray, eqF) {
      var i, len1, p, results, v;
      if (eqF == null) {
        eqF = (function(a, b) {
          return a === b;
        });
      }
      results = [];
      for (i = p = 0, len1 = sortedArray.length; p < len1; i = ++p) {
        v = sortedArray[i];
        if (i === 0 || !eqF(v, sortedArray[i - 1])) {
          results.push(v);
        }
      }
      return results;
    };


    /*
    IN:
      array: an array or falsy value
      element: anything
    OUT:
      array containing element as the last element
    
    EFFECT:
      if array was falsy, a new length-1 array is returned
      else, array was mutated by pushing the current element
    
    WHY?
      Why write this when arrays alread have push?
    
      1) if array is null, this works as desired
      2) this returns array, not array.length
        Returning the array is what Ruby's push does.
        It makes chaining pushes easy.
     */

    ArrayExtensions.push = function(array, element) {
      if (array) {
        array.push(element);
        return array;
      } else {
        return [element];
      }
    };

    ArrayExtensions.peek = function(array, offset) {
      if (offset == null) {
        offset = -1;
      }
      if (array != null) {
        return array[array.length + offset];
      } else {
        return void 0;
      }
    };

    basicCompareFunction = function(a, b) {
      return a - b;
    };

    ArrayExtensions.leftOfIndex = leftOfIndex = function(array, index) {
      if (!array) {
        return array;
      }
      return array.slice(0, index);
    };

    ArrayExtensions.rightOfIndex = rightOfIndex = function(array, index) {
      if (!array) {
        return array;
      }
      if (index < 0) {
        index += array.length;
      }
      return array.slice(index + 1);
    };

    indexOfOrLength = function(array, value) {
      var i;
      if (0 > (i = array.indexOf(value))) {
        return array.length;
      } else {
        return i;
      }
    };

    ArrayExtensions.leftOf = function(array, value) {
      return leftOfIndex(array, indexOfOrLength(array, value));
    };

    ArrayExtensions.rightOf = function(array, value) {
      return rightOfIndex(array, indexOfOrLength(array, value));
    };

    ArrayExtensions.splitArray = function(array, value) {
      var index;
      index = indexOfOrLength(array, value);
      return [leftOfIndex(array, index), rightOfIndex(array, index)];
    };


    /*
    findSortedFirst
    
    Acts as-if it sorted the array and returned the first element.
    
    Details:
      tests each element in the array againts the current "smallest"
      returns the element for which tests "smaller" than every other
      element a is "smaller" than b if compareFunction(a, b) returns >0 value
    
    IN:
      array - the array to search or null
      compareFunction - (a, b) -> # standard compare function
        returns:
          0: if a and b are equal
          <0: if b is greater than a
          >0: if a is greater than b
        default: (a, b) -> a - b
    
    OUT:
      largest value in array or undefined if array is null or length 0
     */

    ArrayExtensions.findSortedFirst = function(array, compareFunction) {
      var element, i, p, ref3, returnElement;
      if (compareFunction == null) {
        compareFunction = basicCompareFunction;
      }
      if (!((array != null ? array.length : void 0) > 0)) {
        return void 0;
      }
      returnElement = array[0];
      for (i = p = 1, ref3 = array.length; p < ref3; i = p += 1) {
        if (0 < compareFunction(returnElement, element = array[i])) {
          returnElement = element;
        }
      }
      return returnElement;
    };

    ArrayExtensions.first = function(array) {
      return array[0];
    };

    ArrayExtensions.second = function(array) {
      return array[1];
    };

    ArrayExtensions.third = function(array) {
      return array[2];
    };

    ArrayExtensions.forth = function(array) {
      return array[3];
    };

    ArrayExtensions.fifth = function(array) {
      return array[4];
    };

    ArrayExtensions.last = function(array) {
      if (array) {
        return array[array.length - 1];
      } else {
        return void 0;
      }
    };

    ArrayExtensions.pushIfNotPresent = function(array, item) {
      if (indexOf.call(array, item) >= 0) {
        return false;
      } else {
        array.push(item);
        return true;
      }
    };

    ArrayExtensions.pushUnique = ArrayExtensions.pushIfNotPresent;


    /*
    IN:
      array: []
      randomizer:               [optional] () -> [0, 1) random number generator
      selectFromFirstNElements: [optional] int
     */

    ArrayExtensions.randomElement = randomElement = function(array, a, b) {
      var fromFirstN, rand, randomizer;
      rand = isFunction(randomizer = a) ? (fromFirstN = b, randomizer()) : (fromFirstN = a, Math.random());
      return array[rand * (fromFirstN != null ? fromFirstN : array.length) | 0];
    };

    ArrayExtensions.randomSortInPlace = randomSortInPlace = function(array) {
      var a, i, j, len, p, ref3;
      len = array.length;
      for (i = p = ref3 = len - 1; p >= 0; i = p += -1) {
        j = intRand(i);
        a = array[i];
        array[i] = array[j];
        array[j] = a;
      }
      return array;
    };

    ArrayExtensions.arrayWithRandomSort = function(array) {
      if (array) {
        return randomSortInPlace(array.slice());
      } else {
        return [];
      }
    };

    ArrayExtensions.randomSort = ArrayExtensions.arrayWithRandomSort;

    ArrayExtensions.insert = function(array, index, item) {
      if (index < 0) {
        index = array.length + index + 1;
      }
      array.splice(index, 0, item);
      return array;
    };

    ArrayExtensions.arrayWithInsertedValue = arrayWithInsertedValue = function(array, index, item) {
      return ArrayExtensions.insert(array.slice(), index, item);
    };

    ArrayExtensions.withInserted = arrayWithInsertedValue;

    ArrayExtensions.withSort = function(array, sortFunction) {
      if (array == null) {
        array = [];
      }
      array = array.slice();
      return array.sort(sortFunction);
    };

    ArrayExtensions.remove = function(array, index, amount) {
      if (amount == null) {
        amount = 1;
      }
      if (index < 0) {
        index = array.length + index + 1;
      }
      array.splice(index, amount);
      return array;
    };

    ArrayExtensions.removeFirstMatch = function(array, toMatchValue) {
      var index;
      index = array.indexOf(toMatchValue);
      if (index >= 0) {
        return ArrayExtensions.remove(array, index);
      } else {
        return array;
      }
    };

    ArrayExtensions.arrayWithout = function(array, index, amount) {
      if (amount == null) {
        amount = 1;
      }
      if (array != null) {
        if (index == null) {
          index = array.length - 1;
        }
        return ArrayExtensions.remove(array.slice(), index, amount);
      } else {
        return [];
      }
    };

    ArrayExtensions.arrayWithoutValue = function(array, value) {
      var index;
      if (array != null) {
        if (0 <= (index = array.indexOf(value))) {
          return ArrayExtensions.remove(array.slice(), index, 1);
        } else {
          return array;
        }
      } else {
        return [];
      }
    };

    ArrayExtensions.arrayWithoutLast = function(array, amount) {
      if (amount == null) {
        amount = 1;
      }
      if ((array != null) && amount < array.length) {
        return array.slice(0, array.length - amount);
      } else {
        return [];
      }
    };

    ArrayExtensions.arrayWith = function(array, value) {
      if (!array) {
        return [value];
      }
      array = array.slice();
      array.push(value);
      return array;
    };

    ArrayExtensions.truncatedArrayWith = function(array, length, value) {
      if (!array) {
        return [value];
      }
      array = array.slice(0, length);
      array.push(value);
      return array;
    };

    ArrayExtensions.poppedArray = function(array) {
      return array.slice(0, array.length - 1);
    };

    ArrayExtensions.arrayWithOne = function(array, value) {
      if (!array) {
        return [value];
      }
      array = array.slice();
      if (indexOf.call(array, value) < 0) {
        array.push(value);
      }
      return array;
    };

    ArrayExtensions.arrayWithUnique = ArrayExtensions.arrayWithOne;

    ArrayExtensions.slice = function(a, b, c) {
      return arraySlice.call(a, b, c);
    };

    ArrayExtensions.shuffleArray = function(a) {
      var i, j, t;
      i = a.length;
      while (--i > 0) {
        j = ~~(Math.random() * (i + 1));
        t = a[j];
        a[j] = a[i];
        a[i] = t;
      }
      return a;
    };

    ArrayExtensions._moveArrayElementLargeArray = _moveArrayElementLargeArray = function(array, from, to) {
      array.splice(to, 0, array.splice(from, 1)[0]);
      return array;
    };

    ArrayExtensions._moveArrayElementSmallArray = _moveArrayElementSmallArray = function(array, from, to) {
      var i, p, q, ref3, ref4, ref5, ref6, tmp;
      from = from | 0;
      to = to | 0;
      tmp = array[from];
      if (from < to) {
        for (i = p = ref3 = from, ref4 = to - 1; p <= ref4; i = p += 1) {
          array[i] = array[i + 1];
        }
      } else {
        for (i = q = ref5 = from, ref6 = to + 1; q >= ref6; i = q += -1) {
          array[i] = array[i - 1];
        }
      }
      array[to] = tmp;
      return array;
    };

    ArrayExtensions.moveArrayElement = moveArrayElement = function(array, from, to) {
      from = modulo(from | 0, array.length);
      to = modulo(to | 0, array.length);
      if (Math.abs(from - to) > 300) {
        _moveArrayElementLargeArray(array, from, to);
      } else {
        _moveArrayElementSmallArray(array, from, to);
      }
      return array;
    };

    ArrayExtensions.arrayWithElementMoved = arrayWithElementMoved = function(array, from, to) {
      from = modulo(from | 0, array.length);
      to = modulo(to | 0, array.length);
      if (from === to) {
        return array;
      }
      array = array.slice();
      return moveArrayElement(array, from, to);
    };

    ArrayExtensions.arrayWithElementValueMoved = function(array, value, to) {
      var from;
      from = array.indexOf(value);
      if (from < 0) {
        return array;
      }
      return arrayWithElementMoved(array, from, to);
    };

    ArrayExtensions.arrayWithElementReplaced = function(array, value, index) {
      array = array.slice();
      array[index] = value;
      return array;
    };

    ArrayExtensions.arrayWithAllButLast = function(array, amount) {
      if (amount == null) {
        amount = 1;
      }
      if (array) {
        return array.slice(0, array.length - amount);
      } else {
        return [];
      }
    };


    /*
    stableSort is an in-place, stable sort
    
    "stable" means that if two elements are 'equal' under the compare test, their order won't
    change with respect to each other.
    
    NOTE: array.sort is not guaranteed to be stable
     */

    ArrayExtensions.stableSort = function(array, compare) {
      var a, b, i, length, notSorted, p, ref3;
      compare || (compare = function(a, b) {
        return a - b;
      });
      notSorted = true;
      length = array.length;
      while (notSorted) {
        notSorted = false;
        for (i = p = 1, ref3 = length; p < ref3; i = p += 1) {
          if (compare(a = array[i - 1], b = array[i]) > 0) {
            array[i - 1] = b;
            array[i] = a;
            notSorted = true;
          }
        }
      }
      return array;
    };

    ArrayExtensions.longestCommonSubsequence = longestCommonSubsequence = function(a, b) {
      var c, diag, i, j, latch, lcs, left, m, n, p, q, r, ref3, ref4, ref5, row, s;
      lcs = [];
      row = [];
      c = [];
      if (m < n) {
        s = a;
        a = b;
        b = s;
      }
      m = a.length;
      n = b.length;
      for (j = p = 0, ref3 = n; p < ref3; j = p += 1) {
        row[j] = 0;
      }
      for (i = q = 0, ref4 = m; q < ref4; i = q += 1) {
        c[i] = row = row.slice();
        diag = 0;
        for (j = r = 0, ref5 = n - 1; r <= ref5; j = r += 1) {
          latch = row[j];
          if (a[i] === b[j]) {
            row[j] = diag + 1;
          } else {
            left = row[j - 1] || 0;
            if (left > row[j]) {
              row[j] = left;
            }
          }
          diag = latch;
        }
      }
      i--;
      j--;
      while (i > -1 && j > -1) {
        switch (c[i][j]) {
          case i && c[i - 1][j]:
            i--;
            continue;
          case j && c[i][j - 1]:
            j--;
            break;
          default:
            j--;
            lcs.unshift(a[i]);
            i--;
            continue;
        }
      }
      return lcs;
    };

    ArrayExtensions.minimumOrderedOverlappingMerge = function(a, b) {
      var ai, bj, c, ck, i, j, k, l, m, n, o, out;
      c = longestCommonSubsequence(a, b);
      m = a.length;
      n = b.length;
      o = c.length;
      out = new Array(n);
      i = 0;
      j = 0;
      k = 0;
      l = 0;
      while (i < m && j < n && k < o) {
        ai = a[i];
        bj = b[j];
        ck = c[k];
        if (ai === ck && bj === ck) {
          i++;
          j++;
          k++;
          out[l++] = ai;
        } else if (ai !== ck) {
          i++;
          if (indexOf.call(b, ai) < 0) {
            out[l++] = ai;
          }
        } else {
          j++;
          out[l++] = bj;
        }
      }
      while (i < m) {
        ai = a[i++];
        if (indexOf.call(b, ai) < 0) {
          out[l++] = ai;
        }
      }
      while (j < n) {
        out[l++] = b[j++];
      }
      return out;
    };

    ArrayExtensions.wordsArray = w = function() {
      var arg, args, len1, out, p;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      out = [];
      for (p = 0, len1 = args.length; p < len1; p++) {
        arg = args[p];
        if (isString(arg) && !arg.match(exactlyOneWordRegex)) {
          out = out.concat(arg.match(wordsRegex));
        } else {
          out.push(arg);
        }
      }
      return out;
    };

    ArrayExtensions.wordArray = ArrayExtensions.wordsArray;

    ArrayExtensions.w = ArrayExtensions.wordsArray;

    ArrayExtensions.a = a = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return args;
    };

    return ArrayExtensions;

  })();

}).call(this);

//# sourceMappingURL=ArrayExtensions.js.map
