"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Date", "describe", "test", "assert", "toSeconds", "toMilliseconds", "abs", "toDate", "formatDate", "firstOfHour", "firstOfDay", "firstOfWeek", "firstOfMonth", "firstOfYear", "merge", "firstOfDayLocale", "firstOfWeekLocale", "firstOfMonthLocale", "firstOfYearLocale"], [global, require('./StandardImport')], (Date, describe, test, assert, toSeconds, toMilliseconds, abs, toDate, formatDate, firstOfHour, firstOfDay, firstOfWeek, firstOfMonth, firstOfYear, merge, firstOfDayLocale, firstOfWeekLocale, firstOfMonthLocale, firstOfYearLocale) => {let date, milliseconds, roundedIntDiv1000, seconds, values; date = new Date(milliseconds = 1497123141167); roundedIntDiv1000 = function(v) {return v / 1000 + .5 | 0;}; seconds = milliseconds / 1000; values = {date, seconds, milliseconds}; return describe({basic: function() {Caf.each2(values, (value, valueName) => {test(`toSeconds ${Caf.toString(valueName)}`, () => {let v; assert.isNumber(v = toSeconds(value)); return assert.eq(seconds, v);}); test(`toMilliseconds ${Caf.toString(valueName)}`, () => {let v; assert.isNumber(v = toMilliseconds(value)); return assert.ok(abs(milliseconds - v) < 1000);}); return test(`toDate ${Caf.toString(valueName)}`, () => {let v; assert.isDate(v = toDate(value)); return assert.ok(abs(v - milliseconds) < 1000);});}); test("toSeconds null", () => assert.isNumber(toSeconds(null))); test("toMilliseconds null", () => assert.isNumber(toMilliseconds(null))); test("toDate null", () => assert.isDate(toDate(null))); return test("formatDate", () => {let baseline; baseline = formatDate(date); assert.eq(baseline, formatDate(seconds)); return assert.eq(baseline, formatDate(milliseconds));});}, firstOf: function() {let breakOut, testFirstOf, testTime; breakOut = (time) => {let d; d = toDate(time); return {year: d.getUTCFullYear(), month: d.getUTCMonth(), day: d.getUTCDate(), hour: d.getUTCHours(), min: d.getUTCMinutes(), dayOfWeek: d.getUTCDay()};}; testFirstOf = (name, f, m) => test(name, () => {let v; v = f(testTime); return assert.eq(breakOut(v), merge(breakOut(testTime), m));}); testTime = 1528587452531; testFirstOf("firstOfHour", firstOfHour, {min: 0}); testFirstOf("firstOfDay", firstOfDay, {hour: 0, min: 0}); testFirstOf("firstOfWeek", firstOfWeek, {hour: 0, min: 0, dayOfWeek: 1, day: 4}); testFirstOf("firstOfMonth", firstOfMonth, {year: 2018, month: 5, hour: 0, min: 0, dayOfWeek: 5, day: 1}); return testFirstOf("firstOfYear", firstOfYear, {year: 2018, month: 1, hour: 0, min: 0, dayOfWeek: 4, day: 1});}, firstOfLocale: function() {let breakOut, testFirstOfLocale, testTime; breakOut = (time) => {let d; d = toDate(time); return {year: d.getFullYear(), month: d.getMonth(), day: d.getDate(), hour: d.getHours(), min: d.getMinutes(), dayOfWeek: d.getDay()};}; testFirstOfLocale = (name, f, m) => test(name, () => {let v; v = f(testTime); return assert.eq(breakOut(v), merge(breakOut(testTime), m), "hello, context!");}); testTime = 1528587452531; testFirstOfLocale("firstOfDayLocale", firstOfDayLocale, {hour: 0, min: 0}); testFirstOfLocale("firstOfWeekLocale", firstOfWeekLocale, {hour: 0, min: 0, dayOfWeek: 1, day: 4}); testFirstOfLocale("firstOfMonthLocale", firstOfMonthLocale, {year: 2018, month: 5, hour: 0, min: 0, dayOfWeek: 5, day: 1}); return testFirstOfLocale("firstOfYearLocale", firstOfYearLocale, {year: 2018, month: 1, hour: 0, min: 0, dayOfWeek: 4, day: 1});}, regressions: {firstOfDay: function() {return test("firstOfDay firstOfDay *many*", () => {let start, end, to, i, by; start = 1537142400 - 100; end = start + 3600 * 24; return (to = end, i = start, by = (i < to) ? 1 : -1, (() => {while (by > 0 && i <= to || by < 0 && i >= to) {let first, second; seconds = i; first = firstOfDay(seconds); second = firstOfDay(seconds); if (first !== second) {assert.eq(first, second, `expected a == b for a = firstOfDay b = firstOfDay ${Caf.toString(seconds)}`);}; i += by;};})(), to);});}, firstOfWeek: function() {test("firstOfWeek firstOfWeek *many*", () => {let start, end, to, i; start = 1537142400 - 100; end = start + 3600 * 24 * 7; return (to = end, i = start, (() => {while (i <= to) {let first, second, firstM, secondM; seconds = i; first = firstOfWeek(seconds); second = firstOfWeek(seconds); if (first !== second) {assert.eq(first, second, `expected a == b for a = firstOfWeek b = firstOfWeek ${Caf.toString(seconds)}`);}; firstM = firstOfMonth(seconds); secondM = firstOfMonth(seconds); if (firstM !== secondM) {assert.eq(firstM, secondM, `expected a == b for a = firstOfMonth b = firstOfMonth ${Caf.toString(seconds)}`);}; i += 61;};})(), to);}); return test("badNumbers", () => {assert.rejects(() => firstOfWeek(NaN)); assert.rejects(() => firstOfWeek(1 / 0)); assert.lte(1537142300, firstOfWeek(undefined), "undefined"); return assert.lte(1537142300, firstOfWeek(null), "null");});}}});});});
//# sourceMappingURL=DateExtensions.test.js.map
