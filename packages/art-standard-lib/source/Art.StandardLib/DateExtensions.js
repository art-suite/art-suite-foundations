// Generated by CoffeeScript 1.12.7
(function() {
  var dateFormat, firstOfDay, firstOfDayLocale, firstOfHour, firstOfMonth, firstOfMonthLocale, formattedInspect, isDate, isNumber, isString, march1973InMilliseconds, ref, secondsPerDay, secondsPerHour, toDate, toMilliseconds, toSeconds,
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  ref = require('./Core/Types'), isString = ref.isString, isNumber = ref.isNumber, isDate = ref.isDate;

  formattedInspect = require('./Inspect').formattedInspect;

  march1973InMilliseconds = 100000000000;

  module.exports = {

    /*
      Mask              | Description
      ----              | -----------
      `d`               | Day of the month as digits; no leading zero for single-digit days.
      `dd`              | Day of the month as digits; leading zero for single-digit days.
      `ddd`             | Day of the week as a three-letter abbreviation.
      `dddd`            | Day of the week as its full name.
      `m`               | Month as digits; no leading zero for single-digit months.
      `mm`              | Month as digits; leading zero for single-digit months.
      `mmm`             | Month as a three-letter abbreviation.
      `mmmm`            | Month as its full name.
      `yy`              | Year as last two digits; leading zero for years less than 10.
      `yyyy`            | Year represented by four digits.
      `h`               | Hours; no leading zero for single-digit hours (12-hour clock).
      `hh`              | Hours; leading zero for single-digit hours (12-hour clock).
      `H`               | Hours; no leading zero for single-digit hours (24-hour clock).
      `HH`              | Hours; leading zero for single-digit hours (24-hour clock).
      `M`               | Minutes; no leading zero for single-digit minutes.
      `MM`              | Minutes; leading zero for single-digit minutes.
      `N`               | ISO 8601 numeric representation of the day of the week.
      `o`               | GMT/UTC timezone offset, e.g. -0500 or +0230.
      `s`               | Seconds; no leading zero for single-digit seconds.
      `ss`              | Seconds; leading zero for single-digit seconds.
      `S`               | The date's ordinal suffix (st, nd, rd, or th). Works well with `d`.
      `l`               |  Milliseconds; gives 3 digits.
      `L`               | Milliseconds; gives 2 digits.
      `t`               | Lowercase, single-character time marker string: a or p.
      `tt`              | Lowercase, two-character time marker string: am or pm.
      `T`               | Uppercase, single-character time marker string: A or P.
      `TT`              | Uppercase, two-character time marker string: AM or PM.
      `W`               | ISO 8601 week number of the year, e.g. 42
      `Z`               | US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the
      `'...'`, `"..."`  | Literal character sequence. Surrounding quotes are removed.
      `UTC:`            |  Must be the first four characters of the mask. Converts the date from local time to UTC/GMT/Zulu time before applying the mask. The "UTC:" prefix is removed.
     */
    dateFormat: dateFormat = require("dateformat"),
    formatDate: function(value, format, utc) {
      if (isString(value) && !isString(format)) {
        format = value;
        value = null;
      }
      return dateFormat(toDate(value), format, utc);
    },

    /*
    IN:
      v:
        Date
        OR Number of Seconds since epoch-start
        OR Number of Milliseconds since epoch-start
        OR String:
          if contains only digets with optional decimial
            examples:
              "123"
              "123.456"
    
            toMilliseconds v - 0
    
          else
            toMilliseconds Date.parse v
    OUT:
      Number of Milliseconds since epoch-start
     */
    toMilliseconds: toMilliseconds = function(v) {
      var __, day, match, month, year;
      if (!((v != null) && v !== false)) {
        return Date.now();
      }
      if (isString(v)) {
        v = (function() {
          var ref1;
          switch (false) {
            case !(match = v.match(/^(\d\d\d\d)-(\d\d)(?:-(\d\d))?$/)):
              __ = match[0], year = match[1], month = match[2], day = (ref1 = match[3]) != null ? ref1 : 1;
              return new Date(year - 0, month - 1, day - 0);
            case !/^\d+(\.\d+)?$/.test(v):
              return v - 0;
            default:
              return Date.parse(v);
          }
        })();
      }
      if (isNumber(v)) {
        if (!isFinite(v)) {
          throw new Error("toMilliseconds(" + v + ") - number is not finite");
        }
        if (v < march1973InMilliseconds) {
          return v * 1000;
        } else {
          return v;
        }
      } else if (isDate(v)) {
        return v - 0;
      } else {
        throw new Error("invalid timestamp value: " + v + " (" + (formattedInspect(v)) + ")");
      }
    },

    /*
    IN:
      Date
      OR Number of Seconds since epoch-start
      OR Number of Milliseconds since epoch-start
    OUT:
      (fractional) Number of Seconds since epoch-start
     */
    toSeconds: toSeconds = function(v) {
      if (!((v != null) && v !== false)) {
        return Date.now() / 1000;
      }
      return toMilliseconds(v) / 1000;
    },
    toDate: toDate = function(v) {
      if (!((v != null) && v !== false)) {
        return new Date;
      }
      if (isDate(v)) {
        return v;
      } else {
        return new Date(toMilliseconds(v));
      }
    },
    secondsPerHour: secondsPerHour = 3600,
    secondsPerDay: secondsPerDay = secondsPerHour * 24,
    firstOfHour: firstOfHour = function(time) {
      return ((toSeconds(time) / secondsPerHour) | 0) * secondsPerHour;
    },
    firstOfDay: firstOfDay = function(time) {
      return ((toSeconds(time) / secondsPerDay) | 0) * secondsPerDay;
    },
    firstOfWeek: function(time) {
      return firstOfDay(time) - (modulo(toDate(time).getUTCDay() - 1, 7)) * secondsPerDay;
    },
    firstOfMonth: firstOfMonth = function(time) {
      return firstOfDay(time) - (toDate(time).getUTCDate() - 1) * secondsPerDay;
    },
    firstOfYear: function(time) {
      return firstOfMonth(new Date(toDate(time).getUTCFullYear(), 0, 3));
    },
    firstOfDayLocale: firstOfDayLocale = function(time) {
      return firstOfHour(time) - toDate(time).getHours() * secondsPerHour;
    },
    firstOfWeekLocale: function(time, sundayIsFirst) {
      var day;
      day = toDate(time).getDay();
      if (!sundayIsFirst) {
        day--;
      }
      return firstOfDayLocale(time) - secondsPerDay * (modulo(day, 7));
    },
    firstOfMonthLocale: firstOfMonthLocale = function(time) {
      return firstOfDayLocale(time) - (toDate(time).getDate() - 1) * secondsPerDay;
    },
    firstOfYearLocale: function(time) {
      return new Date(toDate(time).getFullYear(), 0, 1);
    }
  };

}).call(this);

//# sourceMappingURL=DateExtensions.js.map
