// Generated by CoffeeScript 1.12.7
(function() {
  var Inspect, Log, callStack, containsPromises, deepResolve, disableLog, getEnv, isNode, isString, merge, peek, ref, ref1, stripAnsi,
    slice = [].slice;

  Inspect = require('./Inspect/namespace');

  callStack = require('./CallStack').callStack;

  isString = require('./TypesExtended').isString;

  peek = require('./ArrayExtensions').peek;

  merge = require('./Core').merge;

  ref = require('./Promise'), deepResolve = ref.deepResolve, containsPromises = ref.containsPromises;

  ref1 = require('./Environment'), isNode = ref1.isNode, getEnv = ref1.getEnv;

  stripAnsi = require('./Ansi').stripAnsi;

  disableLog = getEnv().disableLog;

  module.exports = Log = (function() {
    var getLogger, noOptions, promiseLogId, standardOptions;

    function Log() {}

    Log.contextString = function(stack, defaultContext) {
      var caller, context;
      if (stack && (caller = stack[1])) {
        if (caller.original) {
          return caller.original;
        } else {
          context = caller["function"] ? caller["class"] ? caller["class"] + "::" + caller["function"] + "()" : caller["function"] + "()" : defaultContext ? defaultContext + ":" : "";
          if (caller.sourceFileName) {
            return "at " + caller.sourceFileName + ("-" + caller.sourceLine + ": ") + context;
          }
        }
      } else {
        return "at " + (defaultContext || "(unknown context)");
      }
    };

    Log.autoSizedIndepect = function(toInspect, maxLength, maxDepth) {
      var depth, inspected;
      if (maxLength == null) {
        maxLength = 512;
      }
      if (maxDepth == null) {
        maxDepth = 10;
      }
      inspected = null;
      depth = maxDepth;
      while ((inspected = Inspect.inspectLean(toInspect, {
          maxDepth: depth,
          maxLength: maxLength
        })).match(/\.\.\.$/)) {
        depth--;
      }
      return inspected;
    };

    Log.loggedParamsString = function(params) {
      if (typeof params === "string") {
        return params;
      } else {
        return Log.autoSizedIndepect(params);
      }
    };

    Log.hideLogging = function() {
      return Log.loggingHidden = true;
    };

    Log.showLogging = function() {
      return Log.loggingHidden = false;
    };

    Log.rawLog = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (!Log.loggingHidden) {
        return console.log.apply(console, args);
      }
    };

    Log.rawErrorLog = function() {
      var args, str;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (Log.loggingHidden) {
        return;
      }
      if (isNode && "".red) {
        str = args.join(' ');
        return console.error(str.red);
      } else {
        return console.error.apply(console, args);
      }
    };

    Log.rawWarningLog = function() {
      var args, str;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (Log.loggingHidden) {
        return;
      }
      if (isNode && "".red) {
        str = args.join(' ');
        return console.warn(str.yellow);
      } else {
        return console.warn.apply(console, args);
      }
    };

    noOptions = {};

    getLogger = function(arg) {
      var isError, isWarning;
      isError = arg.isError, isWarning = arg.isWarning;
      if (isError) {
        return Log.rawErrorLog;
      } else if (isWarning) {
        return Log.rawWarningLog;
      } else {
        return Log.rawLog;
      }
    };

    promiseLogId = 1;

    Log.logCore = function(m, stack, options) {
      if (options == null) {
        options = noOptions;
      }
      if (Log.alternativeLogger) {
        Log.alternativeLogger.logCore(m, stack, options);
      }
      if (options.resolvePromises) {
        return Log.log.resolvePromiseWrapper(m, function(toLog, label) {
          var obj1;
          return Log._logNow((
            obj1 = {},
            obj1["" + label] = toLog,
            obj1
          ), stack, options);
        });
      } else {
        return Log._logNow(m, stack, options);
      }
    };

    Log._logNow = function(m, stack, options) {
      var className, color, logger;
      className = options.className, color = options.color;
      logger = getLogger(options);
      if (isNode) {
        return logger(isString(m) ? color ? m : stripAnsi(m) : Inspect.formattedInspect(m, merge({
          maxLineLength: process.stdout.columns
        }, options)));
      } else {
        return logger(m);
      }
    };

    standardOptions = (function() {
      if (isNode) {
        try {
          eval("require")("colors");
        } catch (error) {}
        return {
          color: process.stdout.isTTY
        };
      } else {
        return {};
      }
    })();

    Log.log = function() {
      var args, ref2;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (disableLog) {
        return peek(args);
      } else {
        return (ref2 = Log.log).withOptions.apply(ref2, [standardOptions].concat(slice.call(args)));
      }
    };

    Log.log.full = function() {
      var args, ref2;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref2 = Log.log).withOptions.apply(ref2, [{
        maxArrayLength: 100000
      }].concat(slice.call(args)));
    };

    Log.log.resolvePromiseWrapper = function(m, logger) {
      var logId, toResolve;
      if (containsPromises(m)) {
        toResolve = m;
        logId = promiseLogId++;
        logger(m, "RESOLVING_" + logId, false);
        return deepResolve(toResolve).then((function(_this) {
          return function(resolvedM) {
            return logger(resolvedM, "RESOLVED_" + logId, true);
          };
        })(this))["catch"]((function(_this) {
          return function(rejected) {
            return logger(rejected, "REJECTED_" + logId, true, true);
          };
        })(this));
      } else {
        return logger(m, false);
      }
    };

    Log.log.withOptions = function() {
      var args, m, options;
      options = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      m = args.length === 1 ? args[0] : args;
      Log.logCore(m, callStack(), options);
      return peek(args);
    };


    /*
    
    IN:
      labelString, value
      OR object with one or more properties (usually just one)
        returns the last value of the objects last key-value pair
    
    EX:
      log.withLabel foo: myObject
       * out: myObject
    
      log.withLabel "foo", myObject
       * out: myObject
     */

    Log.log.withLabel = function(a, b) {
      var k, obj, ret, v;
      if (isString(a)) {
        obj = {};
        obj[a] = b;
        Log.log(obj);
        return b;
      } else {
        ret = null;
        for (k in a) {
          v = a[k];
          ret = v;
        }
        Log.log(obj);
        return ret;
      }
    };

    Log.log.unquoted = function() {
      var args, ref2;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref2 = Log.log).withOptions.apply(ref2, [merge(standardOptions, {
        unquoted: true
      })].concat(slice.call(args)));
    };

    Log.log.labeled = Log.log.withLabel;

    Log.log.error = function() {
      var args, ref2;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref2 = Log.log).withOptions.apply(ref2, [{
        isError: true
      }].concat(slice.call(args)));
    };

    Log.log.warn = function() {
      var args, ref2;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return (ref2 = Log.log).withOptions.apply(ref2, [{
        isWarning: true
      }].concat(slice.call(args)));
    };

    Log.logL = function(obj) {
      var k, ret, v;
      console.warn("DEPRICATED: logL. USE log.labeled");
      ret = null;
      for (k in obj) {
        v = obj[k];
        ret = v;
      }
      Log.log(obj);
      return ret;
    };

    return Log;

  })();

}).call(this);

//# sourceMappingURL=Log.js.map
