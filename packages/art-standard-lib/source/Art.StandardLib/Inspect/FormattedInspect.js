// Generated by CoffeeScript 1.12.7
(function() {
  var FormattedInspect, alignTabs, ansiSafeStringLength, cafScriptWordStringRegExp, colorNames, colorizeFunctions, escapeForBlockString, escapeJavascriptString, formattedInspectArray, formattedInspectObject, formattedInspectRecursive, formattedInspectString, identity, indentLength, indentString, inspect, isFunction, isInspectableArray, isNumber, isPlainArray, isPlainObject, isString, isTypedArray, max, newLineWithIndentString, object, objectKeyCount, objectName, pad, passThroughColorizeFunctions, postWhitespaceFormatting, ref, ref1, stripTrailingWhitespace, toInspectedObjects, w;

  ref = require('../TypesExtended'), isString = ref.isString, objectName = ref.objectName, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isTypedArray = ref.isTypedArray, isFunction = ref.isFunction, isNumber = ref.isNumber;

  max = Math.max;

  ref1 = require('../StringExtensions'), pad = ref1.pad, stripTrailingWhitespace = ref1.stripTrailingWhitespace, escapeJavascriptString = ref1.escapeJavascriptString;

  inspect = require('./Inspector').inspect;

  objectKeyCount = require('../ObjectExtensions').objectKeyCount;

  toInspectedObjects = require('./InspectedObjects').toInspectedObjects;

  w = require('../ArrayExtensions').w;

  object = require('../Iteration').object;

  ansiSafeStringLength = require('../Ansi').ansiSafeStringLength;

  indentString = '  ';

  indentLength = indentString.length;

  newLineWithIndentString = "\n" + indentString;

  formattedInspectObject = function(m, maxLineLength, options) {
    var colorize, finalInspectedValues, forceMultilineOutput, index, inspected, inspectedLength, inspectedValues, k, key, keyCount, objectStart, shouldBeOnOwnLine, v, value;
    colorize = options.colorize;
    inspectedLength = 0;
    forceMultilineOutput = false;
    shouldBeOnOwnLine = false;
    keyCount = 0;
    inspectedValues = (function() {
      var results;
      results = [];
      for (key in m) {
        value = m[key];
        keyCount++;
        inspected = formattedInspectRecursive(value, maxLineLength - indentLength, options);
        if (inspected.match(/\n/)) {
          inspected = inspected.match(/^\[\]/) ? "" + inspected : newLineWithIndentString + inspected.replace(/\n/g, newLineWithIndentString);
          if (!/\n\s*$/.test(inspected)) {
            inspected += "\n";
          }
        } else if (ansiSafeStringLength(inspected) > maxLineLength - (key.length + 2)) {
          inspected = "" + newLineWithIndentString + inspected + "\n";
        }
        if (!/^[-~!@\#$%^&*_+=|\\<>?\/.$\w\u007f-\uffff]+$/.test(key)) {
          key = inspect(key);
        }
        inspectedLength += ansiSafeStringLength(inspected) + key.length + 2;
        forceMultilineOutput || (forceMultilineOutput = shouldBeOnOwnLine);
        shouldBeOnOwnLine = inspected.length > 100 || !inspected.match(/^([^,:]|\(.*\)|\{.*\}|\".*\"|\'.*\'|\[.*\])*$/);
        results.push([key, inspected, value]);
      }
      return results;
    })();
    objectStart = "{}";
    objectStart = colorize.grey(objectStart);
    if (keyCount === 0) {
      return objectStart;
    } else {
      index = 0;
      finalInspectedValues = (function() {
        var j, len, ref2, results;
        results = [];
        for (j = 0, len = inspectedValues.length; j < len; j++) {
          ref2 = inspectedValues[j], k = ref2[0], v = ref2[1], value = ref2[2];
          key = k + ":";
          key = colorize.blue(key);
          results.push(key + "\t" + v);
        }
        return results;
      })();
      return finalInspectedValues.join(!forceMultilineOutput && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2 ? ",\t" : "\n");
    }
  };

  formattedInspectArray = function(m, maxLineLength, options) {
    var arrayStart, colorize, i, inspected, inspectedHasNewlines, inspectedValues, inspectedValuesContainNewlines, j, lastWasArray, lastWasObject, len, lengthOfCommas, lengthOfInspectedValues, lengthOfStartBrackets, maxArrayLength, objectStart, objectsMustBeExplicit, oneLinerOk, suffix, value;
    colorize = options.colorize;
    lengthOfInspectedValues = 0;
    lastWasObject = false;
    lastWasArray = false;
    maxArrayLength = options.maxArrayLength || 100;
    objectsMustBeExplicit = false;
    oneLinerOk = true;
    inspectedValuesContainNewlines = false;
    for (i = j = 0, len = m.length; j < len; i = ++j) {
      value = m[i];
      if (isPlainObject(value)) {
        if (i < m.length - 1) {
          oneLinerOk = false;
        }
        if (lastWasObject) {
          objectsMustBeExplicit = true;
        }
        lastWasObject = true;
      } else {
        lastWasObject = false;
      }
    }
    inspectedValues = (function() {
      var l, len1, ref2, results;
      ref2 = m.slice(0, maxArrayLength);
      results = [];
      for (l = 0, len1 = ref2.length; l < len1; l++) {
        value = ref2[l];
        if (lastWasArray) {
          oneLinerOk = false;
        }
        if (isInspectableArray(value)) {
          lastWasArray = true;
        }
        inspected = formattedInspectRecursive(value, maxLineLength - indentLength, options);
        inspectedHasNewlines = /\n/.test(inspected);
        if (objectsMustBeExplicit && isPlainObject(value) && objectKeyCount(value) > 0) {
          objectStart = "{}";
          objectStart = colorize.grey(objectStart);
          inspected = inspectedHasNewlines ? "" + objectStart + newLineWithIndentString + (inspected.replace(/\n/g, newLineWithIndentString)) : objectStart + " " + inspected;
        }
        if (inspectedHasNewlines) {
          oneLinerOk = false;
          inspected = inspected.replace(/\n/g, newLineWithIndentString);
          if (!/\n\s*$/.test(inspected)) {
            inspected += "\n";
          }
        }
        lengthOfInspectedValues += ansiSafeStringLength(inspected);
        results.push(inspected);
      }
      return results;
    })();
    lengthOfCommas = (inspectedValues.length - 1) * 2;
    lengthOfStartBrackets = 3;
    arrayStart = isTypedArray(m) ? "{" + (objectName(m)) + "}" : "[]";
    if (m.length > maxArrayLength) {
      arrayStart += " <length: " + m.length + ">";
      suffix = "...";
    }
    arrayStart = colorize.grey(arrayStart);
    if (oneLinerOk && maxLineLength >= lengthOfStartBrackets + lengthOfCommas + lengthOfInspectedValues) {
      if (inspectedValues.length === 0) {
        return arrayStart;
      } else {
        return arrayStart + " " + (inspectedValues.join(",\t")) + (suffix != null ? suffix : "");
      }
    } else {
      return arrayStart + "\n  " + (inspectedValues.join("\n  ")) + (suffix ? "\n  " + suffix : '');
    }
  };

  escapeForBlockString = (function(_this) {
    return function(str) {
      return String(str).replace(/[\\\0\b\f\r\t\v\u001b\u2028\u2029]/g, function(x) {
        switch (x) {
          case '\\':
            return '\\\\';
          case '\0':
            return "\\0";
          case '\b':
            return "\\b";
          case '\f':
            return "\\f";
          case '\r':
            return "\\r";
          case '\t':
            return "\\t";
          case '\v':
            return "\\v";
          case '\u2028':
            return "\\u2028";
          case '\u2029':
            return "\\u2029";
          case '\u001b':
            return '\\u001b';
        }
      }).replace(/^[\n ]+|[\n ]+$|[ ]+(?=\n)/g, function(x) {
        return escapeJavascriptString(x, true).replace(/\ /g, '\\s');
      });
    };
  })(this);

  cafScriptWordStringRegExp = /^(?=[^'":])([^\#\s\0-\x20\x7f;,()[\]{}\\]|\#([^{]|$))+$/;

  formattedInspectString = function(m, options) {
    var out;
    out = (function() {
      switch (false) {
        case !(options != null ? options.unquoted : void 0):
          m = m.trim();
          if (/\n/.test(m)) {
            return m;
          } else {
            return m;
          }
          break;
        case !cafScriptWordStringRegExp.test(m):
          return ":" + m;
        case !/[^\n\s].*\n(.|\n)*[^\n\s]/.test(m):
          return ('"""' + newLineWithIndentString + escapeForBlockString(m).replace(/\n/g, newLineWithIndentString)).replace(/\ +\n/g, '\n');
        default:
          return escapeJavascriptString(m);
      }
    })();
    if (options.colorize) {
      return options.colorize.green(out);
    } else {
      return out;
    }
  };

  isInspectableArray = function(v) {
    return isPlainArray(v) || isTypedArray(v);
  };

  formattedInspectRecursive = function(m, maxLineLength, options) {
    if (isPlainObject(m)) {
      return formattedInspectObject(m, maxLineLength, options);
    } else if (isInspectableArray(m)) {
      return formattedInspectArray(m, maxLineLength, options);
    } else if (isString(m)) {
      return formattedInspectString(m, options);
    } else {
      return options.colorize.yellow(inspect(m));
    }
  };


  /*
  TODO:
  
    special mode for a chunk of lines that all have this pattern:
  
      /^\s*([a-z]:\t)*[^\t]+$/
  
    Example:
      hi: there: my: friends: "my value"
      somethingElseIThough: indexAllMyThings: withThis: "foo"
  
    Currently that becomes:
      hi:                   there:            my:       friends: "my value"
      somethingElseIThough: indexAllMyThings: withThis: "foo"
  
    Which is pretty awkward. I want:
      hi: there: my: friends:                           "my value"
      somethingElseIThough: indexAllMyThings: withThis: "foo"
  
    Basically, replace all but the last tab with a space.
  
    But only if ALL lines in a chunk are this pattern.
  
    CounterExample:
      properties:
        autoTags:          type: "text", analyzer: "standard"
        autoText:          type: "text", analyzer: "english"
        updatedAt:         type: "long"
        createdAt:         type: "long"
        title:             type: "text", analyzer: "english"
        userId:            type: "keyword"
        lastPostCreatedAt: type: "long"
        lastPostId:        type: "keyword"
        lastChapterPostId: type: "keyword"
        postCount:         type: "integer"
        followerCount:     type: "integer"
        activityCount:     type: "long"
        messageCount:      type: "long"
        isProfileTopic:    type: "boolean"
        private:           type: "boolean"
  
    Should NOT look like this:
      properties:
        autoTags:                type: "text", analyzer: "standard"
        autoText:                type: "text", analyzer: "english"
        updatedAt: type:         "long"
        createdAt: type:         "long"
        title:                   type: "text", analyzer: "english"
        userId: type:            "keyword"
        lastPostCreatedAt: type: "long"
        lastPostId: type:        "keyword"
        lastChapterPostId: type: "keyword"
        postCount: type:         "integer"
        followerCount: type:     "integer"
        activityCount: type:     "long"
        messageCount: type:      "long"
        isProfileTopic: type:    "boolean"
        private: type:           "boolean"
   */

  alignTabs = function(linesString, maxLineLength) {
    var alignedLines, el, elLength, elements, expandAmount, i, j, l, len, len1, line, lines, maxColumnSizes, maxColumnWidth, r, spaceAvailable, tabStops;
    if (maxLineLength == null) {
      maxLineLength = 10000;
    }
    tabStops = 1;
    lines = linesString.split("\n");
    maxColumnSizes = [];
    maxColumnWidth = maxLineLength / 2;
    for (j = 0, len = lines.length; j < len; j++) {
      line = lines[j];
      if ((elements = line.split("\t")).length > 1) {
        for (i = l = 0, len1 = elements.length; l < len1; i = ++l) {
          el = elements[i];
          if (!(i < elements.length - 1 && (i === 0 || ansiSafeStringLength(el) < maxColumnWidth))) {
            continue;
          }
          if (maxColumnSizes.length === i) {
            maxColumnSizes.push(0);
          }
          maxColumnSizes[i] = max(maxColumnSizes[i], ansiSafeStringLength(el) + 1);
        }
      }
    }
    alignedLines = (function() {
      var len2, n, results;
      results = [];
      for (n = 0, len2 = lines.length; n < len2; n++) {
        line = lines[n];
        spaceAvailable = maxLineLength - ansiSafeStringLength(line);
        elements = line.split("\t");
        r = (function() {
          var len3, o, results1;
          if (elements.length > 1) {
            results1 = [];
            for (i = o = 0, len3 = elements.length; o < len3; i = ++o) {
              el = elements[i];
              elLength = ansiSafeStringLength(el);
              if (i === elements.length - 1) {
                results1.push(el);
              } else if ((maxColumnSizes[i] != null) && (expandAmount = maxColumnSizes[i] - elLength - 1) <= spaceAvailable) {
                spaceAvailable -= expandAmount;
                results1.push(el + pad('', maxColumnSizes[i] - elLength));
              } else {
                spaceAvailable = 0;
                results1.push(el + " ");
              }
            }
            return results1;
          } else {
            return elements;
          }
        })();
        results.push(r.join(""));
      }
      return results;
    })();
    return alignedLines.join("\n");
  };

  postWhitespaceFormatting = function(maxLineLength, string) {
    var alignTabsInSameIndentGroup, indent, j, lastIndent, len, line, outLines, ref2, sameIndentGroup;
    lastIndent = 0;
    sameIndentGroup = [];
    outLines = [];
    alignTabsInSameIndentGroup = function() {
      var str;
      if (!(0 < sameIndentGroup.length)) {
        return;
      }
      str = sameIndentGroup.join("\n");
      sameIndentGroup = [];
      return outLines.push(alignTabs(str, maxLineLength));
    };
    ref2 = string.split("\n");
    for (j = 0, len = ref2.length; j < len; j++) {
      line = ref2[j];
      line = line.replace(/\s+$/g, '');
      if (lastIndent !== (indent = ansiSafeStringLength(line.match(/^ *-?/)[0]))) {
        alignTabsInSameIndentGroup();
      }
      sameIndentGroup.push(line);
      lastIndent = indent;
    }
    alignTabsInSameIndentGroup();
    return outLines.join('\n');
  };

  colorNames = w("red yellow green blue grey");

  colorizeFunctions = object(colorNames, function(c) {
    return function(str) {
      var ref2;
      return (ref2 = str[c]) != null ? ref2 : str;
    };
  });

  identity = function(s) {
    return s;
  };

  passThroughColorizeFunctions = object(colorNames, function() {
    return identity;
  });

  module.exports = FormattedInspect = (function() {
    var failsafeInspect;

    function FormattedInspect() {}

    FormattedInspect.alignTabs = alignTabs;

    FormattedInspect._escapeForBlockString = escapeForBlockString;

    FormattedInspect.formattedInspectString = formattedInspectString;

    FormattedInspect.failsafeInspect = failsafeInspect = function(toInspect) {
      var ref2;
      return ("typeof: " + (typeof toInspect) + "\n") + ("constructor: " + ((toInspect != null ? toInspect.constructor : void 0) && (toInspect != null ? (ref2 = toInspect.constructor) != null ? ref2.name : void 0 : void 0)) + "\n") + (function() {
        switch (false) {
          case !isInspectableArray(toInspect):
            return "length: " + toInspect.length + "\njoined: [" + (toInspect.join(', ')) + "]";
          case !((toInspect != null) && typeof toInspect === 'object'):
            return "keys: " + (Object.keys(toInspect).join(', '));
          default:
            return "toString: " + toInspect;
        }
      })();
    };

    FormattedInspect.formattedInspect = function(toInspect, options) {
      var error, maxLineLength, out, ref2, ref3;
      if (options == null) {
        options = {};
      }
      try {
        if (isNumber(options)) {
          options = {
            maxLineLength: options
          };
        } else {
          if (!isPlainObject(options)) {
            console.error({
              invalid: {
                options: options
              }
            });
            throw new Error("invalid options object type: " + (typeof options));
          }
        }
        if (options.maxLineLength == null) {
          options.maxLineLength = ((ref2 = global.process) != null ? (ref3 = ref2.stdout) != null ? ref3.columns : void 0 : void 0) || 80;
        }
        maxLineLength = options.maxLineLength;
        options.colorize = options.color ? colorizeFunctions : passThroughColorizeFunctions;
        return out = postWhitespaceFormatting(maxLineLength, formattedInspectRecursive(toInspectedObjects(toInspect), maxLineLength, options)).replace(/\n\n$/, "\n");
      } catch (error1) {
        error = error1;
        out = "Error in formattedInspect: " + error + "\n" + (failsafeInspect(toInspect));
        console.error(out, {
          error: error,
          toInspect: toInspect,
          options: options
        });
        return out;
      }
    };

    return FormattedInspect;

  })();

}).call(this);
