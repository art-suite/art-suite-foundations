// Generated by CoffeeScript 1.12.7
(function() {
  var Time, base, commaize, dateSecondMinusPerformanceSecond, initDateSecond, initPerformanceSecond;

  commaize = require("./MathExtensions").commaize;

  self.performance || (self.performance = {});

  (base = self.performance).now || (base.now = self.performance.mozNow || self.performance.msNow || self.performance.oNow || self.performance.webkitNow || function() {
    return new Date().getTime();
  });

  initPerformanceSecond = self.performance.now() / 1000;

  initDateSecond = new Date().getTime() / 1000;

  dateSecondMinusPerformanceSecond = initDateSecond - initPerformanceSecond;

  module.exports = Time = (function() {
    var currentSecond, multiples, timerStack;

    function Time() {}

    multiples = [["mo", 30 * 24 * 60 * 60], ["d", 24 * 60 * 60], ["h", 60 * 60], ["m", 60], ["s", 1], ["ms", .001], ["Î¼s", .000001], ["ns", .000000001]];

    Time.dateSecondToPerformanceSecond = function(dateSecond) {
      return dateSecond - dateSecondMinusPerformanceSecond;
    };

    Time.performanceSecondToDateSecond = function(performanceSecond) {
      return performanceSecond + dateSecondMinusPerformanceSecond;
    };

    Time.timeStampToPerformanceSecond = function(htmlEventTimeStamp) {
      return htmlEventTimeStamp / 1000 - dateSecondMinusPerformanceSecond;
    };

    Time.durationString = function(seconds, levels, divider, recursing) {
      var i, len, multiplier, name, ref, result;
      if (levels == null) {
        levels = 1;
      }
      if (divider == null) {
        divider = ' ';
      }
      if (recursing == null) {
        recursing = false;
      }
      for (i = 0, len = multiples.length; i < len; i++) {
        ref = multiples[i], name = ref[0], multiplier = ref[1];
        if (seconds >= multiplier) {
          result = levels > 1 ? "" + ((seconds / multiplier) | 0) + name + (Time.durationString(seconds % multiplier, levels - 1, divider, true)) : "" + ((.5 + seconds / multiplier) | 0) + name;
          if (recursing) {
            result = divider + result;
          }
          return result;
        }
      }
      if (recursing) {
        return '';
      } else {
        return "0";
      }
    };

    Time.dateAgeInSeconds = function(date) {
      return ((new Date) - date) * .001;
    };

    Time.dateToSeconds = function(date) {
      return post.getTime() * .001;
    };

    Time.perTimeString = function(secondsPerRun) {
      var perTime;
      perTime = 1 / secondsPerRun;
      if (perTime > 100) {
        return (commaize(perTime | 0)) + "/s";
      } else if (perTime * 60 > 100) {
        return (commaize(perTime * 60 | 0)) + "/m";
      } else {
        return (commaize(perTime * 3600 | 0)) + "/h";
      }
    };

    Time.currentMillisecond = function() {
      return self.performance.now();
    };

    Time.currentSecond = currentSecond = function() {
      return self.performance.now() / 1000;
    };

    Time.currentDateSecond = function() {
      return new Date().getTime() / 1000;
    };

    Time.time = function(a, b) {
      var f, fResult, start, timeResult;
      f = b || a;
      start = currentSecond();
      fResult = f();
      timeResult = currentSecond() - start;
      if (b) {
        Neptune.Art.StandardLib.log("time: " + a + " took " + (Time.durationString(timeResult)));
        return fResult;
      } else {
        return timeResult;
      }
    };

    timerStack = [];

    Time.stackTime = function(f) {
      var start, subTimeTotal, timeResult, tsl;
      start = currentSecond();
      timerStack.push(0);
      f();
      subTimeTotal = timerStack.pop();
      timeResult = currentSecond() - start;
      if ((tsl = timerStack.length) > 0) {
        timerStack[tsl - 1] += timeResult;
      }
      return {
        count: 1,
        total: timeResult,
        subTimeTotal: subTimeTotal,
        remainder: timeResult - subTimeTotal
      };
    };

    Time.logTimeSinceLast = function(a) {
      var time;
      time = Time.currentSecond();
      console.log(a + " (" + (Time.lastTime ? Time.durationString(time - Time.lastTime) : void 0) + ")");
      return Time.lastTime = time;
    };

    return Time;

  })();

}).call(this);
