// Generated by CoffeeScript 1.12.7
(function() {
  var ObjectExtensions, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isObject, isPlainArray, isPlainObject, isString, mergeInto, object, present, ref, ref1,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ref = require('./Core'), compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

  ref1 = require('./TypesExtended'), isPlainObject = ref1.isPlainObject, isString = ref1.isString, isObject = ref1.isObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray, present = ref1.present;

  object = require('./Iteration').object;

  module.exports = ObjectExtensions = (function() {
    var _vivifyObjectPathList, expandPathedProperties, objectKeyCount, propertyIsPathed, setPathedProperty, toObjectInternal, vivifyObjectPath, withPropertyPath;

    function ObjectExtensions() {}

    ObjectExtensions.countKeys = function(o) {
      return Object.keys(o).length;
    };

    ObjectExtensions.objectKeyCount = objectKeyCount = function(o) {
      var count, k, v;
      count = 0;
      for (k in o) {
        v = o[k];
        count++;
      }
      return count;
    };

    ObjectExtensions.objectHasKeys = function(o) {
      var b, k;
      for (k in o) {
        b = o[k];
        return true;
      }
      return false;
    };

    ObjectExtensions.objectLength = objectKeyCount;

    _vivifyObjectPathList = function(obj, path, setValue) {
      var field, i, j, len;
      for (i = j = 0, len = path.length; j < len; i = ++j) {
        field = path[i];
        if (field != null) {
          obj = (function() {
            switch (false) {
              case !((setValue != null) && i === path.length - 1):
                return obj[field] = setValue;
              case !isString(field):
                return obj[field] != null ? obj[field] : obj[field] = {};
              default:
                throw new Error("Expecting string or array or null/undefined");
            }
          })();
        }
      }
      return obj;
    };

    ObjectExtensions.vivifyObjectPath = vivifyObjectPath = function() {
      var obj, path;
      obj = arguments[0], path = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!isPlainObject(obj)) {
        throw new Error("obj must be an object");
      }
      return _vivifyObjectPathList(obj, path);
    };

    ObjectExtensions.vivifyObjectPathAndSet = function() {
      var j, obj, path, ref2, value;
      obj = arguments[0], path = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!isPlainObject(obj)) {
        throw new Error("obj must be an object");
      }
      ref2 = path, path = 2 <= ref2.length ? slice.call(ref2, 0, j = ref2.length - 1) : (j = 0, []), value = ref2[j++];
      _vivifyObjectPathList(obj, path, value);
      return value;
    };


    /*
    NOTE:
      null and undefined keys are NOT SUPPORTED
    
      They should be converted to strings, first,
      which is what they would become anyway.
    
    IN: 0 or more args
      out = {}
      list = args
    
      for element in list
        objects: merge into out
        arrays or args lists: recurse using element as the list
        null or undefined: skip
        else out[element] = next element (or undefined if none)
    
    OUT: plain object
     */

    toObjectInternal = function(list, out) {
      var element, j, key, len;
      key = null;
      for (j = 0, len = list.length; j < len; j++) {
        element = list[j];
        if (key) {
          out[key] = element;
          key = null;
        } else if (isPlainObject(element)) {
          mergeInto(out, element);
        } else if (isArrayOrArguments(element)) {
          toObjectInternal(element, out);
        } else if (element != null) {
          key = element;
        }
      }
      if (key) {
        return out[key] = void 0;
      }
    };

    ObjectExtensions.toObject = function() {
      var all, out;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      out = {};
      toObjectInternal(all, out);
      return out;
    };


    /*
    IN:
      inputArray: any array
      transformFunction: (element) -> [key, value]
        default: transforms an array of the form: [[key1, value1], [key2, value2], etc...]
     */

    ObjectExtensions.arrayToMap = function(inputArray, transformFunction) {
      var element, j, key, len, outputMap, ref2, value;
      if (transformFunction == null) {
        transformFunction = function(element) {
          return element;
        };
      }
      outputMap = {};
      for (j = 0, len = inputArray.length; j < len; j++) {
        element = inputArray[j];
        ref2 = transformFunction(element), key = ref2[0], value = ref2[1];
        outputMap[key] = value;
      }
      return outputMap;
    };


    /*
    IN:
      obj: the object to select fields from
    
      2nd argument can be:
        selectFunction: (value, key) -> true / false
    
      OR obj can be followed by any number of strings or arrays in any nesting, possibly with null fields
     */

    ObjectExtensions.select = function() {
      var a, args, j, k, len, obj, prop, properties, result, v;
      obj = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!obj) {
        return {};
      }
      result = {};
      if (isFunction(a = args[0])) {
        if (a.length === 1) {
          for (k in obj) {
            v = obj[k];
            if (a(v)) {
              result[k] = v;
            }
          }
        } else {
          for (k in obj) {
            v = obj[k];
            if (a(k, v)) {
              result[k] = v;
            }
          }
        }
      } else {
        properties = compactFlatten(args);
        for (j = 0, len = properties.length; j < len; j++) {
          prop = properties[j];
          if (((v = obj[prop]) != null) || obj.hasOwnProperty(prop)) {
            result[prop] = v;
          }
        }
      }
      return result;
    };

    ObjectExtensions.selectAll = function() {
      var j, len, obj, prop, properties, ref2, result;
      obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!obj) {
        return {};
      }
      result = {};
      ref2 = compactFlatten(properties);
      for (j = 0, len = ref2.length; j < len; j++) {
        prop = ref2[j];
        result[prop] = obj[prop];
      }
      return result;
    };

    ObjectExtensions.objectWithDefinedValues = function(obj) {
      return object(obj, {
        when: function(v) {
          return v !== void 0;
        }
      });
    };

    ObjectExtensions.objectWithExistingValues = function(obj) {
      return object(obj, {
        when: function(v) {
          return v != null;
        }
      });
    };

    ObjectExtensions.objectWithPresentValues = function(obj) {
      return object(obj, {
        when: function(v) {
          return present(v);
        }
      });
    };

    ObjectExtensions.objectWith = function(obj, k, v) {
      var _k, _v, o;
      o = {};
      for (_k in obj) {
        _v = obj[_k];
        o[_k] = _v;
      }
      o[k] = v;
      return o;
    };

    ObjectExtensions.objectWithout = function() {
      var anythingToDo, j, len, obj, prop, properties, result, v;
      obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (!obj) {
        return {};
      }
      if (properties.length === 1 && !(typeof properties[0] === "string")) {
        properties = properties[0];
      }
      anythingToDo = false;
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        if (obj.hasOwnProperty(prop)) {
          anythingToDo = true;
          break;
        }
      }
      if (anythingToDo) {
        result = {};
        for (prop in obj) {
          v = obj[prop];
          if (indexOf.call(properties, prop) < 0) {
            result[prop] = v;
          }
        }
        return result;
      } else {
        return obj;
      }
    };

    ObjectExtensions.propertyIsPathed = propertyIsPathed = function(key) {
      return !!key.match(/[\s\.\/]/);
    };

    ObjectExtensions.withPropertyPath = withPropertyPath = function(obj, propertyPath, action) {
      var i, j, key, len;
      propertyPath = propertyPath.match(/[^\s\.\/]+/g);
      for (i = j = 0, len = propertyPath.length; j < len; i = ++j) {
        key = propertyPath[i];
        if (i === propertyPath.length - 1) {
          action(obj, key);
        } else {
          obj = obj[key] || (obj[key] = {});
        }
      }
      return obj;
    };

    ObjectExtensions.setPathedProperty = setPathedProperty = function(obj, propertyPath, value) {
      withPropertyPath(obj, propertyPath, function(o, k) {
        return o[k] = value;
      });
      return obj;
    };

    ObjectExtensions.expandPathedProperties = expandPathedProperties = function(obj, into, pathExpansionEnabled) {
      var k, v;
      if (into == null) {
        into = {};
      }
      if (pathExpansionEnabled == null) {
        pathExpansionEnabled = true;
      }
      for (k in obj) {
        v = obj[k];
        if (pathExpansionEnabled && propertyIsPathed(k)) {
          withPropertyPath(into, k, function(o, finalKey) {
            if (isPlainObject(v)) {
              return expandPathedProperties(v, o[finalKey] || (o[finalKey] = {}), true);
            } else {
              return o[finalKey] = v;
            }
          });
        } else if (isPlainObject(v)) {
          expandPathedProperties(v, into[k] || (into[k] = {}), false);
        } else {
          into[k] = v;
        }
      }
      return into;
    };

    return ObjectExtensions;

  })();

}).call(this);

//# sourceMappingURL=ObjectExtensions.js.map
