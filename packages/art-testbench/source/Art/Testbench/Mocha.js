// Generated by CoffeeScript 1.12.7
(function() {
  var DomConsole, MyMocha, NestedSuites, Promise, chai, configure, defineSuitesByNamespaces, defineSuitesByObjectStructure, isArray, isFunction, isNode, isPlainObject, log, merge, ref;

  ref = require('art-standard-lib'), isArray = ref.isArray, isNode = ref.isNode, log = ref.log, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, merge = ref.merge, Promise = ref.Promise;

  configure = require('art-config').configure;

  chai = require('./ArtChai');

  global.assert = chai.assert;

  if (global.document) {
    if (!document.getElementById("mocha")) {
      document.write("<div id=\"mocha\"></div>");
    }
    require("mocha/mocha.css");
    require("!script-loader!mocha/mocha.js");
    DomConsole = require('art-foundation/dev_tools/dom_console');
    mocha.setup({
      reporter: require('./MochaBrowserReporter')
    });
  }


  /*
  Use mocha as normal, but if you added dots (.) in your suite names, this will
  break them out into nested test suites and group suites with the same path together.
  It also alphabetizes them.

  Ex:

    suite "Art.Foundation.Async", asyncTests
    suite "Art.Foundation.Binary", binaryTests
    suite "Art.Atomic", atomicTests

  Becomes:

    suite "Art", ->
      suite "Atomic", atomicTests
      suite "Foundation", ->
        suite "Async", asyncTests
        suite "Binary", binaryTests
   */

  NestedSuites = (function() {
    function NestedSuites() {
      this.suites = {};
      this.suiteFunctions = {};
    }

    NestedSuites.prototype.addSuite = function(name, f) {
      var base, i, len, results, splitName, suiteMap, suitePart;
      ((base = this.suiteFunctions)[name] || (base[name] = [])).push(f);
      splitName = name.split('.');
      suiteMap = this.suites;
      results = [];
      for (i = 0, len = splitName.length; i < len; i++) {
        suitePart = splitName[i];
        results.push(suiteMap = (suiteMap[suitePart] || (suiteMap[suitePart] = {})));
      }
      return results;
    };

    NestedSuites.prototype._createMochaSuites = function(suites, suitePath) {
      var i, len, ref1, results, subSuites, suitePart;
      if (suites == null) {
        suites = this.suites;
      }
      if (suitePath == null) {
        suitePath = null;
      }
      ref1 = Object.keys(suites);
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        suitePart = ref1[i];
        subSuites = suites[suitePart];
        results.push((function(_this) {
          return function(suitePart, subSuites) {
            var path, self;
            path = suitePath ? suitePath + "." + suitePart : suitePart;
            self = _this;
            return suite(suitePart, function() {
              var f, functions, j, len1, results1;
              self._createMochaSuites(subSuites, path);
              if (functions = self.suiteFunctions[path]) {
                results1 = [];
                for (j = 0, len1 = functions.length; j < len1; j++) {
                  f = functions[j];
                  results1.push(f.call(this));
                }
                return results1;
              }
            });
          };
        })(this)(suitePart, subSuites));
      }
      return results;
    };

    NestedSuites.prototype.groupTestSuites = function(defineAllTests) {
      var oldSuite;
      oldSuite = global.suite;
      global.suite = (function(_this) {
        return function(name, f) {
          return _this.addSuite(name, f);
        };
      })(this);
      return Promise.resolve(defineAllTests(chai)).then(defineSuitesByNamespaces).then((function(_this) {
        return function() {
          global.suite = oldSuite;
          if (typeof mocha !== "undefined" && mocha !== null) {
            mocha.setup('tdd');
          }
          return _this._createMochaSuites();
        };
      })(this));
    };

    NestedSuites.prototype.groupTestSuitesSync = function(defineAllTests) {
      var oldSuite;
      oldSuite = global.suite;
      global.suite = (function(_this) {
        return function(name, f) {
          return _this.addSuite(name, f);
        };
      })(this);
      defineSuitesByNamespaces(defineAllTests(chai));
      global.suite = oldSuite;
      if (typeof mocha !== "undefined" && mocha !== null) {
        mocha.setup('tdd');
      }
      return this._createMochaSuites();
    };

    return NestedSuites;

  })();


  /*
  IN: rootNamespace
  EFFECT:
    Traverses all of rootNamespace looking for modules with a 'suite' function.
    When found, creates a suite with the namespacePath of that module and evalutest
    the module's suite function in that suite.
   */

  defineSuitesByNamespaces = function(namespace, rootNamespacePath) {
    var i, len, mod, modName, modules, n, namespacePath, namespaces, ns, nsName, ref1, relativeNamespacePath, results, results1;
    if (isArray(namespace)) {
      results = [];
      for (i = 0, len = namespace.length; i < len; i++) {
        n = namespace[i];
        results.push(defineSuitesByNamespaces(n, rootNamespacePath));
      }
      return results;
    } else {
      namespacePath = namespace.namespacePath, namespaces = namespace.namespaces, modules = namespace.modules;
      rootNamespacePath || (rootNamespacePath = namespacePath + ".");
      ref1 = namespacePath.split(rootNamespacePath), relativeNamespacePath = ref1[ref1.length - 1];
      for (nsName in namespaces) {
        ns = namespaces[nsName];
        defineSuitesByNamespaces(ns, rootNamespacePath);
      }
      results1 = [];
      for (modName in modules) {
        mod = modules[modName];
        if (mod) {
          if (isFunction(mod.suite)) {
            results1.push(suite(relativeNamespacePath + "." + modName, mod.suite));
          } else if (isPlainObject(mod.suite)) {
            results1.push(defineSuitesByObjectStructure(mod.suite, relativeNamespacePath + "." + modName));
          } else {
            results1.push(void 0);
          }
        }
      }
      return results1;
    }
  };

  defineSuitesByObjectStructure = function(object, namespacePath) {
    var k, results, v;
    results = [];
    for (k in object) {
      v = object[k];
      if (isFunction(v)) {
        results.push(suite(namespacePath + "." + k, v));
      } else if (isPlainObject(v)) {
        results.push(defineSuitesByObjectStructure(v, namespacePath + "." + k));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  module.exports = MyMocha = (function() {
    function MyMocha() {}

    MyMocha.assert = chai.assert;

    MyMocha.init = function(options) {
      var defineTests, error, ref1, synchronous;
      defineTests = options.defineTests, synchronous = options.synchronous;
      if (!isFunction(defineTests)) {
        throw new Error("defineTests required");
      }
      if ((ref1 = global.mocha) != null) {
        ref1.setup({
          timeout: 10000
        });
      }
      options = merge({
        artConfigName: "Test"
      }, options);
      this.defineGlobals();
      if (DomConsole != null) {
        DomConsole.enable();
      }
      if (synchronous || isNode) {
        try {
          configure(options);
          return this._runSync(defineTests);
        } catch (error1) {
          error = error1;
          return log.error({
            "Art.Foundation.Mocha": {
              error: error
            }
          });
        }
      } else {
        return Promise.resolve(configure(options)).then((function(_this) {
          return function() {
            return _this._run(options.defineTests);
          };
        })(this));
      }
    };

    MyMocha.defineGlobals = function() {
      global.testAssetRoot = "/test/assets";
      return global.skipKnownFailingTest = function(name, f) {
        var message;
        message = "SKIPPING KNOWN-FAILING TEST: " + name;
        return test(message, function() {
          return assert.rejects(f, "This test is passing now, yay! Switch to a normal test.");
        });
      };
    };

    MyMocha._run = function(defineAllTests) {
      return (new NestedSuites).groupTestSuites(defineAllTests).then(function() {
        return typeof mocha !== "undefined" && mocha !== null ? mocha.run() : void 0;
      });
    };

    MyMocha._runSync = function(defineAllTests) {
      (new NestedSuites).groupTestSuitesSync(defineAllTests);
      return typeof mocha !== "undefined" && mocha !== null ? mocha.run() : void 0;
    };

    return MyMocha;

  })();

}).call(this);
