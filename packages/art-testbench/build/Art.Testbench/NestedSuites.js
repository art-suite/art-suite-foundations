"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isFunction", "isPlainObject", "isArray", "peek", "Object", "Promise"], [global, require('./StandardImport')], (isFunction, isPlainObject, isArray, peek, Object, Promise) => {let assertLib, mocha, suite, defineSuitesByObjectStructure, defineSuitesByNamespaces, NestedSuites, temp; assertLib = require('@art-suite/assert'); temp = global; mocha = temp.mocha; suite = temp.suite; defineSuitesByObjectStructure = function(obj, namespacePath) {return Caf.each2(obj, (v, k) => isFunction(v) ? suite(`${Caf.toString(namespacePath)}.${Caf.toString(k)}`, v) : isPlainObject(v) ? defineSuitesByObjectStructure(v, `${Caf.toString(namespacePath)}.${Caf.toString(k)}`) : undefined);}; defineSuitesByNamespaces = function(namespace, rootNamespacePath) {let namespacePath, namespaces, modules, relativeNamespacePath; return isArray(namespace) ? Caf.each2(namespace, (n) => defineSuitesByNamespaces(n, rootNamespacePath)) : (({namespacePath, namespaces, modules} = namespace), rootNamespacePath != null ? rootNamespacePath : rootNamespacePath = namespacePath + ".", relativeNamespacePath = peek(namespacePath.split(rootNamespacePath)), Caf.each2(namespaces, (ns, nsName) => defineSuitesByNamespaces(ns, rootNamespacePath)), Caf.each2(modules, (mod, modName) => isFunction(mod.suite) ? suite(`${Caf.toString(relativeNamespacePath)}.${Caf.toString(modName)}`, mod.suite) : isPlainObject(mod.suite) ? defineSuitesByObjectStructure(mod.suite, `${Caf.toString(relativeNamespacePath)}.${Caf.toString(modName)}`) : undefined, (mod, modName) => mod));}; return NestedSuites = Caf.defClass(class NestedSuites extends Object {constructor() {super(...arguments); this.suites = {}; this.suiteFunctions = {};};}, function(NestedSuites, classSuper, instanceSuper) {this.prototype.addSuite = function(name, f) {let splitName, suiteMap, base; ((base = this.suiteFunctions)[name] || (base[name] = [])).push(f); splitName = name.split("."); suiteMap = this.suites; return Caf.each2(splitName, (suitePart) => suiteMap = suiteMap[suitePart] || (suiteMap[suitePart] = {}));}; this.prototype._createMochaSuites = function(suites = this.suites, suitePath = null) {return Caf.each2(Object.keys(suites), (suitePart) => {let subSuites, path, self; subSuites = suites[suitePart]; path = suitePath ? suitePath + "." + suitePart : suitePart; self = this; return suite(suitePart, () => {let functions; self._createMochaSuites(subSuites, path); return (functions = self.suiteFunctions[path]) ? Caf.each2(functions, (f) => f.call(this)) : undefined;});});}; this.prototype.groupTestSuites = function(defineAllTests) {let oldSuite; oldSuite = global.suite; global.suite = (name, f) => this.addSuite(name, f); return Promise.resolve(defineAllTests(assertLib)).then(defineSuitesByNamespaces).then(() => {global.suite = oldSuite; Caf.exists(mocha) && mocha.setup("tdd"); return this._createMochaSuites();});}; this.prototype.groupTestSuitesSync = function(defineAllTests) {let oldSuite; oldSuite = global.suite; global.suite = (name, f) => this.addSuite(name, f); defineSuitesByNamespaces(defineAllTests(assertLib)); global.suite = oldSuite; Caf.exists(mocha) && mocha.setup("tdd"); return this._createMochaSuites();};});});});
//# sourceMappingURL=NestedSuites.js.map
