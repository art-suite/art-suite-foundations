import &StandardImport

suite:
  _each:
    basic: ->
      test "objects", ->
        values = 0
        keys = ""
        _each {a: 1, b: 2}, (v, k) -> values += v; keys += k
        assert.eq values, 3
        assert.eq keys, "ab"

      test "arrays", ->
        keys = values = 0
        _each [3, 4], (v, k) -> values += v; keys += k
        assert.eq values, 7
        assert.eq keys, 1

    empty: ->
      test "_array null", ->
        assert.eq [], _array null, (v, k) ->

      test "_each null", ->
        count = 0
        _each null, (v, k) -> count++
        assert.eq 0, count

    when: ->
      test "objects", ->
        values = 0
        _each {a: 1, b: 2, c: 3, d: 4},
          when: (v, k) -> v % 2 == 0
          with: (v) -> values += v
        assert.eq values, 6

      test "arrays", ->
        values = 0
        _each [1,2,3,4],
          when: (v, k) -> v % 2 == 0
          with: (v) -> values += v
        assert.eq values, 6

      test "when return value", ->
        out = []
        _each [{a:"foo"},{},{a:"bar"},{}],
          when: ({a}) -> a
          with: (v, k, o, whenResult) ->
            out.push whenResult

        assert.eq out, ["foo", "bar"]

  _find: ->
    source = [1, 2, 9, 3, 4]
    test "when",      -> assert.eq 9,   _find source, when: (v) -> v % 3 == 0
    test "with",      -> assert.eq 90,  _find source, (v) -> if v % 3 == 0 then v * 10
    test "when with", -> assert.eq 45,  _find source,
      when: (v) -> v % 3 == 0
      with: (v) -> v * 5

  _object:
    fromObjects: ->
      test "no function, empty _object", ->
        b = _object a = {}
        assert.eq a, b
        assert.notSame a, b

      test "no function, non-empty _object", ->
        b = _object a = {a: 1, b: 2}
        assert.eq a, b
        assert.notSame a, b

      test "0-arg function: -> 123", ->
        assert.eq {a: 123, b: 123}, _object {a: 1, b: 2}, -> 123

      test "1-arg function: (v) -> v + 1", ->
        assert.eq {a: 2, b: 3}, _object {a: 1, b: 2}, (v) -> v + 1

      test "2-arg function: (v, k) -> k + v", ->
        assert.eq {a: "a1", b: "b2"}, _object {a: 1, b: 2}, (v, k) -> k + v

      test "3-arg function: (v, k, map) -> map[k+v] = v", ->
        source = {a: 1, b: 2}
        assert.eq {a1: 1, b2: 2}, _each source, (_into = {}), (v, k) -> _into[k + v] = v
        assert.eq {a1: 1, a: 1, b2: 2, b: 2}, _object source,             (v, k, _into) -> _into[k+v] = v

      test "when", ->
        assert.eq {b: 2, d: 4}, _object {a: 1, b: 2, c: 3, d: 4}, when: (v) -> v % 2 == 0

      test "key", ->
        assert.eq
          101: 1
          202: 2
          303: 3
          404: 4
          _object {a: 1, b: 2, c: 3, d: 4},
            key: (v) -> v * 101

      test "key - all values passed through", ->
        assert.eq
          _array: [1, 2, 3, 4]
          a102: 1
          b204: 2
          c306: 3
          d408: 4
          _object {a: 1, b: 2, c: 3, d: 4},
            when: (v) -> v * 2
            key: (v, k, _into, w) ->
              (_into._array ||= []).push v
              "#{k}#{v * 100 + w}"

    fromArrays: ->
      test "0-arg function: -> true", ->
        assert.eq {a: true, b: true}, _object ["a", "b"], -> true

      test "1-arg function: (v) -> v + v", ->
        assert.eq {a: "aa", b: "bb"}, _object ["a", "b"], (v) -> v+v

      test "2-arg function: (v, k) -> map[k+v] = v", ->
        assert.eq {a: "0a", b: "1b"}, _object ["a", "b"], (v, k) -> k+v

      test "3-arg function: (v, k, map) -> map[k+v] = v", ->
        assert.eq {"0a": "a", a: "a", "1b": "b", b: "b"}, _object ["a", "b"], (v, k, map) -> map[k+v] = v

  _array:
    objects: ->
      test "no function, empty _object", ->
        assert.eq [], _array {}

      test "no function, non-empty _object", ->
        assert.eq [1, 2], _array a: 1, b: 2

      test "0-arg function: -> 123", ->
        assert.eq [123, 123], _array {a: 1, b: 2}, -> 123

      test "1-arg function: (v) -> v + v", ->
        assert.eq ["aa", "bb"], _array ["a", "b"], (v) -> v+v
