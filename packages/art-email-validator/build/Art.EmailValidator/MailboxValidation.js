"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Error", "present", "Promise", "log", "processResponse", "success", "clientFailure", "networkFailure", "formattedInspect", "merge", "logResult"], [global, require('./StandardImport'), require('./Smtp')], (Error, present, Promise, log, processResponse, success, clientFailure, networkFailure, formattedInspect, merge, logResult) => {let hardInvalidSmtpRejectionCodes, validateMailbox; hardInvalidSmtpRejectionCodes = {550: {reason: "mailboxDoesNotExist", message: "mailbox does not exist"}, 452: {reason: "mailboxFull", message: "mailbox is full"}}; return {validateMailbox: validateMailbox = function(options = {}, socket) {let smtpFrom, smtpHost, emailServer, email, verbose, fallbackValidator, timeout, currentCommandIndex, smtpCommands; ({smtpFrom, smtpHost, emailServer, email, verbose, fallbackValidator} = options); if (!(email && (smtpHost != null ? smtpHost : smtpFrom))) {throw new Error("email, emailServer and smtpHost or smtpFrom required");}; ({timeout = 1000} = options); smtpHost != null ? smtpHost : smtpHost = smtpFrom.split("@")[1]; if (!present(smtpHost)) {throw new Error("Please provide smtpHost or a complete smtpFrom email address");}; currentCommandIndex = 0; smtpCommands = [`helo ${Caf.toString(smtpHost)}`, `mail from:<${Caf.toString(smtpFrom)}>`, `rcpt to:<${Caf.toString(email)}>`]; return (new Promise((resolve, reject) => {socket != null ? socket : socket = require('net').createConnection(25, emailServer); socket.setTimeout(timeout, () => resolve({valid: false, invalid: false, reason: "smtpTimeout", message: `${Caf.toString(emailServer)} failed to respond within specified timeout, (${Caf.toString(timeout)}ms)`, emailServer})); socket.on("error", (socketError) => (socketError.code === "ECONNRESET") ? resolve({valid: false, reason: "smtpConnectionReset", message: `${Caf.toString(emailServer)} refused ${Caf.toString(email)} (connection reset).`}, emailServer) : resolve({valid: false, reason: "smtpSocketError", message: `socket socketError ${Caf.toString("#err.code")} communicating with ${Caf.toString(emailServer)}`, emailServer})); return socket.on("data", (data) => {let smtpStatus, smtpStatusSubject, softFailure, reason, message, smtpStatusCode, smtpEnhancedStatusCode, normalizedResponse, hardInvalid, result; data = data.toString(); if (verbose >= 2) {log({smtpResponse: data});}; ({smtpStatus, smtpStatusSubject, softFailure, reason, message, smtpStatusCode, smtpEnhancedStatusCode, normalizedResponse} = processResponse(data)); if (smtpStatus !== success) {hardInvalid = !softFailure && ((smtpStatus === clientFailure) ? (() => {switch (smtpStatusSubject) {case "mailbox": return true; case "mailSystem": return true; case "addressing": return true; case "security": return false; case "network": return false; case "protocol": return false; case "content": return false; default: return false;};})() : (smtpStatus === networkFailure && smtpStatusSubject === "mailbox") ? !!reason : undefined); result = {valid: false, invalid: !!hardInvalid, reason: reason != null ? reason : `smtpError${Caf.toString(smtpEnhancedStatusCode != null ? smtpEnhancedStatusCode : smtpStatusCode)}`, smtpStatus, smtpStatusSubject, smtpStatusCode, smtpEnhancedStatusCode, emailServer, refusedWith: normalizedResponse, message: message != null ? message : `${Caf.toString(emailServer)} refused ${Caf.toString(email)}. (${Caf.toString(formattedInspect(merge({smtpStatusCode, smtpEnhancedStatusCode})))})`}; resolve(Caf.object(result, null, (v) => v != null));}; return (currentCommandIndex < smtpCommands.length) ? ((verbose >= 2) ? log({smtpCommand: smtpCommands[currentCommandIndex]}) : undefined, socket.write(smtpCommands[currentCommandIndex] + "\r\n", () => currentCommandIndex++)) : resolve({valid: true, reason: "mailboxExists", message: "mailbox exists", emailServer});});})).finally(() => socket.destroy()).then((result) => (!result.valid && !result.invalid) ? fallbackValidator ? (verbose && logResult(email, result, "useFallback"), Promise.then(() => fallbackValidator(options, result)).tap(({valid, invalid, code, reason, message}) => {}).then((result) => merge({usedFallbackValidator: true, reason: "fallbackValidator"}, result))) : (verbose && logResult(email, result, "noFallback"), result) : result);}};});});
//# sourceMappingURL=MailboxValidation.js.map
