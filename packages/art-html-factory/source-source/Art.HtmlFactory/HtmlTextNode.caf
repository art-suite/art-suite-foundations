import &ArtStandardLib, &HtmlLib, {} &wrapAnsi

class HtmlTextNode extends &ArtClassSystem.BaseClass
  constructor: (@_name, @_props, @_children) ->
    @_name = @_name.toLocaleLowerCase()
    @_normalizeChildren()

  clone: (withNewValues) ->
    withNewValues extract? name, props, children
    props ?= @_props unless props == null
    children ?= @_children unless children == null

    new @class
      name ? @_name
      if props? && objectHasKeys props then props
      if children?.length > 0 then children

  _normalizeChildren: ->
    @_haveStringChildrenWithNewLines = false

    if @_children?
      @_children =
        find child in @_children when child is String
          array child in @_children
            if child is String
              child = @_getNormalizedText child
              @_haveStringChildrenWithNewLines = true if /\n/.test child

            child
        ? @_children

  reformatTextForNiceHtmlSource = (text) ->
    if /\n *\n/.test text
      array p in text.replace(/\ *\n( *\n)+/g, "\n\n").split "\n\n"
        p.replace /\ *\n\ */g, ' '
      .join "\n\n"
    else text.replace /\n/, ' '

  _getNormalizedText: (text) ->
    if @preserveRawText then text
    else reformatTextForNiceHtmlSource text

  @setter
    style: (style) ->
      log.warn "" HtmlTextNode#style setter is DEPRICATED - use @clone to create a new object with new style
      @_props = merge @_props, {} style

    props: (props) -> @_props =
      log.warn "" HtmlTextNode#props setter is DEPRICATED - use @clone to create a new object with new props
      if @_style = props extract? style
        props = merge props, style:
          array name from Object.keys(style).sort()
            "#{name}: #{style[name]}"
          .join '; '

      else if hasProperties props
        props
      else
        null

  emptyString = ''
  @getter
    :props
    :name
    :children
    inspectedObjects: -> [@name]: merge
      props:    @props
      children: if @children then array child in @children with child.inspectedObjects ? child

    style:            -> @_props?.style
    preserveRawText:  -> rawHtmlTags[@_name]
    isRawHtml:        -> @_name == :rawhtml
    isPre:            -> @_name == :pre

    childRequireMultipleLines: ->
      !!@_children &&
        @_children.length > 1 || @_children[0].onelinerOk == false

    onelinerOk: -> !@_haveStringChildrenWithNewLines && !@childRequireMultipleLines

    length: -> @_length ?=
      5 + @_name.length * 2 # <name></name>
      + @propsString.length
      + reduce total, v from @_children inject 0 with total + v.length

    styleString: ->
      @ extract style
      @_styleString ?=
        array name from-array Object.keys(style).sort()
          "#{name}: #{style[name]}"
        .join '; '

    propsString: ->
      @_propsString ?=
        if @_props
          ' ' +
            array propValue, propName from @_props
              propValue = @styleString if propName == :style
              if propValue == true then propName
              else "" #{propName}="#{escapeHtmlString propValue}"

            .join ' '
        ? emptyString

  @defaultCompileOptions:
    tagWrap: 80
    textWordWrap: 80

  compile: (indentOrOptions) ->
    if indentOrOptions is String
      indent = indentOrOptions
      options = HtmlTextNode.defaultCompileOptions

    else if indentOrOptions is Object
      indentOrOptions extract indent
      {indent} = options = merge
        HtmlTextNode.defaultCompileOptions
        indentOrOptions

    indent = '' if indent == true

    compactFlatten @_compile indent, options

  toString: (options = '')->
    @compile options
    .join "\n"

  emptyOptions = {}
  toCompactString: ->
    compactFlattenJoin '' @_compile null, emptyOptions

  ##################
  # PRIVATE
  ##################

  htmlFriendlyTextWrap = (line, columns) ->
    wrapAnsi
      line.replace /\ *\n( *\n)/g, "\n\n"
      columns

  applyIndent = (indent, line, columns) ->
    if columns > 0
      line = htmlFriendlyTextWrap line, columns

    if indent?
      indent + line.replace /\n(?!\n)/g, "\n#{indent}"
    else
      line

  ## OUT: String or Array of Strings, possibly nested
  _compile: (indent, options) ->
    if @isRawHtml && @_children
      @_getCompiledChildren indent, emptyOptions

    else if indent? && indent.length + @length <= options.tagWrap && @onelinerOk
      indent + @toCompactString()

    else
      if compiledChildren = @_getCompiledChildren indent, options
        []
          applyIndent indent, "" <#{@_name}#{@propsString}>
          compiledChildren
          applyIndent indent, "" </#{@_name}>

      else if noCloseTags[@_name]
        applyIndent indent, "" <#{@_name}#{@propsString}>

      else
        applyIndent indent, "" <#{@_name}#{@propsString}></#{@_name}>

  _getCompiledChildren: (indent, options) ->
    if @_children
      indent = indent + '  ' if indent? && !@isRawHtml
      array child from @_children
        if isString child
          if @_name != :pre
            applyIndent indent, child, unless @preserveRawText then options.textWordWrap
          else child
        else child._compile indent, options
