import &ArtStandardLib, {} &wrapAnsi

noCloseTag =
  link: true
  meta: true
  img: true
  br: true

class HtmlTextNode extends &ArtClassSystem.BaseClass
  constructor: (@name, @props, @children) ->
    @name = @name.toLocaleLowerCase()
    @_normalizeProps()
    @_normalizeChildren()

  _normalizeProps: ->
    if hasProperties @props
      if @props.style
        @style = @props.style
        @props.style =
          array value, name from @style
            "#{name}: #{value}"
          .join '; '

    else
      @props = null

  _normalizeChildren: ->
    @_haveStringChildrenWithNewLines = false

    if @children?
      @children =
        find child in @children when child is String
          array child in @children
            if child is String
              child = @_getNormalizedText child
              @_haveStringChildrenWithNewLines = true if /\n/.test child

            child
        ? @children

  _getNormalizedText: (text) ->
    unless @preserveRawText
      escapeHtmlString
        if /\n *\n/.test text
          array p in text.replace(/\ *\n( *\n)+/g, "\n\n").split "\n\n"
            p.replace /\ *\n\ */g, ' '
          .join "\n\n"
        else text.replace /\n/, ' '
    else text

  @htmlEscapes: htmlEscapes =
    '"': "" &quot;
    '&': "" &amp;
    '<': "" &lt;
    '>': "" &gt;

  getHtmlEscape = (e) -> htmlEscapes[e]

  @escapeHtmlString: escapeHtmlString = (string) ->
    string = "#{string}"
    if /["<>&]/.test string
      string.replace /["<>&]/g, getHtmlEscape

    else string

  rawHtmlTags =
    rawhtml: true
    pre: true
    script: true
    style: true

  @getter
    preserveRawText: -> rawHtmlTags[@name]
    isRawHtml: -> @name == :rawhtml
    isPre:  -> @name == :pre
    childRequiresMultipleLines: ->
      !!@children &&
        @children.length > 1 || @children[0].onelinerOk == false

    onelinerOk: -> !@_haveStringChildrenWithNewLines && !@childRequiresMultipleLines
    length: ->
      5 + @name.length * 2 # <name></name>
      + reduce total, v, k from @props inject 0 with total + 4 + k.length + "#{v}".length
      + reduce total, v from @children inject 0 with total + v.length

    propsString: ->
      if @props
        ' ' +
          array propValue, propName from @props
            if propValue == true
              propName
            else
              "" #{propName}="#{escapeHtmlString propValue}"
          .join ' '

  @defaultCompileOptions:
    tagWrap: 80
    textWordWrap: 80

  compile: (indentOrOptions) ->
    if indentOrOptions is String
      indent = indentOrOptions
      options = HtmlTextNode.defaultCompileOptions

    else if indentOrOptions is Object
      indentOrOptions extract indent
      {indent} = options = merge
        HtmlTextNode.defaultCompileOptions
        indentOrOptions

    indent = '' if indent == true

    compactFlatten @_compile indent, options

  toString: (options = '')->
    @compile options
    .join "\n"

  emptyOptions = {}
  toCompactString: ->
    compactFlattenJoin '' @_compile null, emptyOptions

  ##################
  # PRIVATE
  ##################

  htmlFriendlyTextWrap = (line, columns) ->
    wrapAnsi
      line.replace /\ *\n( *\n)/g, "\n\n"
      columns

  applyIndent = (indent, line, columns) ->
    if columns > 0
      line = htmlFriendlyTextWrap line, columns

    if indent?
      indent + line.replace /\n(?!\n)/g, "\n#{indent}"
    else
      line

  ## OUT: String or Array of Strings, possibly nested
  _compile: (indent, options) ->
    if @isRawHtml && @children
      @_getCompiledChildren indent, emptyOptions

    else if indent? && indent.length + @length <= options.tagWrap && @onelinerOk
      indent + @toCompactString()

    else
      if compiledChildren = @_getCompiledChildren indent, options
        []
          applyIndent indent, "" <#{@name}#{@propsString}>
          compiledChildren
          applyIndent indent, "" </#{@name}>

      else if noCloseTag[@name]
        applyIndent indent, "" <#{@name}#{@propsString}>

      else
        applyIndent indent, "" <#{@name}#{@propsString}></#{@name}>

  _getCompiledChildren: (indent, options) ->
    if @children
      indent = indent + '  ' if indent? && !@isRawHtml
      array child from @children
        if isString child
          if @name != :pre
            applyIndent indent, child, unless @preserveRawText then options.textWordWrap
          else child
        else child._compile indent, options
