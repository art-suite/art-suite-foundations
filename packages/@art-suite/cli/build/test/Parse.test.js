"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {let parentImports; return Caf.importInvoke(["ArtCli"], parentImports = [global, require('./StandardImport')], (ArtCli) => {return Caf.importInvoke(["describe", "test", "assert", "parseAndSelectCommand", "normalizeCommands", "w", "parseArgs", "JSON", "ParseError"], [parentImports, ArtCli.Parse, ArtCli.Util, {ParseError: ArtCli.ParseError}], (describe, test, assert, parseAndSelectCommand, normalizeCommands, w, parseArgs, JSON, ParseError) => {return describe({parseAndSelectCommand: {basic: function() {test("parseAndSelectCommand", () => {let foo, bar; return assert.eq(parseAndSelectCommand(normalizeCommands({foo: foo = () => {}, bar: bar = () => {}}), ["foo", "bar"]), {commandFunction: foo, commandName: "foo", options: {}, args: ["bar"]});}); return test("parseAndSelectCommand commands with help", () => {let foo, bar; return assert.eq(parseAndSelectCommand({foo: {run: foo = () => {}, description: "walk about", examples: "walk", options: {gate: ["mph", "estimated mph for yer walking"]}}, bar: bar = () => {}}, ["foo", "bar"]), {commandFunction: foo, commandName: "foo", options: {}, args: ["bar"]});});}, optionDefaults: function() {test("with default applied", () => assert.eq(parseAndSelectCommand(normalizeCommands({foo: {run: () => {}, options: {bar: {default: "123"}}}}), w("foo --bar")).options, {bar: "123"})); return test("with default ignored", () => assert.eq(parseAndSelectCommand(normalizeCommands({foo: {run: () => {}, options: {bar: {default: "123"}}}}), w("foo --bar 456")).options, {bar: 456}));}, argsDefault: function() {return test("with default applied", () => assert.eq(parseAndSelectCommand(normalizeCommands({foo: {run: () => {}, args: {default: w("123 456")}}}), w("foo")).args, ["123", "456"]));}}, parseArgs: {options: function() {return test("empty args", () => assert.eq(parseArgs([]), {commandName: undefined, options: {}, args: []}));}, dataTypes: {boolean: function() {test("boolean value", () => assert.eq(parseArgs(["--verbose"]), {commandName: undefined, args: [], options: {verbose: []}})); test('boolean true from "true"', () => assert.eq(parseArgs(["--verbose", "true"]), {commandName: undefined, args: [], options: {verbose: [true]}})); return test('boolean true from "true"', () => assert.eq(parseArgs(["--verbose", "false"]), {commandName: undefined, args: [], options: {verbose: [false]}}));}, number: function() {return test("number value", () => assert.eq(parseArgs(["--num", "123"]).options, {num: [123]}));}, string: function() {test("simple string", () => assert.eq(parseArgs(["--foo", "bar"]).options, {foo: ["bar"]})); test("string:true", () => assert.eq(parseArgs(["--foo", "string:true"]).options, {foo: ["true"]})); test("string:false", () => assert.eq(parseArgs(["--foo", "string:false"]).options, {foo: ["false"]})); return test("string:10", () => assert.eq(parseArgs(["--foo", "string:10"]).options, {foo: ["10"]}));}, lists: function() {test("list", () => assert.eq(parseArgs(["--foo", "bar", "--foo", "baz"]).options, {foo: ["bar", "baz"]})); return test("not a list", () => assert.eq(parseArgs(["--foo", "bar", "baz"]).options, {foo: ["bar"]}));}, json: function() {return test("regexp", () => {let data; data = {alpha: null, beta: true, gamma: ["a", "b", "c"], delta: "foo"}; return assert.eq(parseArgs(["--my-json", `json:${Caf.toString(JSON.stringify(data))}`]).options.myJson, [data]);});}, js: function() {test("regexp", () => assert.eq(parseArgs(["--regex", "js:/[a-z]+/"]).options.regex[0].exec("123 frank %"), ["frank"])); return test("function", () => {let f; f = (v) => v * 123; return assert.eq(parseArgs(["--f", `js:${Caf.toString(f)}`]).options.f[0](10), 1230);});}}, arrays: function() {return test("add [] to the end of an option to make it an array: myCommand myArg --foo[] foo1 foo2 --bam boom myOtherArg", () => assert.eq(parseArgs(w("myCommand myArg --foo[] foo1 foo2 --bam boom myOtherArg")), {commandName: "myCommand", options: {foo: ["foo1", "foo2"], bam: ["boom"]}, args: ["myArg", "myOtherArg"]}));}, withEquals: function() {return test("params can have an = sign instead of a space: myCommand myArg --foo=foo1 myOtherArg --bam", () => assert.eq(parseArgs(w("myCommand myArg --foo=foo1 myOtherArg --bam")), {commandName: "myCommand", options: {foo: ["foo1"], bam: []}, args: ["myArg", "myOtherArg"]}));}, parseErrors: {js: test("function throws error", function() {return assert.rejects(() => parseArgs(["--f", "js:() => {"])).then((error) => assert.instanceof(ParseError, error));})}, commands: function() {test("one command", () => assert.eq(parseArgs(["myCommand"]), {commandName: "myCommand", options: {}, args: []})); return test("multiple args - first is command", () => assert.eq(parseArgs(["myCommand1", "myArg2"]), {commandName: "myCommand1", args: ["myArg2"], options: {}}));}, mixed: function() {test("multiple commands and options", () => assert.eq(parseArgs(w("myCommand1 myArg2 --files one.json --files two.json --output out.json")), {commandName: "myCommand1", args: ["myArg2"], options: {files: ["one.json", "two.json"], output: ["out.json"]}})); return test("args mixed with options", () => assert.eq(parseArgs(w("myCommand1 --files one.json myArg2 --files two.json --output out.json")), {commandName: "myCommand1", args: ["myArg2"], options: {files: ["one.json", "two.json"], output: ["out.json"]}}));}}});});});});
//# sourceMappingURL=Parse.test.js.map
