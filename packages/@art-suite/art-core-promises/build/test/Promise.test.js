"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Promise", "timeout", "Error", "assert", "deepAll"], [global, require('./StandardImport')], (describe, test, Promise, timeout, Error, assert, deepAll) => {return describe({blueBirdBasics: function() {return test("new Promise()", () => new Promise((resolve) => resolve()));}, newExternallyResolvable: function() {test("newExternallyResolvable.resolve()", () => Promise.newExternallyResolvable().resolve()); test("newExternallyResolvable with true async", () => {let p; p = Promise.newExternallyResolvable(); timeout(0, () => p.resolve()); return p;}); return test("newExternallyResolvable.reject()", () => {let p; (p = Promise.newExternallyResolvable()).reject(new Error); return assert.rejects(p);});}, invert: function() {test("Promise.invert catch to then", () => Promise.invert(Promise.then(() => (() => {throw new Error("foo");})()))); return test("Promise.invert then to catch", () => assert.rejects(Promise.invert(Promise.then(() => "foo"))));}, finally: function() {test("Promise.finally fires on success", () => {let took; took = false; return Promise.finally(Promise.resolve(123), () => took = true).then((v) => {assert.eq(v, 123); return assert.ok(took);});}); test("Promise.finally fires on error", () => {let took; took = false; return assert.rejects(Promise.finally(Promise.reject(new Error(123)), () => took = true)).then(({message}) => {assert.eq(message, "123"); return assert.ok(took);});}); test("Promise.finally failure after success causes rejection", () => assert.rejects(Promise.finally(Promise.resolve(new Error(123)), () => (() => {throw new Error("foo");})()))); return test("Promise.finally failure after failure causes new rejection", () => assert.rejects(Promise.finally(Promise.reject(new Error("original rejection")), () => (() => {throw new Error("from finally");})())).then(({message}) => assert.eq(message, "from finally")));}, deepAll: function() {test("deepAll {}", () => deepAll({a: Promise.resolve(123), b: Promise.resolve({c: 1, d: 2})}).then((result) => assert.eq(result, {a: 123, b: {c: 1, d: 2}}))); test("deepAll [{}]", () => deepAll([999, {a: Promise.resolve(123), b: Promise.resolve({c: 1, d: 2})}]).then((result) => assert.eq(result, [999, {a: 123, b: {c: 1, d: 2}}]))); return test("deepAll []", () => deepAll([Promise.resolve(123), Promise.resolve({c: 1, d: 2})]).then((result) => assert.eq(result, [123, {c: 1, d: 2}])));}, serializer: function() {test("Promise.serialize", () => {let count, delays, delaysUsed, order, f; count = 0; delays = [100, 0, 10]; delaysUsed = []; order = []; f = Promise.serialize(() => timeout(delays[count], () => {delaysUsed.push(delays[count]); return order.push(count++);})); f(); f(); return f().then(() => {assert.eq(order, [0, 1, 2]); return assert.eq(delaysUsed, delays);});}); test("always", () => {let serializer; serializer = new (Promise.Serializer); serializer.then(() => (() => {throw new Error("oh no!");})()); serializer.always(() => "oh, ok!"); return serializer.then((out) => {assert.eq(out, "oh, ok!"); return null;});}); return test("serializer with forEach", () => {let count, delays, delaysUsed, order, serializer; count = 0; delays = [100, 0, 10]; delaysUsed = []; order = []; serializer = new (Promise.Serializer); delays.forEach(serializer.serialize((delay) => timeout(delay, () => {delaysUsed.push(delay); return order.push(count++);}))); return serializer.then(() => {assert.eq(order, [0, 1, 2]); return assert.eq(delaysUsed, delays);});});}});});});
//# sourceMappingURL=Promise.test.js.map
