"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Error", "Promise", "Array"], [global, require('./ArtPromise')], (Error, Promise, Array) => {let PromiseWorkerPool; return PromiseWorkerPool = Caf.defClass(class PromiseWorkerPool extends Object {constructor(numWorkers = 10) {super(...arguments); this.numWorkers = numWorkers; this._queue = [];};}, function(PromiseWorkerPool, classSuper, instanceSuper) {this.prototype.queue = function(job) {if (this._startPromise) {throw new Error("already started");}; this._queue.push(job); return this;}; this.prototype.start = function() {return this._startPromise || (this._startPromise = Promise.then(() => {let jobIndex, doNextAction, results, numJobs, workerPromises, numWorkers; jobIndex = 0; doNextAction = () => {let currentJobIndex, job; return (this._queue.length > (currentJobIndex = jobIndex)) ? (jobIndex++, (job = this._queue[currentJobIndex]) ? (this._queue[currentJobIndex] = null, Promise.then(() => job(currentJobIndex, numJobs)).then((result) => results[currentJobIndex] = result).then(doNextAction)) : Promise.then(doNextAction)) : Promise.resolve("queue done");}; results = new Array(numJobs = this._queue.length); workerPromises = []; ({numWorkers} = this); while (workerPromises.length < numWorkers) {workerPromises.push(doNextAction());}; return Promise.all(workerPromises).then(() => results);}));}; this.prototype.then = function(a, b) {return this.start().then(a, b);}; this.prototype.catch = function(a) {return this.start().catch(a);};});});});
//# sourceMappingURL=PromiseWorkerPool.js.map
