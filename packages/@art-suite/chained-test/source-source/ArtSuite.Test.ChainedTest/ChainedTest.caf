import &ArtStandardLib, &ArtClassSystem

cleanErrorStack = (error, stackTraceIgnoreLineRegExp) ->
  error.stack =
    array line in error.stack?.split :\n when !stackTraceIgnoreLineRegExp.test line
    .join :\n

  error

{chainedTest} = class ChainedTest extends BaseClass
  ###
    IN:
      PATTERN 1:
        (setupFunciton) ->

      PATTERN 2:
        (setupTestName, setupFunction) ->

      setupTestName
        String
        If present, appended to the Mocha setup-test's name

      setupFunction
        Result: any arbitrary function.
        Result is resolved if it's a promise before passing to tests.
        The result is passed to every test as the test's 2nd argument.
        The result is ALSO passed to the very first test as the test's 1st argument.
  @chainedTest: (a, b) ->
    setupFunction = b ? a
    setupName = a if b?

    throw new Error "expected test/setup function" unless setupFunction is Function

    new ChainedTest
      setupName ? "" ChainedTest setup
      setupFunction

  thenTest:     (args...)-> @_applySequence :_thenTest    compactFlatten args
  tapTest:      (args...)-> @_applySequence :_tapTest     compactFlatten args
  softTapTest:  (args...)-> @_applySequence :_softTapTest compactFlatten args

  ##########################
    PRIVATE
  ##########################
  ###
    IN:
      name: [optional] string
        if present, a mocha test is created

      test: [optional] (runSetupOnceResult) ->
        IN: resolved result from @runSetupOnce
        OUT: result will be resolved and passed to any thenTest tests

      runSetupOnce: [optional] ->
        OUT: promise result will be resolved and passed to every @test
          as the second argument
          AND, as the first argument for the first test
        REQUIREMENT: should be re-invokable without additional side-effects
          and should always return the same thing

      runDependencyChainOnce:

      options:
        tap: <boolean> ignore the result of this test
        soft: <boolean> skip this test if not explicitly run by the test framework (Jest/Mocha)

  constructor: (@name, @test, @_runSetupOnce, @runDependencyChainOnce, @options) ->
    throw new Error "test required" unless @test is Function
    throw new Error "name required" unless @name is String
    global.test @name, @runThisTestOnce

  @getter
    runSetupOnce: -> @_runSetupOnce ? @runDependencyChainOnce
    runThisTestOnce: ->
      @_runThisTestOnce ?= ->
        @_setupAndTestOncePromise ?=
          Promise.all []
            Promise.then @runDependencyChainOnce ? ->
            Promise.then @runSetupOnce ? ->
          .then ([previousTestResult, setupResult]) ->
            Promise.then -> @test previousTestResult, setupResult
            .then (out) -> if @options?.tap then previousTestResult else out
          .catch (error) ->
            throw cleanErrorStack
              error
              /ArtSuite.Test|caffeine-script-runtime|processImmediate|art-testbench|caffeine-script-runtime|bluebird|jest-jasmine2/

    runDependencyChainPlusThisOnce: ->
      ->
        if @options?.soft
              Promise.then @runDependencyChainOnce
        else  @runThisTestOnce()
        .catch (error) ->
          unless /failed in/.test error.message
            # error.message = "" (ChainedTest failed in: #{if @name then @name else :setup})\n\n
            throw error

  _thenTest:    (nextName, nextTest) -> new ChainedTest nextName, nextTest, @runSetupOnce, @runDependencyChainPlusThisOnce
  _tapTest:     (nextName, nextTest) -> new ChainedTest nextName, nextTest, @runSetupOnce, @runDependencyChainPlusThisOnce, tap: true
  _softTapTest: (nextName, nextTest) -> new ChainedTest nextName, nextTest, @runSetupOnce, @runDependencyChainPlusThisOnce, tap: true, soft: true

  _applySequence: (applyMemberName, sequence) ->
    lastChainedTest = @
    each name, i in sequence by 2

      unless isString name
        throw new Error "" ChainedTestError: expecting <String> got: #{formattedInspect name}

      unless isFunction f = sequence[i + 1]
        throw new Error "" ChainedTestError: expecting <Function> after <String>(#{formattedInspect name}) got: #{formattedInspect f}

      lastChainedTest = lastChainedTest[applyMemberName] name, f

    lastChainedTest
