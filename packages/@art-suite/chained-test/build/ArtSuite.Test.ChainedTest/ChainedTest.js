"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "isPlainObject", "compactFlatten", "Promise", "Error", "formattedInspect", "merge", "isString", "isFunction"], [global, require('art-standard-lib'), require('art-class-system')], (BaseClass, isPlainObject, compactFlatten, Promise, Error, formattedInspect, merge, isString, isFunction) => {let cleanErrorStack, isMergeable, uniqueErrorsReported, chainedTest, firstIt, ChainedTest; cleanErrorStack = function(error, stackTraceIgnoreLineRegExp) {error.stack = Caf.array(error.stack.split("\n"), null, (line) => !stackTraceIgnoreLineRegExp.test(line)).join("\n"); return error;}; isMergeable = function(v) {return !(v != null) || isPlainObject(v);}; uniqueErrorsReported = {}; return ({chainedTest, firstIt} = ChainedTest = Caf.defClass(class ChainedTest extends BaseClass {constructor(name, test, _runSetupOnce, _runDependencyChainOnce, options) {let self, temp; super(...arguments); this.name = name; this.test = test; this._runSetupOnce = _runSetupOnce; this._runDependencyChainOnce = _runDependencyChainOnce; this.options = options; if (!isString(this.name)) {throw new Error(`chainedTest: Test name-string is required.\n\n${Caf.toString(formattedInspect({received: this.name}))}`);}; if (!isFunction(this.test)) {throw new Error(`chainedTest: Test function is required.\n\n${Caf.toString(formattedInspect({received: this.test}))}`);}; self = this; ((temp = global.it) != null ? temp : global.test)(this.name, function() {return self.runThisTestOnce().catch((error) => {let base; return uniqueErrorsReported[error.message] ? Caf.isF((base = this).skip) && base.skip() : (uniqueErrorsReported[error.message] = true, (() => {throw error;})());});});};}, function(ChainedTest, classSuper, instanceSuper) {this.chainedTest = function(a, b) {return new ChainedTest((b != null) ? a : "ChainedTest setup", b != null ? b : a);}; this.prototype.thenTest = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.thenTestMerged = function(...args) {return this._applySequence("_thenTestMerged", compactFlatten(args));}; this.prototype.tapTest = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapTest = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.firstIt = this.chainedTest; this.prototype.thenIt = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.tapIt = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapIt = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.getter({previousTestResultPromise: function() {let temp; return Promise.then(((temp = this._runDependencyChainOnce) != null ? temp : (() => {})));}, setupResultPromise: function() {let temp, temp1; return Promise.then(((temp = ((temp1 = this._runSetupOnce) != null ? temp1 : this._runDependencyChainOnce)) != null ? temp : (() => {})));}, runThisTestOnce: function() {let temp; return ((temp = this._runThisTestOnce) != null ? temp : this._runThisTestOnce = () => {let temp1; return ((temp1 = this._setupAndTestOncePromise) != null ? temp1 : this._setupAndTestOncePromise = Promise.all([this.previousTestResultPromise, this.setupResultPromise]).then(([previousTestResult, setupResult]) => Promise.then(() => {chainedTest.current = this; return this.test(previousTestResult, setupResult);}).then((out) => {let filter, temp2; return (Caf.exists(temp2 = this.options) ? filter = temp2.filter : undefined) ? filter(out, previousTestResult) : out;})).catch((error) => (() => {throw cleanErrorStack(error, /ArtSuite.Test|caffeine-script-runtime|processImmediate|art-testbench|caffeine-script-runtime|bluebird|jest-jasmine2/);})()));});}, runSetupForNextLink: function() {let temp; return ((temp = this._runSetupOnce) != null ? temp : this.runThisTestOnce);}, runChainForNextLink: function() {return () => {let base; return (Caf.exists(base = this.options) && base.soft) ? this.previousTestResultPromise : this.runThisTestOnce();};}}); this.prototype._thenTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink);}; this.prototype._thenTestMerged = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {filter: (testResult, testInput) => Promise.deepResolve(testResult).then((testResult) => {if (!(isMergeable(testResult) && isMergeable(testInput))) {throw new Error(`Always return a plain object, null or undefined result when using \`thenTestMerged\`. For ${Caf.toString(formattedInspect({testInput}))} got: ${Caf.toString(formattedInspect({testResult}))}`);}; return merge(testInput, testResult);})});}; this.prototype._tapTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {filter: (res, prevRes) => prevRes});}; this.prototype._softTapTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {soft: true, filter: (res, prevRes) => prevRes});}; this.prototype._applySequence = function(applyMemberName, sequence) {let lastChainedTest, from, into, to, i1; lastChainedTest = this; from = sequence; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let name, i; name = from[i1]; i = i1; lastChainedTest = lastChainedTest[applyMemberName](name, sequence[i + 1]); i1 += 2;};}; into; return lastChainedTest;};}), {chainedTest, firstIt});});});
//# sourceMappingURL=ChainedTest.js.map
