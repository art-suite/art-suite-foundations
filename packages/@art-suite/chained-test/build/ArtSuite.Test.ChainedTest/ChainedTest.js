"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "isPlainObject", "compactFlatten", "Promise", "merge", "isString", "Error", "formattedInspect", "isFunction"], [global, require('art-standard-lib'), require('art-class-system')], (BaseClass, isPlainObject, compactFlatten, Promise, merge, isString, Error, formattedInspect, isFunction) => {let cleanErrorStack, isMergeable, useIfMergeable, uniqueErrorsReported, chainedTest, firstIt, ChainedTest; cleanErrorStack = function(error, stackTraceIgnoreLineRegExp) {error.stack = Caf.array(error.stack.split("\n"), null, (line) => !stackTraceIgnoreLineRegExp.test(line)).join("\n"); return error;}; isMergeable = function(v) {return !(v != null) || isPlainObject(v);}; useIfMergeable = function(v) {return isPlainObject(v) ? v : undefined;}; uniqueErrorsReported = {}; return ({chainedTest, firstIt} = ChainedTest = Caf.defClass(class ChainedTest extends BaseClass {constructor(name, test, _runSetupOnce, _runDependencyChainOnce, options) {let self, temp, temp1; super(...arguments); this.name = name; this.test = test; this._runSetupOnce = _runSetupOnce; this._runDependencyChainOnce = _runDependencyChainOnce; this.options = options; ((temp = this.options) != null ? temp : this.options = {}); if (!isString(this.name)) {throw new Error(`chainedTest: Test name-string is required.\n\n${Caf.toString(formattedInspect({received: this.name}))}`);}; if (!isFunction(this.test)) {throw new Error(`chainedTest: Test function is required.\n\n${Caf.toString(formattedInspect({received: this.test}))}`);}; self = this; ((temp1 = global.it) != null ? temp1 : global.test)(this.name, function() {return self.runThisTestOnce().catch((error) => {let base; return uniqueErrorsReported[error.message] ? Caf.isF((base = this).skip) && base.skip() : (uniqueErrorsReported[error.message] = true, (() => {throw error;})());});});};}, function(ChainedTest, classSuper, instanceSuper) {this.chainedTest = function(a, b) {return new ChainedTest((b != null) ? a : "ChainedTest setup", b != null ? b : a);}; this.prototype.thenTest = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.thenTestMerged = function(...args) {return this._applySequence("_thenTestMerged", compactFlatten(args));}; this.prototype.tapTest = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapTest = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.prototype.alwaysTest = function(...args) {return this._applySequence("_alwaysTest", compactFlatten(args));}; this.firstIt = this.chainedTest; this.prototype.thenIt = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.tapIt = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapIt = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.prototype.alwaysIt = function(...args) {return this._applySequence("_alwaysTest", compactFlatten(args));}; this.prototype.finally = function(...args) {return this._applySequence("_alwaysTest", compactFlatten(args));}; this.getter({previousTestResultPromise: function() {let temp; return Promise.then(((temp = this._runDependencyChainOnce) != null ? temp : (() => {})));}, setupResultPromise: function() {let temp, temp1; return Promise.then(((temp = ((temp1 = this._runSetupOnce) != null ? temp1 : this._runDependencyChainOnce)) != null ? temp : (() => {})));}, runThisTestOnce: function() {let temp; return ((temp = this._runThisTestOnce) != null ? temp : this._runThisTestOnce = () => {let temp1; return ((temp1 = this._setupAndTestOncePromise) != null ? temp1 : this._setupAndTestOncePromise = Promise.all([this.options.always ? this.setupResultPromise : this.previousTestResultPromise, this.setupResultPromise]).then(([previousTestResult, setupResult]) => Promise.then(() => {chainedTest.current = this; return this.test(previousTestResult, setupResult);}).then((out) => {let filter; return (filter = this.options.filter) ? filter(out, previousTestResult) : out;})).catch((error) => (() => {throw cleanErrorStack(error, /ArtSuite.Test|caffeine-script-runtime|processImmediate|art-testbench|caffeine-script-runtime|bluebird|jest-jasmine2/);})()));});}, runSetupForNextLink: function() {let temp; return ((temp = this._runSetupOnce) != null ? temp : this.runThisTestOnce);}, runChainForNextLink: function() {return () => this.options.soft ? this.previousTestResultPromise : this.runThisTestOnce();}}); this.prototype._thenTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink);}; this.prototype._thenTestMerged = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {filter: (testResult, testInput) => Promise.deepResolve(testResult).then((testResult) => merge(useIfMergeable(testInput), useIfMergeable(testResult)))});}; this.prototype._alwaysTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {always: true});}; this.prototype._tapTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {filter: (res, prevRes) => prevRes});}; this.prototype._softTapTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {soft: true, filter: (res, prevRes) => prevRes});}; this.prototype._applySequence = function(applyMemberName, sequence) {let lastChainedTest, from, into, to, i1; lastChainedTest = this; from = sequence; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let name, i; name = from[i1]; i = i1; lastChainedTest = lastChainedTest[applyMemberName](name, sequence[i + 1]); i1 += 2;};}; into; return lastChainedTest;};}), {chainedTest, firstIt});});});
//# sourceMappingURL=ChainedTest.js.map
