"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "isPlainObject", "isString", "isFunction", "compactFlatten", "Promise", "merge", "Error", "formattedInspect"], [global, require('art-standard-lib'), require('art-class-system')], (BaseClass, isPlainObject, isString, isFunction, compactFlatten, Promise, merge, Error, formattedInspect) => {let cleanErrorStack, isMergeable, useIfMergeable, uniqueErrorsReported, chainedTest, firstIt, ChainedTest; cleanErrorStack = function(error, stackTraceIgnoreLineRegExp) {error.stack = Caf.array(error.stack.split("\n"), null, (line) => !stackTraceIgnoreLineRegExp.test(line)).join("\n"); return error;}; isMergeable = function(v) {return !(v != null) || isPlainObject(v);}; useIfMergeable = function(v) {return isPlainObject(v) ? v : undefined;}; uniqueErrorsReported = {}; return ({chainedTest, firstIt} = ChainedTest = Caf.defClass(class ChainedTest extends BaseClass {constructor(name, test, _runSetupOnce, _runDependencyChainOnce, options) {let self, temp, temp1, temp2; super(...arguments); this.name = name; this.test = test; this._runSetupOnce = _runSetupOnce; this._runDependencyChainOnce = _runDependencyChainOnce; this.options = options; ((temp = this.options) != null ? temp : this.options = {}); if (!isString(this.name)) {throw new Error(`chainedTest: Test name-string is required.\n\n${Caf.toString(formattedInspect({received: this.name}))}`);}; if (!isFunction(this.test)) {throw new Error(`chainedTest: Test function is required.\n\n${Caf.toString(formattedInspect({received: this.test}))}`);}; self = this; ((temp1 = ((temp2 = this.options.test) != null ? temp2 : global.it)) != null ? temp1 : global.test)(this.name, function(...args) {let context; ([context] = args); return self.runThisTestOnce().catch((error) => {let base, base1; return uniqueErrorsReported[error.message] ? ((() => {try {return Caf.isF((base = this.options).skip) && base.skip();} catch (error1) {};})(), (() => {try {return Caf.isF((base1 = this).skip) && base1.skip();} catch (error2) {};})()) : (uniqueErrorsReported[error.message] = true, (() => {throw error;})());});});};}, function(ChainedTest, classSuper, instanceSuper) {this.chainedTest = function(a, b, c) {let startTestName, startTestFunction, options, test, skip; startTestName = (() => {switch (false) {case !isString(a): return a; case !isString(b): return b; case !isString(c): return c; default: return "ChainedTest setup";};})(); startTestFunction = (() => {switch (false) {case !isFunction(a): return a; case !isFunction(b): return b; case !isFunction(c): return c; default: return () => {};};})(); options = ({test, skip} = (() => {switch (false) {case !isPlainObject(a): return a; case !isPlainObject(b): return b; case !isPlainObject(c): return c; default: return {};};})(), {test, skip}); return new ChainedTest(startTestName, startTestFunction, null, null, options);}; this.prototype.thenTest = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.thenTestMerged = function(...args) {return this._applySequence("_thenTestMerged", compactFlatten(args));}; this.prototype.tapTest = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapTest = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.prototype.alwaysTest = function(...args) {return this._applySequence("_alwaysTest", compactFlatten(args));}; this.firstIt = this.chainedTest; this.prototype.thenIt = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.tapIt = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapIt = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.prototype.alwaysIt = function(...args) {return this._applySequence("_alwaysTest", compactFlatten(args));}; this.prototype.finally = function(...args) {return this._applySequence("_alwaysTest", compactFlatten(args));}; this.getter({previousTestResultPromise: function() {let temp; return Promise.then(((temp = this._runDependencyChainOnce) != null ? temp : (() => {})));}, setupResultPromise: function() {let temp, temp1; return Promise.then(((temp = ((temp1 = this._runSetupOnce) != null ? temp1 : this._runDependencyChainOnce)) != null ? temp : (() => {})));}, runThisTestOnce: function() {let temp; return ((temp = this._runThisTestOnce) != null ? temp : this._runThisTestOnce = () => {let temp1; return ((temp1 = this._setupAndTestOncePromise) != null ? temp1 : this._setupAndTestOncePromise = Promise.all([this.options.always ? this.setupResultPromise : this.previousTestResultPromise, this.setupResultPromise]).then(([previousTestResult, setupResult]) => Promise.then(() => {chainedTest.current = this; return this.test(previousTestResult, setupResult);}).then((out) => {let filter; return (filter = this.options.filter) ? filter(out, previousTestResult) : out;})).catch((error) => (() => {throw cleanErrorStack(error, /ArtSuite.Test|caffeine-script-runtime|processImmediate|art-testbench|caffeine-script-runtime|bluebird|jest-jasmine2/);})()));});}, runSetupForNextLink: function() {let temp; return ((temp = this._runSetupOnce) != null ? temp : this.runThisTestOnce);}, runChainForNextLink: function() {return () => this.options.soft ? this.previousTestResultPromise : this.runThisTestOnce();}}); this.prototype._chainNextTest = function(nextName, nextTest, options) {let test, skip; return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, merge(options, ({test, skip} = this.options, {test, skip})));}; this.prototype._thenTest = function(nextName, nextTest) {return this._chainNextTest(nextName, nextTest);}; this.prototype._thenTestMerged = function(nextName, nextTest) {return this._chainNextTest(nextName, nextTest, {filter: (testResult, testInput) => Promise.deepResolve(testResult).then((testResult) => merge(useIfMergeable(testInput), useIfMergeable(testResult)))});}; this.prototype._alwaysTest = function(nextName, nextTest) {return this._chainNextTest(nextName, nextTest, {always: true});}; this.prototype._tapTest = function(nextName, nextTest) {return this._chainNextTest(nextName, nextTest, {filter: (res, prevRes) => prevRes});}; this.prototype._softTapTest = function(nextName, nextTest) {return this._chainNextTest(nextName, nextTest, {soft: true, filter: (res, prevRes) => prevRes});}; this.prototype._applySequence = function(applyMemberName, sequence) {let lastChainedTest, from, into, to, i1; lastChainedTest = this; from = sequence; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let name, i; name = from[i1]; i = i1; lastChainedTest = lastChainedTest[applyMemberName](name, sequence[i + 1]); i1 += 2;};}; into; return lastChainedTest;};}), {chainedTest, firstIt});});});
//# sourceMappingURL=ChainedTest.js.map
