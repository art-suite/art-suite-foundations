"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "compactFlatten", "Promise", "String", "Error", "formattedInspect", "Function"], [global, require('art-standard-lib'), require('art-class-system')], (BaseClass, compactFlatten, Promise, String, Error, formattedInspect, Function) => {let cleanErrorStack, uniqueErrorsReported, chainedTest, ChainedTest; cleanErrorStack = function(error, stackTraceIgnoreLineRegExp) {error.stack = Caf.array(error.stack.split("\n"), null, (line) => !stackTraceIgnoreLineRegExp.test(line)).join("\n"); return error;}; uniqueErrorsReported = {}; return ({chainedTest} = ChainedTest = Caf.defClass(class ChainedTest extends BaseClass {constructor(name, test, _runSetupOnce, _runDependencyChainOnce, options) {let self, temp; super(...arguments); this.name = name; this.test = test; this._runSetupOnce = _runSetupOnce; this._runDependencyChainOnce = _runDependencyChainOnce; this.options = options; if (!(Caf.is(this.name, String))) {throw new Error(`chainedTest: Test name-string is required.\n\n${Caf.toString(formattedInspect({received: this.name}))}`);}; if (!(Caf.is(this.test, Function))) {throw new Error(`chainedTest: Test function is required.\n\n${Caf.toString(formattedInspect({received: this.test}))}`);}; self = this; ((temp = global.test) != null ? temp : global.it)(this.name, function() {return self.runThisTestOnce().catch((error) => {let base; return uniqueErrorsReported[error.message] ? Caf.isF((base = this).skip) && base.skip() : (uniqueErrorsReported[error.message] = true, (() => {throw error;})());});});};}, function(ChainedTest, classSuper, instanceSuper) {this.chainedTest = function(a, b) {return new ChainedTest((b != null) ? a : "ChainedTest setup", b != null ? b : a);}; this.prototype.thenTest = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.tapTest = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapTest = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.prototype.thenIt = function(...args) {return this._applySequence("_thenTest", compactFlatten(args));}; this.prototype.tapIt = function(...args) {return this._applySequence("_tapTest", compactFlatten(args));}; this.prototype.softTapIt = function(...args) {return this._applySequence("_softTapTest", compactFlatten(args));}; this.getter({previousTestResultPromise: function() {let temp; return Promise.then(((temp = this._runDependencyChainOnce) != null ? temp : (() => {})));}, setupResultPromise: function() {let temp, temp1; return Promise.then(((temp = ((temp1 = this._runSetupOnce) != null ? temp1 : this._runDependencyChainOnce)) != null ? temp : (() => {})));}, runThisTestOnce: function() {let temp; return ((temp = this._runThisTestOnce) != null ? temp : this._runThisTestOnce = () => {let temp1; return ((temp1 = this._setupAndTestOncePromise) != null ? temp1 : this._setupAndTestOncePromise = Promise.all([this.previousTestResultPromise, this.setupResultPromise]).then(([previousTestResult, setupResult]) => Promise.then(() => this.test(previousTestResult, setupResult)).then((out) => {let base; return (Caf.exists(base = this.options) && base.tap) ? previousTestResult : out;})).catch((error) => (() => {throw cleanErrorStack(error, /ArtSuite.Test|caffeine-script-runtime|processImmediate|art-testbench|caffeine-script-runtime|bluebird|jest-jasmine2/);})()));});}, runSetupForNextLink: function() {let temp; return ((temp = this._runSetupOnce) != null ? temp : this.runThisTestOnce);}, runChainForNextLink: function() {return () => {let base; return (Caf.exists(base = this.options) && base.soft) ? this.previousTestResultPromise : this.runThisTestOnce();};}}); this.prototype._thenTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink);}; this.prototype._tapTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {tap: true});}; this.prototype._softTapTest = function(nextName, nextTest) {return new ChainedTest(nextName, nextTest, this.runSetupForNextLink, this.runChainForNextLink, {tap: true, soft: true});}; this.prototype._applySequence = function(applyMemberName, sequence) {let lastChainedTest, from, into, to, i1; lastChainedTest = this; from = sequence; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let name, i; name = from[i1]; i = i1; lastChainedTest = lastChainedTest[applyMemberName](name, sequence[i + 1]); i1 += 2;};}; into; return lastChainedTest;};}), {chainedTest});});});
//# sourceMappingURL=ChainedTest.js.map
