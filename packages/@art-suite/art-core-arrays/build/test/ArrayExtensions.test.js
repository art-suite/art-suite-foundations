"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "isArray", "assert", "isPlainObject", "isFunction", "RegExp", "isObject", "isString", "isBoolean", "isNumber", "isJsonType", "JSON", "arrayWithoutValue", "arrayWithout", "moveArrayElement", "arrayWithElementMoved", "arrayWithElementValueMoved", "compact", "flatten", "Array", "insertIntoArray", "arrayWithInsertedAt", "stableSort", "arrayWithLeftOfIndex", "arrayWithRightOfIndex", "arrayWithLeftOf", "arrayWithRightOf", "findSortedFirst", "w"], [global, require('./StandardImport')], (describe, test, isArray, assert, isPlainObject, isFunction, RegExp, isObject, isString, isBoolean, isNumber, isJsonType, JSON, arrayWithoutValue, arrayWithout, moveArrayElement, arrayWithElementMoved, arrayWithElementValueMoved, compact, flatten, Array, insertIntoArray, arrayWithInsertedAt, stableSort, arrayWithLeftOfIndex, arrayWithRightOfIndex, arrayWithLeftOf, arrayWithRightOf, findSortedFirst, w) => {let oneTwoTree, testEq, inspectForTestStringR, inspectForTestString; oneTwoTree = [1, 2, 3]; testEq = function(f, input, output) {return test(`${Caf.toString(f.name)} ${Caf.toString(input)} >> ${Caf.toString(output)}`, () => isArray(input) ? assert.eq(output, f(...input)) : assert.eq(output, f(input)));}; inspectForTestStringR = function(a) {let base; return (() => {switch (false) {case !isPlainObject(a): return Caf.object(a, (v, k) => inspectForTestStringR(v)); case !isArray(a): return Caf.array(a, (v, k) => inspectForTestStringR(v)); case !isFunction(a): return `${Caf.toString(a)}`; case !(Caf.is(a, RegExp)): return `${Caf.toString(a)}`; case !isObject(a): return `<${Caf.toString(Caf.exists(base = a.class) && base.name)} instance>`; case !isString(a): case !isBoolean(a): case !isNumber(a): return a; case !(a === null): return null; default: return `${Caf.toString(a)}`;};})();}; inspectForTestString = function(a) {return isJsonType(a) ? JSON.stringify(inspectForTestStringR(a)).slice(0, 100) : inspectForTestStringR(a);}; return describe({insertAndRemoveValues: function() {test("arrayWithoutValue", () => {assert.eq(arrayWithoutValue(oneTwoTree, 2), [1, 3]); assert.eq(arrayWithoutValue(oneTwoTree, 4), oneTwoTree); return assert.eq(arrayWithoutValue(), []);}); return test("arrayWithout", () => {assert.eq(arrayWithout(oneTwoTree, 2), [1, 2]); return assert.eq(arrayWithout(), []);});}, move: function() {let moveArrayElementTest, largeMoveArrayElementTest; moveArrayElementTest = (inArray, _from, _to, outArray) => test(`moveArrayElement ${Caf.toString(inspectForTestString(inArray))}, ${Caf.toString(_from)}, ${Caf.toString(_to)} >>> ${Caf.toString(inspectForTestString(outArray))}`, () => assert.eq(outArray, moveArrayElement(inArray, _from, _to))); moveArrayElementTest([1, 2, 3], 0, 0, [1, 2, 3]); moveArrayElementTest([1, 2, 3], 0, 1, [2, 1, 3]); moveArrayElementTest([1, 2, 3], 0, 2, [2, 3, 1]); moveArrayElementTest([1, 2, 3], 1, 0, [2, 1, 3]); moveArrayElementTest([1, 2, 3], 1, 1, [1, 2, 3]); moveArrayElementTest([1, 2, 3], 1, 2, [1, 3, 2]); moveArrayElementTest([1, 2, 3], 2, 0, [3, 1, 2]); moveArrayElementTest([1, 2, 3], 2, 1, [1, 3, 2]); moveArrayElementTest([1, 2, 3], 2, 2, [1, 2, 3]); largeMoveArrayElementTest = (_from, _to, tests) => test(`large moveArrayElement from:${Caf.toString(_from)}, to:${Caf.toString(_to)}`, () => {let a, largeArray, into, i; a = (into = [], i = 0, (() => {while (i < 1000) {let v; v = i; into.push(v); i++;};})(), into); assert.eq(a.length, 1000); assert.eq(a[0], 0); assert.eq(a[999], 999); largeArray = moveArrayElement(a, _from, _to); assert.eq(largeArray.length, 1000); Caf.each2(tests, (v, k) => {let index; index = k | 0; return assert.eq(largeArray[index], v, `largeArray[${Caf.toString(index)}] should == ${Caf.toString(v)}`);}); return undefined;}); largeMoveArrayElementTest(999, 0, {0: 999, 1: 0, 998: 997, 999: 998}); largeMoveArrayElementTest(0, 999, {0: 1, 1: 2, 998: 999, 999: 0}); test("arrayWithElementMoved [1,2,3], 2, 0", () => assert.eq([3, 1, 2], arrayWithElementMoved([1, 2, 3], 2, 0))); return test("arrayWithElementValueMoved [1,2,3], 3, 0", () => assert.eq([3, 1, 2], arrayWithElementValueMoved([1, 2, 3], 3, 0)));}, compact: function() {test("compact", () => {assert.eq(compact([1, 2, 3, null, 4]), [1, 2, 3, 4]); assert.eq(compact([1, 2, 3, null]), [1, 2, 3]); return assert.eq(compact([null, 1, 2, 3]), [1, 2, 3]);}); test("compact doesn't remove false", () => assert.eq(["child2", "child3", false, "child4"], compact([undefined, "child2", null, "child3", false, "child4"]))); test("compact not needed returns exactly the input array", () => {let a; a = [1, 3, 4]; return assert.equal(a, compact(a));}); return test("compact with custom keepTester", () => {let structure; structure = [0, false, 1, 2, null, 3, 4, undefined, 5]; assert.eq(compact(structure), [0, false, 1, 2, 3, 4, 5]); return assert.eq(compact(structure, (a) => !!a), [1, 2, 3, 4, 5]);});}, flatten: function() {test("flatten empty array", () => assert.eq(flatten([]), [])); test("flatten not needed returns exactly the input array", () => {let a; a = [1, 3, 4]; return assert.equal(a, flatten(a));}); test("flatten args returns array", () => assert.eq(flatten(1, 2, 3).constructor, Array)); test("flatten() => []", () => assert.eq([], flatten())); test("flatten [] => []", () => assert.eq([], flatten([]))); test("flatten 1 => [1]", () => assert.eq([1], flatten(1))); test("flatten [1] => [1]", () => assert.eq([1], flatten([1]))); test("flatten 1, 2 => [1, 2]", () => assert.eq([1, 2], flatten(1, 2))); test("flatten [1], 2 => [1, 2]", () => assert.eq([1, 2], flatten([1], 2))); test("flatten 1, [2] => [1, 2]", () => assert.eq([1, 2], flatten(1, [2]))); test("flatten [1, 2] => [1, 2]", () => assert.eq([1, 2], flatten([1, 2]))); test("flatten already flat array returns untouched input", () => {let b, a; b = flatten(a = [1, 2, 3, 4, 5]); return assert.eq(true, a === b);}); test("flatten keeps nulls, undefineds, falses and 0s", () => assert.eq(flatten([null, undefined, false, 0]), [null, undefined, false, 0])); test("flatten array with one sub-array", () => assert.eq(flatten([1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5])); test("flatten array lots of direct nesting", () => {assert.eq(flatten([[[1]]]), [1]); return assert.eq(flatten([[[]]]), []);}); test("flatten array with random nesting", () => assert.eq(flatten([[0, [1, 2], 3], [4, [5, [6, 7]]]]), [0, 1, 2, 3, 4, 5, 6, 7])); return test("flatten array with nested []", () => assert.eq(flatten([[], 1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5]));}, insertIntoArray: function() {test("insertIntoArray 0", () => assert.eq(insertIntoArray([1, 2, 3], 0, 999), [999, 1, 2, 3])); test("insertIntoArray 3", () => assert.eq(insertIntoArray([1, 2, 3], 3, 999), [1, 2, 3, 999])); test("insertIntoArray -1", () => assert.eq(insertIntoArray([1, 2, 3], -1, 999), [1, 2, 3, 999])); test("insertIntoArray -2", () => assert.eq(insertIntoArray([1, 2, 3], -2, 999), [1, 2, 999, 3])); return test("arrayWithInsertedAt 0", () => {let a, b; a = [1, 2, 3]; b = arrayWithInsertedAt(a, 0, 999); assert.eq(a, [1, 2, 3]); return assert.eq(b, [999, 1, 2, 3]);});}, stableSort: function() {test("stableSort works like sort (except for stability)", () => {let arrays; arrays = [[1, 2, 3, 4], [4, 3, 2, 1], [3, 1, 2, 4], [], [1], [2, 1], [1, 2, 3], [1, 1], [2, 3, 1, 1, 4]]; Caf.each2(arrays, (a) => assert.eq(a.sort(), stableSort(a))); return undefined;}); return test("stableSort maintains order of 'same' elements", () => {let list, stableSortedList, sortFunction; list = [[2, "a"], [1, "b"], [1, "c"], [0, "f"], [1, "d"], [1, "e"]]; stableSortedList = [[0, "f"], [1, "b"], [1, "c"], [1, "d"], [1, "e"], [2, "a"]]; sortFunction = (a, b) => a[0] - b[0]; return assert.eq(stableSortedList, stableSort(list, sortFunction));});}, "slice helpers": function() {test("arrayWithLeftOfIndex null array", () => assert.eq(null, arrayWithLeftOfIndex(null, 0))); test("arrayWithRightOfIndex null array", () => assert.eq(null, arrayWithRightOfIndex(null, 0))); test("arrayWithLeftOfIndex 0", () => assert.eq([], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], 0))); test("arrayWithRightOfIndex 0", () => assert.eq([2, 3, 4, 5, 6], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], 0))); test("arrayWithLeftOfIndex -2", () => assert.eq([1, 2, 3, 4], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], -2))); test("arrayWithRightOfIndex -2", () => assert.eq([6], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], -2))); test("arrayWithLeftOfIndex -1", () => assert.eq([1, 2, 3, 4, 5], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], -1))); test("arrayWithRightOfIndex -1", () => assert.eq([], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], -1))); test("arrayWithLeftOfIndex 3", () => assert.eq([1, 2, 3], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], 3))); test("arrayWithRightOfIndex 3", () => assert.eq([5, 6], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], 3))); test("arrayWithLeftOfIndex 5", () => assert.eq([1, 2, 3, 4, 5], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], 5))); test("arrayWithRightOfIndex 5", () => assert.eq([], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], 5))); test("arrayWithLeftOfIndex 6", () => assert.eq([1, 2, 3, 4, 5, 6], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], 6))); test("arrayWithRightOfIndex 6", () => assert.eq([], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], 6))); test("arrayWithLeftOfIndex 7", () => assert.eq([1, 2, 3, 4, 5, 6], arrayWithLeftOfIndex([1, 2, 3, 4, 5, 6], 7))); test("arrayWithRightOfIndex 7", () => assert.eq([], arrayWithRightOfIndex([1, 2, 3, 4, 5, 6], 7))); test("arrayWithLeftOf one match", () => assert.eq([1, 2, 3], arrayWithLeftOf([1, 2, 3, 4, 5, 6], 4))); test("arrayWithRightOf one match ", () => assert.eq([5, 6], arrayWithRightOf([1, 2, 3, 4, 5, 6], 4))); test("arrayWithLeftOf no match", () => assert.eq([1, 2, 3, 4, 5, 6], arrayWithLeftOf([1, 2, 3, 4, 5, 6], 400))); test("arrayWithRightOf no match ", () => assert.eq([], arrayWithRightOf([1, 2, 3, 4, 5, 6], 400))); test("arrayWithLeftOf two matches", () => assert.eq([1], arrayWithLeftOf([1, 4, 3, 4, 5, 6], 4))); return test("arrayWithRightOf two matches", () => assert.eq([3, 4, 5, 6], arrayWithRightOf([1, 4, 3, 4, 5, 6], 4)));}, findSortedFirst: function() {test("empty or null/undefined array returns undefined", () => {assert.eq(undefined, findSortedFirst([])); assert.eq(undefined, findSortedFirst(null)); return assert.eq(undefined, findSortedFirst(undefined));}); test("numbers", () => {assert.eq(1, findSortedFirst([3, 1, 2])); assert.eq(1, findSortedFirst([1, 2, 3])); return assert.eq(1, findSortedFirst([1, 3, 2]));}); return test("custom compareFunction with numbers", () => {assert.eq(3, findSortedFirst([3, 1, 2], (a, b) => b - a)); assert.eq(3, findSortedFirst([1, 2, 3], (a, b) => b - a)); return assert.eq(3, findSortedFirst([1, 3, 2], (a, b) => b - a));});}, w: function() {testEq(w, "this", ["this"]); testEq(w, "this ~!@#$%^&*()_+{}|:<>? stinks", ["this", "~!@#$%^&*()_+{}|:<>?", "stinks"]); testEq(w, "this is it", ["this", "is", "it"]); testEq(w, ["this is", "it also"], ["this", "is", "it", "also"]); return testEq(w, [123, "it also", {foo: ["baz it", ["keep together"]]}], [123, "it", "also", {foo: ["baz it", ["keep together"]]}]);}});});});
//# sourceMappingURL=ArrayExtensions.test.js.map
