"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["toSeconds", "Date", "pluralize", "longTimeNames", "secondsPer", "compactFlatten", "round", "formatDate", "toDate", "Math"], [global, require('art-standard-lib'), require('./TimeConstants')], (toSeconds, Date, pluralize, longTimeNames, secondsPer, compactFlatten, round, formatDate, toDate, Math) => {let TimePresenters; return TimePresenters = Caf.defClass(class TimePresenters extends Object {}, function(TimePresenters, classSuper, instanceSuper) {let dateAgeInSeconds, humanDurationStringHelper, humanDurationString, timeAgo; this.dateAgeInSeconds = dateAgeInSeconds = function(date, now = new Date) {return toSeconds(now) - toSeconds(date);}; humanDurationStringHelper = function(number, unit, verbose) {return verbose ? pluralize(number, longTimeNames[unit]) : `${Caf.toString(number)}${Caf.toString(unit)}`;}; this.humanDurationString = humanDurationString = function(seconds, {verbose, precision} = {precision: 1}) {let units, unit, number, into, to, i1, by; return (precision > 1) ? (units = (() => {switch (false) {case !(seconds < secondsPer.m): return ["s"]; case !(seconds < secondsPer.h): return ["m", "s"]; case !(seconds < secondsPer.d): return ["h", "m", "s"]; case !(seconds < secondsPer.mo): return ["d", "h", "m", "s"]; case !(seconds < secondsPer.y): return ["mo", "d", "h", "m", "s"]; default: return ["y", "mo", "d", "h", "m", "s"];};})(), compactFlatten((into = [], to = precision, i1 = 0, by = (i1 < to) ? 1 : -1, (() => {while (by > 0 && i1 < to || by < 0 && i1 > to) {let i, currentUnit; i = i1; into.push((currentUnit = units[i]) ? (number = seconds / secondsPer[currentUnit], (i === precision - 1) ? number = round(number) : number |= 0, seconds %= secondsPer[currentUnit], humanDurationStringHelper(number, currentUnit, verbose)) : undefined); i1 += by;};})(), into)).join(" ")) : (unit = (() => {switch (false) {case !(seconds < secondsPer.m): return "s"; case !(seconds < 3 * secondsPer.h): return "m"; case !(seconds < 3 * secondsPer.d): return "h"; case !(seconds < 3 * secondsPer.mo): return "d"; case !(seconds < 2 * secondsPer.y): return "mo"; default: return "y";};})(), number = round(seconds / secondsPer[unit]), humanDurationStringHelper(number, unit, verbose));}; this.niceFullDateString = function(date) {return formatDate(date, "h:MMtt mmmm d, yyyy");}; this.niceMonthYear = function(date) {return formatDate(date, "mmmm yyyy");}; this.niceDateString = function(date, now) {now = toDate(now); date = toDate(date); return (() => {switch (Math.round((toSeconds(date) - toSeconds(now)) / secondsPer.day)) {case 1: return "tomorrow"; case -1: return "yesterday"; case 0: return "today"; default: return (now.getFullYear() !== date.getFullYear()) ? formatDate(date, "mmmm d, yyyy") : (now.getMonth() !== date.getMonth()) ? formatDate(date, "mmmm d") : formatDate(date, "mmmm d");};})();}; this.niceTimeDetailsString = (date, now) => `${Caf.toString(formatDate(date, "h:MMtt"))} ${Caf.toString(this.niceDateString(date, now))}`; this.timeAgo = timeAgo = function(date, {verbose, precision, now} = {now: toDate()}) {let ageInSeconds, ageInMinutes, ageInHours, ageInDays, minPlural; ageInSeconds = dateAgeInSeconds(date, now); return (ageInSeconds < 0) ? (verbose ? "in " : "-") + humanDurationString(-ageInSeconds, {verbose, precision, now}) : (ageInMinutes = ageInSeconds / secondsPer.minute, ageInHours = ageInSeconds / secondsPer.hour, ageInDays = ageInSeconds / secondsPer.day, (ageInMinutes < 1 && !(precision > 1)) ? "just now" : (minPlural = humanDurationString(ageInSeconds, {verbose, precision, now}), verbose ? minPlural + " ago" : minPlural));};});});});
//# sourceMappingURL=TimePresenters.js.map
