// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, ClassSystem, Promise, StandardLib, WebWorker, Worker, WorkerRpc, debugPrefix, isFunction, isPlainArray, isString, isWebWorker, log, mergeInto,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  StandardLib = require('art-standard-lib');

  ClassSystem = require('art-class-system');

  WebWorker = require('./WebWorker');

  Promise = StandardLib.Promise, log = StandardLib.log, isPlainArray = StandardLib.isPlainArray, isFunction = StandardLib.isFunction, isString = StandardLib.isString, mergeInto = StandardLib.mergeInto;

  BaseObject = ClassSystem.BaseObject;

  isWebWorker = WebWorker.isWebWorker;

  Worker = global.Worker;

  debugPrefix = isWebWorker ? "WorkerRpc(worker)" : "WorkerRpc(browser)";

  module.exports = WorkerRpc = (function(superClass) {
    var workerRpcChannelIdString;

    extend(WorkerRpc, superClass);

    WorkerRpc.singletonClass();

    WorkerRpc.workerRpcChannelIdString = workerRpcChannelIdString = "Art.Foundation.WorkerRpcChannel";

    WorkerRpc.register = function(toRegister) {
      return WorkerRpc.singleton.register(toRegister);
    };

    WorkerRpc.bind = function(toBind) {
      return WorkerRpc.singleton._bind(toBind, false);
    };

    WorkerRpc.bindWithPromises = function(toBind) {
      return WorkerRpc.singleton._bind(toBind, true);
    };


    /*
    INPUT:
      thread:
        must implement onmessage= and postMessage or be null
        In a webworker, this gets set to self if it is null.
      options:
        bind: map # invokes: @bind map
        bindWithPromises: map # invokes: @bindWithPromises map
     */

    function WorkerRpc(thread, options) {
      if (isString(thread)) {
        log("WorkerRpc starting worker: " + thread);
        thread = new Worker(thread);
        log("WorkerRpc starting worker: " + thread + ", started?:", thread);
      }
      if (!(thread || self === self.window)) {
        thread = self;
      }
      this._reset();
      this._bindOnmessage(this._thread = thread);
      if (options) {
        this._applyOptions(options);
      }
    }

    WorkerRpc.prototype.register = function(toRegister) {
      var functionMap, namespaceName;
      if (!toRegister) {
        return;
      }
      for (namespaceName in toRegister) {
        functionMap = toRegister[namespaceName];
        if (this._registry.hasOwnProperty(namespaceName)) {
          mergeInto(this._registry[namespaceName], functionMap);
        } else {
          this._registry[namespaceName] = functionMap;
        }
      }
      return this._registry;
    };


    /*
    Creates functions to make specific remote-procedure-calls.
    
    IN:
      toBind: map to arrays of strings
        Each key in the map specifies a namespace.
        The array of strings specify the names of each RPC you want to be able to invoke.
    
    For a given namespaceName and functionName, this binds the function so you can
    invoke it as follows:
      @myNamespaceName.myFunctionName()
    
    The created functions are one-way. They return null as soon as the message has been sent
    to the remote thread. If you want the results, see @bindWithPromises
     */

    WorkerRpc.prototype.bind = function(toBind) {
      return this._bind(toBind, false);
    };


    /*
    Same as @bind except each function created will return a promise which will return
    the results return from the remote procedure call when they are ready.
     */

    WorkerRpc.prototype.bindWithPromises = function(toBind) {
      return this._bind(toBind, true);
    };

    WorkerRpc.prototype._bind = function(toBind, withPromises) {
      var functionName, functionNames, i, len, namespace, namespaceName, ref;
      if (!isFunction((ref = this._thread) != null ? ref.postMessage : void 0)) {
        throw new Error("@_thread.postMessage required for remote requests");
      }
      if (!toBind) {
        return;
      }
      namespace = null;
      for (namespaceName in toBind) {
        functionNames = toBind[namespaceName];
        if (!this.hasOwnProperty(namespaceName)) {
          this[namespaceName] = {};
        }
        namespace = this[namespaceName];
        for (i = 0, len = functionNames.length; i < len; i++) {
          functionName = functionNames[i];
          namespace[functionName] = withPromises ? this._newRemoteRequestFunctionWithPromise(namespaceName, functionName) : this._newRemoteRequestFunction(namespaceName, functionName);
        }
      }
      return namespace;
    };

    WorkerRpc.prototype._reset = function() {
      return this._registry = {
        promiseCallback: {
          success: (function(_this) {
            return function(promiseId, result) {
              return WorkerRpc._resolvePromise(promiseId, result);
            };
          })(this),
          error: (function(_this) {
            return function(promiseId, error) {
              return WorkerRpc._rejectPromise(promiseId, error);
            };
          })(this)
        }
      };
    };

    WorkerRpc.prototype._applyOptions = function(arg) {
      var bind, bindWithPromises, register;
      register = arg.register, bind = arg.bind, bindWithPromises = arg.bindWithPromises;
      this.register(register);
      this.bind(bind);
      this.bindWithPromises(bindWithPromises);
      return this;
    };

    WorkerRpc.prototype._send = function(namespaceName, functionName, promiseId, args) {
      return this._thread.postMessage([workerRpcChannelIdString, namespaceName, functionName, promiseId, args]);
    };

    WorkerRpc.prototype._newRemoteRequestFunctionWithPromise = function(namespaceName, functionName) {
      return (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return WorkerRpc._bindPromise(function(promiseId) {
            return _this._send(namespaceName, functionName, promiseId, args);
          });
        };
      })(this);
    };

    WorkerRpc.prototype._newRemoteRequestFunction = function(namespaceName, functionName) {
      return (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return _this._send(namespaceName, functionName, null, args);
        };
      })(this);
    };

    WorkerRpc.prototype._bindOnmessage = function(thread) {
      var handler;
      if (!thread) {
        return;
      }
      handler = (function(_this) {
        return function(arg) {
          var args, data, functionName, namespaceName, promiseId, testWorkerRpcChannelIdString;
          data = arg.data;
          if (!isPlainArray(data)) {
            return;
          }
          testWorkerRpcChannelIdString = data[0], namespaceName = data[1], functionName = data[2], promiseId = data[3], args = data[4];
          if (testWorkerRpcChannelIdString !== workerRpcChannelIdString) {
            return;
          }
          return _this._invokeLocalFunction(namespaceName, functionName, promiseId, args);
        };
      })(this);
      if (thread.addEventListener) {
        return thread.addEventListener('message', handler);
      } else {
        return thread.onmessage = handler;
      }
    };

    WorkerRpc.prototype._invokeLocalFunction = function(namespaceName, functionName, promiseId, args) {
      var localFunction, namespace, singleton;
      if (!((namespace = this._registry[namespaceName]) && (localFunction = namespace[functionName]))) {
        singleton = WorkerRpc.singleton;
        if (this !== singleton && (namespace = singleton._registry[namespaceName])) {
          localFunction = namespace[functionName];
        }
      }
      if (!localFunction) {
        console.warn(debugPrefix + "_onmessage: could not find: '" + namespaceName + "." + functionName + "'\n\nnamespaces: " + (Object.keys(this._registry).join(', ')) + "\nglobal namespaces: " + (singleton === this ? "(same)" : Object.keys(singleton._registry).join(', ')));
      }
      if (localFunction) {
        WorkerRpc.lastMessageReceivedFrom = this;
        return this._resolveOrRejectRemotePromise(promiseId, localFunction.apply(namespace, args));
      }
    };

    WorkerRpc.prototype._resolveOrRejectRemotePromise = function(promiseId, result) {
      if (promiseId == null) {
        return;
      }
      return Promise.resolve(result).then((function(_this) {
        return function(result) {
          return _this._send("promiseCallback", "success", null, [promiseId, result], function(error) {
            return _this._send("promiseCallback", "error", null, [promiseId, error]);
          });
        };
      })(this));
    };


    /*
    IN:   f: (promiseId) -> ignored
    OUT:  promise
    
    Creates a new promise, addes it to @_promises with a unique id, and invokes f, passing in
    the promise's id.
     */

    WorkerRpc._promises = {};

    WorkerRpc._nextPromiseId = 0;

    WorkerRpc._bindPromise = function(f) {
      var promise, promiseId;
      this._promises[promiseId = this._nextPromiseId++] = promise = Promise.newExternallyResolvable();
      f(promiseId);
      return promise;
    };

    WorkerRpc._resolvePromise = function(promiseId, result) {
      var ref;
      if ((ref = this._promises[promiseId]) != null) {
        ref.resolve(result);
      }
      return delete this._promises[promiseId];
    };

    WorkerRpc._rejectPromise = function(promiseId, error) {
      var ref;
      if ((ref = this._promises[promiseId]) != null) {
        ref.reject(error);
      }
      return delete this._promises[promiseId];
    };

    return WorkerRpc;

  })(BaseObject);

}).call(this);

//# sourceMappingURL=WorkerRpc.js.map
