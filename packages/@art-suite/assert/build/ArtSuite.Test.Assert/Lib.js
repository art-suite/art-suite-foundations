"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isFunction", "isPlainObject", "Error", "failWithExpectedMessage", "inspectedObjectLiteral", "assert", "isObject", "eq", "Object", "isArray"], [global, require('art-standard-lib'), require('./Presentation'), require('chai')], (isFunction, isPlainObject, Error, failWithExpectedMessage, inspectedObjectLiteral, assert, isObject, eq, Object, isArray) => {let getTesterFor, addTester, eqAfterStringifyingFunctions; return [require('./Presentation'), {getTesterFor: getTesterFor = function(name, a, b) {let tester, options; tester = isFunction(a) ? a : isPlainObject(a) ? (options = a, b) : (() => {throw new Error("expected object or function");})(); if (!isFunction(tester)) {throw new Error("expected tester function");}; return (() => {switch (tester.length) {case 1: return (testValue, context) => !tester(testValue) ? (Caf.exists(options) && options.customFailure) ? Caf.exists(options) && options.customFailure(name, testValue, context) : failWithExpectedMessage(context, inspectedObjectLiteral(name), "should be true for", testValue) : undefined; default: return (value1, value2, context) => !tester(value1, value2) ? (Caf.exists(options) && options.customFailure) ? Caf.exists(options) && options.customFailure(name, value1, value2, context) : failWithExpectedMessage(context, value1, (() => {switch (name) {case "<": case ">": case "<=": case ">=": case "lte": case "gte": return `should be '${Caf.toString(name)}' this value:`; case "==": case "eq": case "equal": case "match": return `should '${Caf.toString(name)}' this value:`; default: return `should be '${Caf.toString(name)}' to this value:`;};})(), value2) : undefined;};})();}, addTester: addTester = function(name, a, b) {let testerFor; return assert[name] = testerFor = getTesterFor(name, a, b);}, eqAfterStringifyingFunctions: eqAfterStringifyingFunctions = function(a, b) {return (() => {switch (false) {case !isObject(a): return isObject(b) && eq(Object.keys(a).sort(), Object.keys(b).sort()) && !Caf.find(a, null, (v, k) => !eqAfterStringifyingFunctions(v, b[k])); case !isArray(a): return isArray(b) && a.length === b.length && !Caf.find(a, null, (v, i) => !eqAfterStringifyingFunctions(v, b[i])); case !isFunction(a): return isFunction(b) && `${Caf.toString(a)}` === `${Caf.toString(b)}`; default: return eq(a, b);};})();}}];});});
//# sourceMappingURL=Lib.js.map
