"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["getEnv", "isNode", "process", "peek", "isString", "merge", "console", "red", "yellow", "stripAnsi", "Inspect", "containsPromises", "deepAll"], [global, require('./StandardImport'), {Inspect: require('./Inspect')}], (getEnv, isNode, process, peek, isString, merge, console, red, yellow, stripAnsi, Inspect, containsPromises, deepAll) => {let callStack, ART_CORE_LOGGING_DISABLED, noOptions, promiseLogId, standardOptions, Log, log, showLogging, hideLogging; callStack = require('./CallStack').callStack; ART_CORE_LOGGING_DISABLED = getEnv().ART_CORE_LOGGING_DISABLED; noOptions = {}; promiseLogId = 1; standardOptions = isNode ? {color: process.stdout.isTTY} : {}; Log = Caf.defClass(class Log extends Object {}, function(Log, classSuper, instanceSuper) {this.hideLogging = () => this.loggingHidden = true; this.showLogging = () => this.loggingHidden = false; this.log = (...args) => ART_CORE_LOGGING_DISABLED ? peek(args) : this.log.withOptions(standardOptions, ...args); this.log.full = (...args) => this.log.withOptions({maxArrayLength: 100000}, ...args); this.log.withOptions = function(options, ...args) {let m; m = (args.length === 1) ? args[0] : args; Log._logCore(m, callStack(), options); return peek(args);}; this.log.labeled = (a, b) => {let obj, ret; return isString(a) ? (obj = {}, obj[a] = b, this.log(obj), b) : (ret = null, Caf.each2(a, (v, k) => ret = v), this.log(obj), ret);}; this.log.unquoted = (...args) => this.log.withOptions(merge(standardOptions, {unquoted: true}), ...args); this.log.error = (...args) => this.log.withOptions({isError: [true, ...args]}); this.log.warn = (...args) => this.log.withOptions({isWarning: [true, ...args]}); this._rawLog = (...args) => !this.loggingHidden ? console.log(...args) : undefined; this._rawErrorLog = (...args) => {let str; if (this.loggingHidden) {return;}; return isNode ? (str = args.join(" "), console.error(red(str))) : console.error(...args);}; this._rawWarningLog = (...args) => {let str; if (this.loggingHidden) {return;}; return isNode ? (str = args.join(" "), console.warn(yellow(str))) : console.warn(...args);}; this._getLogger = function({isError, isWarning}) {return isError ? Log._rawErrorLog : isWarning ? Log._rawWarningLog : Log._rawLog;}; this._logCore = (m, stack, options = noOptions) => {if (this.alternativeLogger) {this.alternativeLogger._logCore(m, stack, options);}; return options.resolvePromises ? this._resolvePromiseWrapper(m, (toLog, label) => this._logNow({[label]: [toLog, stack, options]})) : this._logNow(m, stack, options);}; this._logNow = (m, stack, options) => {let color, logger; color = options.color; logger = this._getLogger(options); return isNode ? logger(isString(m) ? color ? m : stripAnsi(m) : Inspect.formattedInspect(m, merge({maxLineLength: process.stdout.columns}, options))) : logger(m);}; this._resolvePromiseWrapper = function(m, logger) {let toResolve, logId; return containsPromises(m) ? (toResolve = m, logId = promiseLogId++, logger(m, `RESOLVING_${Caf.toString(logId)}`, false), deepAll(toResolve).then((resolvedM) => logger(resolvedM, `RESOLVED_${Caf.toString(logId)}`, true)).catch((rejected) => logger(rejected, `REJECTED_${Caf.toString(logId)}`, true, true))) : logger(m, false);};}); return ({log, showLogging, hideLogging} = Log, {log, showLogging, hideLogging});});});
//# sourceMappingURL=Log.js.map
