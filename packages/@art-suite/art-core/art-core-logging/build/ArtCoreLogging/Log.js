"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["getEnv", "isNode", "process", "Inspect", "isString", "console", "red", "yellow", "stripAnsi", "merge", "peek", "containsPromises", "deepAll"], [global, require('./StandardImport'), {Inspect: require('./Inspect')}], (getEnv, isNode, process, Inspect, isString, console, red, yellow, stripAnsi, merge, peek, containsPromises, deepAll) => {let callStack, ART_CORE_LOGGING_DISABLED, Log; callStack = require('./CallStack').callStack; ART_CORE_LOGGING_DISABLED = getEnv().ART_CORE_LOGGING_DISABLED; return Log = Caf.defClass(class Log extends Object {}, function(Log, classSuper, instanceSuper) {let noOptions, getLogger, promiseLogId, standardOptions; this.contextString = (stack, defaultContext) => {let caller, context; return (stack && (caller = stack[1])) ? caller.original ? caller.original : (context = caller.function ? caller.class ? `${Caf.toString(caller.class)}::${Caf.toString(caller.function)}()` : caller.function + "()" : defaultContext ? defaultContext + ":" : "", caller.sourceFileName ? "at " + caller.sourceFileName + `-${Caf.toString(caller.sourceLine)}: ` + context : undefined) : `at ${Caf.toString(defaultContext || "(unknown context)")}`;}; this.autoSizedInspect = (toInspect, maxLength = 512, maxDepth = 10) => {let inspected, depth; inspected = null; depth = maxDepth; while ((inspected = Inspect.inspectLean(toInspect, {maxDepth: depth, maxLength})).match(/\.\.\.$/)) {depth--;}; return inspected;}; this.loggedParamsString = (params) => isString(params) ? params : this.autoSizedInspect(params); this.hideLogging = () => this.loggingHidden = true; this.showLogging = () => this.loggingHidden = false; this.rawLog = (...args) => !this.loggingHidden ? console.log(...args) : undefined; this.rawErrorLog = (...args) => {let str; if (this.loggingHidden) {return;}; return isNode ? (str = args.join(" "), console.error(red(str))) : console.error(...args);}; this.rawWarningLog = (...args) => {let str; if (this.loggingHidden) {return;}; return isNode ? (str = args.join(" "), console.warn(yellow(str))) : console.warn(...args);}; noOptions = {}; getLogger = function({isError, isWarning}) {return isError ? Log.rawErrorLog : isWarning ? Log.rawWarningLog : Log.rawLog;}; promiseLogId = 1; this.logCore = (m, stack, options = noOptions) => {if (this.alternativeLogger) {this.alternativeLogger.logCore(m, stack, options);}; return options.resolvePromises ? this.log.resolvePromiseWrapper(m, (toLog, label) => this._logNow({[label]: [toLog, stack, options]})) : this._logNow(m, stack, options);}; this._logNow = (m, stack, options) => {let className, color, logger; className = options.className; color = options.color; logger = getLogger(options); return isNode ? logger(isString(m) ? color ? m : stripAnsi(m) : Inspect.formattedInspect(m, merge({maxLineLength: process.stdout.columns}, options))) : logger(m);}; standardOptions = isNode ? ((() => {try {return eval("require")("colors");} catch (error) {};})(), {color: process.stdout.isTTY}) : {}; this.log = (...args) => ART_CORE_LOGGING_DISABLED ? peek(args) : this.log.withOptions(standardOptions, ...args); this.log.full = (...args) => this.log.withOptions({maxArrayLength: 100000}, ...args); this.log.resolvePromiseWrapper = function(m, logger) {let toResolve, logId; return containsPromises(m) ? (toResolve = m, logId = promiseLogId++, logger(m, `RESOLVING_${Caf.toString(logId)}`, false), deepAll(toResolve).then((resolvedM) => logger(resolvedM, `RESOLVED_${Caf.toString(logId)}`, true)).catch((rejected) => logger(rejected, `REJECTED_${Caf.toString(logId)}`, true, true))) : logger(m, false);}; this.log.withOptions = function(options, ...args) {let m; m = (args.length === 1) ? args[0] : args; Log.logCore(m, callStack(), options); return peek(args);}; this.log.labeled = (a, b) => {let obj, ret; return isString(a) ? (obj = {}, obj[a] = b, this.log(obj), b) : (ret = null, Caf.each2(a, (v, k) => ret = v), this.log(obj), ret);}; this.log.unquoted = (...args) => this.log.withOptions(merge(standardOptions, {unquoted: true}), ...args); this.log.error = (...args) => this.log.withOptions({isError: [true, ...args]}); this.log.warn = (...args) => this.log.withOptions({isWarning: [true, ...args]});});});});
//# sourceMappingURL=Log.js.map
