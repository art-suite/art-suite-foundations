"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "inspectForTestString", "formattedInspect", "isString", "assert", "stripTrailingWhitespace", "alignTabs", "failsafeInspect", "Error", "BaseClass", "inspectedObjectLiteral"], [global, require('../StandardImport'), require('art-class-system')], (describe, test, inspectForTestString, formattedInspect, isString, assert, stripTrailingWhitespace, alignTabs, failsafeInspect, Error, BaseClass, inspectedObjectLiteral) => {let oneLine, testFI, testFIMultiLine, testFormattedInspectString, testAlignTabs; oneLine = function(str) {return str.replace(/\n/g, "\\n");}; testFI = function(input, out, altOut) {return test(`formattedInspect ${Caf.toString(inspectForTestString(input))}`, () => {let o; o = formattedInspect(input); return isString(out) ? (altOut !== o) ? assert.eq(o, out) : undefined : assert.match(o, out);});}; testFIMultiLine = function(input, out, maxLineLength = 0) {return test(`formattedInspect ${Caf.toString(inspectForTestString(input))}`, () => {let o; o = stripTrailingWhitespace(formattedInspect(input, maxLineLength)); return assert.eq(o, out);});}; testFormattedInspectString = function(map) {return Caf.object(map, (v, k) => test(oneLine(`${Caf.toString(k)} > ${Caf.toString(v)}`), () => assert.eq(formattedInspect(k), v)));}; testAlignTabs = function(str, testStr, maxLineLength = 10000) {return test(`${Caf.toString(inspectForTestString(str))}`, () => assert.eq(alignTabs(str, maxLineLength), testStr));}; return describe({unquoted: function() {return test("simple unquoted", () => {let out; out = formattedInspect({foo: "bar"}, {unquoted: true}); return assert.eq(out, "foo: bar");});}, failsafeInspect: function() {test("failsafeInspect", () => assert.eq(failsafeInspect({a: 123}), "typeof: object\nconstructor: Object\nkeys: a")); return test("trigger failsafeInspect", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {}, function(Foo, classSuper, instanceSuper) {this.prototype.getInspectedObjects = function() {return (() => {throw new Error("failed to inspect");})();};}); return assert.eq(formattedInspect(new Foo), "Error in formattedInspect: Error: failed to inspect\ntypeof: object\nconstructor: Foo\nkeys: (no keys)");});}, singleLine: function() {let Foo; Foo = Caf.defClass(class Foo extends BaseClass {}, function(Foo, classSuper, instanceSuper) {this.namespacePath = "MyNamespace.Foo";}); testFI('"hi there"', '\'\"hi there\"\''); testFI("'hi there'", '"\'hi there\'"'); testFI("\\", "'\\'"); testFI("\0", '"\\u0000"'); testFI("\b", '"\\b"'); testFI("\f", '"\\f"'); testFI("\r", '"\\r"'); testFI("\t", '"\\t"'); testFI("a\n\\ a\n\0 a\n\b a\n\f a\n\r a\n\v a\n\t a\n\u2028 a\n\u2029 a\n\u001b a\na", '"""\n  a\n  \\\\ a\n  \\0 a\n  \\b a\n  \\f a\n  \\r a\n  \\v a\n  \\t a\n  \\u2028 a\n  \\u2029 a\n  \\u001b a\n  a'); testFI('"hi"', '\'\"hi\"\''); testFI("'hi'", '"\'hi\'"'); testFI("hi", ":hi"); testFI((a) => 123, "a => 123", "function(a) { return 123; }"); testFI({a: 1}, "a: 1"); testFI(/hi/, "/hi/"); testFI({inspect: () => "myInspectOutput"}, /inspect.*myInspectOutput/); testFI([], "[]"); testFI(["string", {foo: "bar"}], "[] :string, foo: :bar"); testFI([{foo: "bar"}, "string"], "[]\n  foo: :bar\n  :string"); testFI([1], "[] 1"); testFI([1, 2], "[] 1, 2"); testFI([{a: 1}, 2], "[]\n  a: 1\n  2"); testFI({a: 1, b: [2, "a: 1, b: 2"]}); testFI({a: [1, 2], b: 3}, "a: [] 1, 2\nb: 3"); testFI([[1, 2], [3, 4]], "[]\n  [] 1, 2\n  [] 3, 4"); testFI({a: {a1: 1, a2: 2}, b: {b1: 1, b2: 2}}, "a: a1: 1, a2: 2\nb: b1: 1, b2: 2"); testFI({a: {a1: 1, a2: 2}, b: {b1Long: 1, b2: 2}}, "a: a1:     1, a2: 2\nb: b1Long: 1, b2: 2"); testFI([{a: 1}, {b: 2}], "[]\n  {} a: 1\n  {} b: 2"); testFI({"has:": 1}, '"has:": 1'); testFI(Foo, `class ${Caf.toString(Foo.namespacePath)}`); return testFI(new Foo, `<${Caf.toString(Foo.namespacePath)}>`);}, unsupportedObjects: function() {test("my Foo class - one property", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {constructor() {super(...arguments); this.bar = 123;};}, function(Foo, classSuper, instanceSuper) {this.prototype.ignoreMe = function() {};}); assert.eq(formattedInspect({bar: 123}), "bar: 123"); return assert.eq(formattedInspect(new Foo), "Foo {} bar: 123");}); test("my Foo class - multiple property", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {constructor() {super(...arguments); this.bar = this.baz = this.bom = "This is just fine, right? Just a little longer.";};}, function(Foo, classSuper, instanceSuper) {this.prototype.ignoreMe = function() {};}); assert.eq(formattedInspect({bar: 123}, {maxLineLength: 80}), "bar: 123"); return assert.eq(formattedInspect(new Foo, {maxLineLength: 80}), 'Foo {}\n  bom: "This is just fine, right? Just a little longer."\n  baz: "This is just fine, right? Just a little longer."\n  bar: "This is just fine, right? Just a little longer."');}); test("my Foo class - with nesting 1", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {constructor() {super(...arguments); this.bom = {boo: "bar"};};}); return assert.eq(formattedInspect(new Foo, {maxLineLength: 80}), "Foo {} bom: boo: :bar");}); test("my Foo class - with nesting 2", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {constructor() {super(...arguments); this.bom = {boo: "bar"}; this.bat = {bow: "bay"};};}); return assert.eq(formattedInspect(new Foo, {maxLineLength: 80}), "Foo {}\n  bom: boo: :bar\n  bat: bow: :bay");}); test("my Foo class - with nesting 3", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {constructor() {super(...arguments); this.justOne = {boo: "bar", bow: "bay"};};}); return assert.eq(formattedInspect(new Foo, {maxLineLength: 20}), "Foo {} justOne:\n  boo: :bar\n  bow: :bay\n");}); return test("my Foo class - with nesting 4", () => {let Foo; Foo = Caf.defClass(class Foo extends Object {constructor() {super(...arguments); this.bom = {boo: "bar", bow: "bay"}; this.bom2 = {boo: "bar", bow: "bay"};};}); return assert.eq(formattedInspect(new Foo, {maxLineLength: 20}), "Foo {}\n  bom:\n    boo: :bar\n    bow: :bay\n\n  bom2:\n    boo: :bar\n    bow: :bay\n");});}, stackedSinglePropObjects: function() {test("simple", () => assert.eq(formattedInspect({a: {b: {c: {c1: 1, c2: 2}, d: 3}}}), "a: b:\n  c: c1: 1, c2: 2\n  d: 3\n")); test("withArray", () => assert.eq(formattedInspect({a: {b: {c: [1, 2, 3, 4]}}}, {maxLineLength: 10}), "a: b: c: []\n  1\n  2\n  3\n  4\n")); test("more", () => assert.eq(formattedInspect({a: {b: {b1: {b11: 11, b12: {b121: 121, b122: 122}}, b2: {b21: 21, b22: 22}}}}), "a: b:\n  b1: b11: 11, b12: b121: 121, b122: 122\n  b2: b21: 21, b22: 22\n")); return test("too many", () => assert.eq(formattedInspect({a: {b: {c: {d: {e: {f: {g: {h: {i: {j: {k: {l: {m: {n: {o: 0}}}}}}}}}}}}}}}, {maxLineLength: 10}), "a: b: c: d: e: f: g: h: i: j: k: l: m: n: o:\n  0\n", "Really, this should look more like this:\na: b: c: d: e:\n  f: g: h: i:\n    j: k: l:\n      m: n: o:\n        0\n\n(due to maxLineLength: 10)\nBut that would require a larger refactor"));}, recursion: function() {test("self-reference", () => {let selfR; selfR = {}; selfR.self = selfR; return assert.eq(formattedInspect(selfR), "self: <<< self reference");}); test("parent-reference", () => {let backR; backR = {child: {}}; backR.child.parent = backR; return assert.eq(formattedInspect(backR), "child: parent: <<< parent reference");}); test("grandparent-reference", () => {let backR; backR = {child: {grandchild: {}}}; backR.child.grandchild.grandparent = backR; return assert.eq(formattedInspect(backR, {maxLineLength: 1000}), "child: grandchild: grandparent: <<< grandparent reference");}); test("grandparent-reference", () => {let backR; backR = {child: {grandchild: {greatgrandchild: {}}}}; backR.child.grandchild.greatgrandchild.greatgrandparent = backR; return assert.eq(formattedInspect(backR, {maxLineLength: 1000}), "child: grandchild: greatgrandchild: greatgrandparent: <<< great grandparent reference");}); return test("grandparent-reference", () => {let backR; backR = {child: {grandchild: {greatgrandchild: {greatgreatgrandchild: {}}}}}; backR.child.grandchild.greatgrandchild.greatgreatgrandchild.greatgreatgrandparent = backR; return assert.eq(formattedInspect(backR, {maxLineLength: 1000}), "child: grandchild: greatgrandchild: greatgreatgrandchild: greatgreatgrandparent: <<< 4 generations back reference");});}, strings: {multiLine: function() {return testFormattedInspectString({"\n": '"\\n"', "\na": '"\\na"', "a\n": '"a\\n"', "\na\n": '"\\na\\n"', "a\nb": '"""\n  a\n  b'});}, multiLineStartingWhitespace: function() {return testFormattedInspectString({"\na\nb": '"""\n  \\na\n  b', " a\nb": '"""\n  \\sa\n  b'});}, multiLineTrailingWhitespace: function() {return testFormattedInspectString({"a\nb\n": '"""\n  a\n  b\\n', "a\nb ": '"""\n  a\n  b\\s', "a \nb": '"""\n  a\\s\n  b'});}}, alignTabs: function() {testAlignTabs("alice\t1\nbill\t2", "alice 1\nbill  2"); testAlignTabs('Neptune:\n  version:"1.10.2"\n  Neptune.CaffeineMc:\n    Neptune.CaffeineMc.Compilers:modules:\t"JavaScript"\n    modules:\t"CafRepl, CaffeineMcParser, FileCompiler, Metacompiler, ModuleResolver, SourceRoots"', 'Neptune:\n  version:"1.10.2"\n  Neptune.CaffeineMc:\n    Neptune.CaffeineMc.Compilers:modules: "JavaScript"\n    modules:                              "CafRepl, CaffeineMcParser, FileCompiler, Metacompiler, ModuleResolver, SourceRoots"'); return testAlignTabs('Neptune:\n  version:"1.10.2"\n  Neptune.CaffeineMc:\n    Neptune.CaffeineMc.Compilers:modules:\t"JavaScript"\n    modules:\t"CafRepl, CaffeineMcParser, FileCompiler, Metacompiler, ModuleResolver, SourceRoots"\n\n  Neptune.Art:\n    Neptune.Art.ClassSystem:modules:\t"BaseClass, BaseObject, WebpackHotLoader"\n    Neptune.Art.StandardLib:\n      Neptune.Art.StandardLib.Core:modules:\t"ArrayCompactFlatten, Merge, StringCase, Types"\n      Neptune.Art.StandardLib.Inspect:\n        Neptune.Art.StandardLib.Inspect.Inspected:modules:\t"Array, Core, Object, String"\n        modules:\t"FormattedInspect, InspectedObjectLiteral, InspectedObjects, Inspector, Inspector2, PlainObjects"\n\n      modules:\t"ArrayExtensions, AsyncExtensions, CallStack, Clone, CommonJs, Eq, ErrorWithInfo, Function, Iteration, Log, Map, MathExtensions, MinimalBaseObject, ObjectDiff, ObjectExtensions, ParseUrl, Promise, PromisedFileReader, Regexp, Ruby, ShallowClone, StringExtensions, Time, TypesExtended, Unique"\n\n    Neptune.Art.ObjectTreeFactory:{}\n\n  Neptune.BabelBridge:', 'Neptune:\n  version:"1.10.2"\n  Neptune.CaffeineMc:\n    Neptune.CaffeineMc.Compilers:modules:                  "JavaScript"\n    modules:                                               "CafRepl, CaffeineMcParser, FileCompiler, Metacompiler, ModuleResolver, SourceRoots"\n\n  Neptune.Art:\n    Neptune.Art.ClassSystem:modules:                       "BaseClass, BaseObject, WebpackHotLoader"\n    Neptune.Art.StandardLib:\n      Neptune.Art.StandardLib.Core:modules:                "ArrayCompactFlatten, Merge, StringCase, Types"\n      Neptune.Art.StandardLib.Inspect:\n        Neptune.Art.StandardLib.Inspect.Inspected:modules: "Array, Core, Object, String"\n        modules: "FormattedInspect, InspectedObjectLiteral, InspectedObjects, Inspector, Inspector2, PlainObjects"\n\n      modules: "ArrayExtensions, AsyncExtensions, CallStack, Clone, CommonJs, Eq, ErrorWithInfo, Function, Iteration, Log, Map, MathExtensions, MinimalBaseObject, ObjectDiff, ObjectExtensions, ParseUrl, Promise, PromisedFileReader, Regexp, Ruby, ShallowClone, StringExtensions, Time, TypesExtended, Unique"\n\n    Neptune.Art.ObjectTreeFactory:{}\n\n  Neptune.BabelBridge:', 150);}, alignTabsColor: function() {testAlignTabs("a:\t1,\tb:\t2", "a: 1, b: 2"); return testAlignTabs("\u001b[34ma:\u001b[39m\t\u001b[33m1\u001b[39m,\t\u001b[34mb:\u001b[39m\t\u001b[33m2\u001b[39m", "\u001b[34ma:\u001b[39m \u001b[33m1\u001b[39m, \u001b[34mb:\u001b[39m \u001b[33m2\u001b[39m");}, maxLineLength: {simpleArray: function() {testFIMultiLine([1, 2], "[]\n  1\n  2", ("[] 1, 2").length - 1); return testFIMultiLine([1, 2], "[] 1, 2", ("[] 1, 2").length);}, objectArray: function() {testFIMultiLine({a: [1, 2]}, "a: [] 1, 2", ("a: [] 1, 2").length); testFIMultiLine({a: [1, 2]}, "a:\n  [] 1, 2", ("a: [] 1, 2").length - 1); return testFIMultiLine({a: [1, 2]}, "a: []\n  1\n  2", 5);}, arrayObject: function() {testFIMultiLine([{ab: 1}], "[] ab: 1", ("[] ab: 1").length); testFIMultiLine([{ab: 1}], "[]\n  ab: 1", ("[] ab: 1").length - 1); return testFIMultiLine([{ab: 1}], "[]\n  ab:\n    1", 4);}, tabs: function() {testFIMultiLine({userA: {name: "John Groovy Handcock", address: "home"}, userB: {name: "Amy Mae", address: "home on the range"}}, 'userA: name: "John Groovy Handcock", address: :home\nuserB: name: "Amy Mae",              address: "home on the range"', 65); testFIMultiLine({userA: {name: "John Groovy Handcock", address: "home"}, userB: {name: "Amy Mae", address: "home on the range"}}, 'userA: name: "John Groovy Handcock", address: :home\nuserB: name: "Amy Mae", address: "home on the range"', 64); testFIMultiLine({a: 1, what: 4}, "a:    1\nwhat: 4", 10); return testFIMultiLine({a: {b: 1}, what: {abc: 4}}, "a:    b:   1\nwhat: abc: 4", 100);}}, multiLine: {array: function() {testFIMultiLine([1, 2], "[]\n  1\n  2"); return testFIMultiLine([[1, 2], [3, 4]], "[]\n  [] 1, 2\n  [] 3, 4", 1000);}, object: function() {testFIMultiLine({a: 1, b: 2}, "a:\n  1\n\nb:\n  2"); return testFIMultiLine({a: {a1: 1, a2: 2}, b: {b1: 1, b2: 2}}, "a:\n  a1: 1\n  a2: 2\n\nb:\n  b1: 1\n  b2: 2", 10);}, objectArrays: function() {return testFIMultiLine({a: [1, 2], b: [3, 4]}, "a: []\n  1\n  2\n\nb: []\n  3\n  4");}, objectArraysObjects: function() {return testFIMultiLine({a: [{a1: 1}, {a2: 2}], b: [{b3: 3}, {b4: 4}]}, "a: []\n  {} a1: 1\n  {} a2: 2\n\nb: []\n  {} b3: 3\n  {} b4: 4", 10);}, arrayObjects: function() {return testFIMultiLine([{a1: 1, a2: 2}, {b1: 1, b2: 2}], "[]\n  {}\n    a1: 1\n    a2: 2\n\n  {}\n    b1: 1\n    b2: 2", 10);}, arrayObjectsArrays: function() {testFIMultiLine([{a1: [1, 1], a2: [1, 2]}, {b1: [2, 1], b2: [2, 2]}], "[]\n  {}\n    a1: []\n      1\n      1\n\n    a2: []\n      1\n      2\n\n  {}\n    b1: []\n      2\n      1\n\n    b2: []\n      2\n      2"); return testFIMultiLine([{a1: [1, 1], a2: [1, 2]}, {b1: [2, 1], b2: [2, 2]}], "[]\n  {}\n    a1: [] 1, 1\n    a2: [] 1, 2\n\n  {}\n    b1: [] 2, 1\n    b2: [] 2, 2", 1000);}, mixed: function() {testFIMultiLine(["string", {foo: "bar"}], "[]\n  :string\n  foo: :bar", 12); testFIMultiLine([inspectedObjectLiteral("myInspectedObjectLiteral"), {foo: "bar"}], "[]\n  myInspectedObjectLiteral\n  foo: :bar", 12); testFIMultiLine({a: [1, 2], b: 2}, "a: []\n  1\n  2\n\nb: 2", 5); testFIMultiLine({getInspectedObjects: () => ["A", {foo: "B", bar: "C"}]}, "[]\n  :A\n  foo: :B\n  bar: :C", 11); return testFIMultiLine([{foo: "A", bar: "B"}, "C", {fad: "D", baz: "E"}], "[]\n  foo: :A\n  bar: :B\n\n  :C\n  fad: :D\n  baz: :E", 11);}}, wordStrings: function() {return testFIMultiLine(["abc"], "[]\n  :abc");}, regressions: function() {testFIMultiLine({a: [1, 2], b: 3}, "a: []\n  1\n  2\n\nb:\n  3"); testFIMultiLine([{}, {}], "[]\n  {}\n  {}"); return testFIMultiLine({Neptune: {version: "1.10.2", "Neptune.CaffeineMc": {"Neptune.CaffeineMc.Compilers": {modules: "JavaScript"}, modules: "CafRepl, CaffeineMcParser, FileCompiler, Metacompiler, ModuleResolver, SourceRoots"}, "Neptune.Art": {"Neptune.Art.ClassSystem": {modules: "BaseClass, BaseObject, WebpackHotLoader"}, "Neptune.Art.StandardLib": {"Neptune.Art.StandardLib.Core": {modules: "ArrayCompactFlatten, Merge, StringCase, Types"}, "Neptune.Art.StandardLib.Inspect": {"Neptune.Art.StandardLib.Inspect.Inspected": {modules: "Array, Core, Object, String"}, modules: "FormattedInspect, InspectedObjectLiteral, InspectedObjects, Inspector, Inspector2, PlainObjects"}, modules: "ArrayExtensions, AsyncExtensions, CallStack, Clone, CommonJs, Eq, ErrorWithInfo, Function, Iteration, Log, Map, MathExtensions, MinimalBaseObject, ObjectDiff, ObjectExtensions, ParseUrl, Promise, PromisedFileReader, Regexp, Ruby, ShallowClone, StringExtensions, Time, TypesExtended, Unique"}, "Neptune.Art.ObjectTreeFactory": {}}}}, 'Neptune:\n  version: :1.10.2\n  Neptune.CaffeineMc:\n    Neptune.CaffeineMc.Compilers: modules: :JavaScript\n    modules:                      "CafRepl, CaffeineMcParser, FileCompiler, Metacompiler, ModuleResolver, SourceRoots"\n\n  Neptune.Art:\n    Neptune.Art.ClassSystem: modules: "BaseClass, BaseObject, WebpackHotLoader"\n    Neptune.Art.StandardLib:\n      Neptune.Art.StandardLib.Core: modules: "ArrayCompactFlatten, Merge, StringCase, Types"\n      Neptune.Art.StandardLib.Inspect:\n        Neptune.Art.StandardLib.Inspect.Inspected: modules: "Array, Core, Object, String"\n        modules:                                   "FormattedInspect, InspectedObjectLiteral, InspectedObjects, Inspector, Inspector2, PlainObjects"\n\n      modules:\n        "ArrayExtensions, AsyncExtensions, CallStack, Clone, CommonJs, Eq, ErrorWithInfo, Function, Iteration, Log, Map, MathExtensions, MinimalBaseObject, ObjectDiff, ObjectExtensions, ParseUrl, Promise, PromisedFileReader, Regexp, Ruby, ShallowClone, StringExtensions, Time, TypesExtended, Unique"\n\n    Neptune.Art.ObjectTreeFactory: {}', 150);}, regressionsInfiniteLoop: function() {return test("infinite loop", () => {let out; out = formattedInspect({data: '{"mappings":{"post_search":{"_parent":{"type":"topic"},"properties":{"topicId":{"type":"keyword"},"userId":{"type":"keyword"},"postOrder":{"type":"long"},"createdAt":{"type":"long"},"updatedAt":{"type":"long"},"isChapterStart":{"type":"boolean"},"caption":{"type":"text","analyzer":"english"},"tags":{"type":"text"},"mentions":{"type":"text"},"mediaMimeType":{"type":"keyword"},"mediaAspectRatio":{"type":"short"},"mediaUrl":{"type":"keyword","index":false},"mediaFocus":{"type":"object","index":false},"mediaDimensions":{"type":"object","index":false},"mediaColorInfo":{"type":"object","index":false},"templateUrl":{"type":"keyword","index":false},"templateType":{"type":"keyword"},"templateDropInCount":{"type":"byte"},"templateText":{"type":"text","analyzer":"english"},"templateDropInLocations":{"type":"nested","index":false},"templateUses":{"type":"integer"},"activityCount":{"type":"integer"},"lastActivityAt":{"type":"long"},"messageCount":{"type":"integer","index":false},"participantCount":{"type":"integer","index":false},"lastActiveUserId":{"type":"keyword","index":false},"lastMessageId":{"type":"keyword","index":false}}},"topic_search":{"_parent":{"type":"user"},"properties":{"title":{"type":"text","analyzer":"english"},"createdAt":{"type":"long"},"updatedAt":{"type":"long"},"lastPostCreatedAt":{"type":"long"},"lastPostId":{"type":"keyword"},"lastChapterPostId":{"type":"keyword"},"postCount":{"type":"integer"},"followerCount":{"type":"integer"},"activityCount":{"type":"long"},"messageCount":{"type":"long"},"isProfileTopic":{"type":"boolean"}}},"user_search":{"properties":{"displayName":{"type":"text","analyzer":"english"},"postCount":{"type":"integer"},"topicCount":{"type":"short"},"followerCount":{"type":"integer"},"messageCount":{"type":"integer"},"lastTopicCreatedAt":{"type":"long"},"lastPostCreatedAt":{"type":"long"},"profileTopicId":{"type":"keyword","index":false}}}},"settings":{}}'}); return assert.eq(out, 'data:\n  \'{\"mappings\":{\"post_search\":{\"_parent\":{\"type\":\"topic\"},\"properties\":{\"topicId\":{\"type\":\"keyword\"},\"userId\":{\"type\":\"keyword\"},\"postOrder\":{\"type\":\"long\"},\"createdAt\":{\"type\":\"long\"},\"updatedAt\":{\"type\":\"long\"},\"isChapterStart\":{\"type\":\"boolean\"},\"caption\":{\"type\":\"text\",\"analyzer\":\"english\"},\"tags\":{\"type\":\"text\"},\"mentions\":{\"type\":\"text\"},\"mediaMimeType\":{\"type\":\"keyword\"},\"mediaAspectRatio\":{\"type\":\"short\"},\"mediaUrl\":{\"type\":\"keyword\",\"index\":false},\"mediaFocus\":{\"type\":\"object\",\"index\":false},\"mediaDimensions\":{\"type\":\"object\",\"index\":false},\"mediaColorInfo\":{\"type\":\"object\",\"index\":false},\"templateUrl\":{\"type\":\"keyword\",\"index\":false},\"templateType\":{\"type\":\"keyword\"},\"templateDropInCount\":{\"type\":\"byte\"},\"templateText\":{\"type\":\"text\",\"analyzer\":\"english\"},\"templateDropInLocations\":{\"type\":\"nested\",\"index\":false},\"templateUses\":{\"type\":\"integer\"},\"activityCount\":{\"type\":\"integer\"},\"lastActivityAt\":{\"type\":\"long\"},\"messageCount\":{\"type\":\"integer\",\"index\":false},\"participantCount\":{\"type\":\"integer\",\"index\":false},\"lastActiveUserId\":{\"type\":\"keyword\",\"index\":false},\"lastMessageId\":{\"type\":\"keyword\",\"index\":false}}},\"topic_search\":{\"_parent\":{\"type\":\"user\"},\"properties\":{\"title\":{\"type\":\"text\",\"analyzer\":\"english\"},\"createdAt\":{\"type\":\"long\"},\"updatedAt\":{\"type\":\"long\"},\"lastPostCreatedAt\":{\"type\":\"long\"},\"lastPostId\":{\"type\":\"keyword\"},\"lastChapterPostId\":{\"type\":\"keyword\"},\"postCount\":{\"type\":\"integer\"},\"followerCount\":{\"type\":\"integer\"},\"activityCount\":{\"type\":\"long\"},\"messageCount\":{\"type\":\"long\"},\"isProfileTopic\":{\"type\":\"boolean\"}}},\"user_search\":{\"properties\":{\"displayName\":{\"type\":\"text\",\"analyzer\":\"english\"},\"postCount\":{\"type\":\"integer\"},\"topicCount\":{\"type\":\"short\"},\"followerCount\":{\"type\":\"integer\"},\"messageCount\":{\"type\":\"integer\"},\"lastTopicCreatedAt\":{\"type\":\"long\"},\"lastPostCreatedAt\":{\"type\":\"long\"},\"profileTopicId\":{\"type\":\"keyword\",\"index\":false}}}},\"settings\":{}}\'\n');});}});});});
//# sourceMappingURL=FormattedInspect.test.js.map
