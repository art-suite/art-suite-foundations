"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "assert", "vivifyObjectPath", "vivifyObjectPathAndSet", "objectWithout", "toObject", "objectKeyCount", "select", "setPathedProperty", "withPathedPropertiesExpanded"], [global, require('./StandardImport')], (describe, test, assert, vivifyObjectPath, vivifyObjectPathAndSet, objectWithout, toObject, objectKeyCount, select, setPathedProperty, withPathedPropertiesExpanded) => {return describe({vivifyObjectPath: function() {test("vivifyObjectPath {}", () => assert.eq({}, vivifyObjectPath({}))); test("vivifyObjectPath {}, 'a'", () => {let input; assert.eq({}, vivifyObjectPath(input = {}, "a")); return assert.eq(input, {a: {}});}); test("vivifyObjectPath null, 'a', 'b'", () => {let input; assert.eq({}, vivifyObjectPath(input = {}, "a", "b")); return assert.eq(input, {a: {b: {}}});}); test("vivifyObjectPath {c: 123}, 'a', 'b'", () => {let input; assert.eq({}, vivifyObjectPath(input = {c: 123}, "a", "b")); return assert.eq(input, {a: {b: {}}, c: 123});}); return test("vivifyObjectPath {a: c: 123}, 'a', 'b'", () => {let input, origA; assert.eq({}, vivifyObjectPath(input = {a: origA = {c: 123}}, "a", "b")); assert.eq(input, {a: {b: {}, c: 123}}); return assert.equal(input.a, origA);});}, vivifyObjectPathAndSet: function() {test("vivifyObjectPathAndSet {}, 'a', 'b'", () => {let input; assert.eq("b", vivifyObjectPathAndSet(input = {}, "a", "b")); return assert.eq(input, {a: "b"});}); test("vivifyObjectPathAndSet {}, 'a', 'b', 'c'", () => {let input; assert.eq("c", vivifyObjectPathAndSet(input = {}, "a", "b", "c")); return assert.eq(input, {a: {b: "c"}});}); test("vivifyObjectPathAndSet {c: 123}, 'a', 'b'", () => {let input; assert.eq("b", vivifyObjectPathAndSet(input = {c: 123}, "a", "b")); return assert.eq(input, {a: "b", c: 123});}); return test("vivifyObjectPathAndSet {a: c: 123}, 'a', 'b'", () => {let input, origA; assert.eq("b", vivifyObjectPathAndSet(input = {a: origA = {c: 123}}, "a", "b")); return assert.eq(input, {a: "b"});});}, objectWithout: function() {test("objectWithout", () => {let a, b; a = {foo: 1, bar: 2, fooz: 3, baz: 4}; b = objectWithout(a, "bar", "baz"); return assert.eq(b, {foo: 1, fooz: 3});}); return test("objectWithout with nothing to do returns original object", () => {let a, b; a = {foo: 1, bar: 2, fooz: 3, baz: 4}; b = objectWithout(a, "cat", "frog"); return assert.eq(true, a === b);});}, toObject: function() {test("simple key-value", () => assert.eq({123: "foo"}, toObject(123, "foo"))); test("two key-values", () => assert.eq({123: "foo", 456: "bar"}, toObject(123, "foo", 456, "bar"))); test("missing value for key becomes undefined", () => assert.eq({foo: undefined}, toObject("foo"))); test("null values", () => assert.eq({1: null, 2: false, 3: undefined, 4: 0, 456: "foo"}, toObject(1, null, 2, false, 3, undefined, 4, 0, null, undefined, 456, "foo"))); test("objects in the list get merged in", () => assert.eq({foo: 1, bar: 2, bob: 3, 123: "foo"}, toObject({foo: 1, bar: 2}, [123, "foo"], {bob: 3}))); test("array of pairs", () => assert.eq({foo: 1, bar: 2, baz: 3, bat: 4}, toObject([["baz", 3], ["foo", 1], ["bat", 4], ["bar", 2]]))); test("last value for same key sticks", () => assert.eq({foo: 1, bar: 2, baz: 3, bat: 5}, toObject([["baz", 3], ["foo", 1], ["bat", 4], ["bat", 5], ["bar", 2]]))); test("compactFlatten IN DA HOUSE", () => assert.eq({foo: 1, bar: 2, baz: 3, bat: 4}, toObject([null, ["baz", 3], [["foo", 1], ["bat", 4]], undefined, [[["bar", 2]]]]))); test("toObject 'myKey', x: 1, y: 2", () => assert.eq({myKey: {x: 1, y: 2}}, toObject("myKey", {x: 1, y: 2}))); return test("toObject 'myKey', [1, 2]", () => assert.eq({myKey: [1, 2]}, toObject("myKey", [1, 2])));}, objectKeyCount: function() {test("objectKeyCount {}", () => assert.eq(0, objectKeyCount({}))); test("objectKeyCount a:1", () => assert.eq(1, objectKeyCount({a: 1}))); return test("objectKeyCount a:1, b:2", () => assert.eq(2, objectKeyCount({a: 1, b: 2})));}, select: function() {test("select()", () => assert.eq(select(), {})); test("select (foo: 0), 'foo'", () => assert.eq(select({foo: 0}, "foo"), {foo: 0})); test("select (foo: 1, bar: 2), 'foo'", () => assert.eq({foo: 1}, select({foo: 1, bar: 2}, "foo"))); test("select bar: 2, 'foo'", () => assert.eq({}, select({bar: [2, "foo"]}))); test("select foo: 1, bar: 2, baz: 3, 'foo', 'bar'", () => assert.eq(select({foo: 1, bar: 2, baz: 3}, "foo", "bar"), {foo: 1, bar: 2})); test("select foo: 1, bar: 2, baz: 3, (k, v)->", () => assert.eq(select({foo: 1, bar: 2, baz: 3}, (v, k) => k.match(/^b/)), {baz: 3, bar: 2})); test("select foo: 1, bar: 2, baz: 3, (v)->", () => assert.eq(select({foo: 1, bar: 2, baz: 3}, (v) => v <= 2), {foo: 1, bar: 2})); return test("select foo: null, bar: false, baz: undefined, -> true", () => assert.eq(select({foo: null, bar: false, baz: undefined}, () => true), {foo: null, bar: false, baz: undefined}));}, pathedProperties: function() {test("setPathedProperty not really pathed", () => assert.eq({b: 123}, setPathedProperty({}, "b", 123))); test("setPathedProperty 'b.c'", () => assert.eq({b: {c: 123}}, setPathedProperty({}, "b.c", 123))); test("setPathedProperty 'b c'", () => assert.eq({b: {c: 123}}, setPathedProperty({}, "b c", 123))); test("setPathedProperty 'b/c'", () => assert.eq({b: {c: 123}}, setPathedProperty({}, "b/c", 123))); test("setPathedProperty two overlapping paths", () => assert.eq({b: {c: 123, d: 456}}, setPathedProperty({b: {c: 123}}, "b.d", 456))); return test("setPathedProperty two non-overlapping paths", () => assert.eq({b: {c: 123}, d: {c: 456}}, setPathedProperty({b: {c: 123}}, "d.c", 456)));}, withPathedPropertiesExpanded: function() {test("a: 1", () => assert.eq({a: 1}, withPathedPropertiesExpanded({a: 1}))); test("a.b: 1", () => assert.eq(withPathedPropertiesExpanded({"a.b": 1}), {a: {b: 1}})); test("a: b.c: 1", () => assert.eq(withPathedPropertiesExpanded({a: {"b.c": 1}}), {a: {b: {c: 1}}})); test("a.b.c: 1", () => assert.eq(withPathedPropertiesExpanded({"a.b.c": 1}), {a: {b: {c: 1}}})); test("a.b: c.d: 1", () => assert.eq(withPathedPropertiesExpanded({"a.b": {"c.d": 1}}), {a: {b: {c: {d: 1}}}})); return test("realworld", () => assert.eq(withPathedPropertiesExpanded({verbose: true, "Art.Foo.Auth.Server": {testAuthEmail: "special@imikimi.com", testAuthCode: "107734"}}), {verbose: true, Art: {Foo: {Auth: {Server: {testAuthEmail: "special@imikimi.com", testAuthCode: "107734"}}}}}));}});});});
//# sourceMappingURL=ObjectExtensions.test.js.map
