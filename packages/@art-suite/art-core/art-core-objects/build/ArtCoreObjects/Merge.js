// Generated by CoffeeScript 1.12.7
(function() {
  var Merge, compactFlatten, isPlainObject,
    slice = [].slice;

  compactFlatten = require("@art-suite/art-core-arrays").compactFlatten;

  isPlainObject = require("@art-suite/art-core-types").isPlainObject;

  module.exports = Merge = (function() {
    var _deepMerge, deepMerge, merge, mergeInto, mergeIntoWithNullDeletes, pureMerge;

    function Merge() {}


    /*
    
    merge "flattens" its args and then adds all keys from all objects in
    the list into a new object which is returned.
    
    return: new object
    
    The first object's keys are added first. If two or more objects have the same
    keys, the value set in the result is the last object's in the list with that key.
     */

    Merge.merge = merge = function() {
      var all;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return mergeInto({}, all);
    };

    Merge.mergeWithoutNulls = function() {
      var all;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return mergeIntoWithNullDeletes({}, all);
    };

    Merge.mergeWith = function() {
      var all;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return mergeInto({}, this, all);
    };

    Merge.mergeWithSelf = Merge.mergeWith;


    /*
    The same as 'merge' with one difference:
    
    Instead of a new object, all objects are merged into the first object in the list.
    
    return: first object in the flattened list
    return: null if no source objects
     */

    Merge.mergeInto = mergeInto = function() {
      var all, j, k, len, result, source, sources, v;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      result = sources[0] || {};
      for (j = 0, len = sources.length; j < len; j++) {
        source = sources[j];
        if (source !== result) {
          for (k in source) {
            v = source[k];
            if (v !== void 0) {
              result[k] = v;
            }
          }
        }
      }
      return result;
    };

    Merge.mergeIntoWithNullDeletes = mergeIntoWithNullDeletes = function() {
      var all, j, k, len, result, source, sources, v;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      result = sources[0] || {};
      for (j = 0, len = sources.length; j < len; j++) {
        source = sources[j];
        if (source !== result) {
          for (k in source) {
            v = source[k];
            switch (false) {
              case v == null:
                result[k] = v;
                break;
              case v !== null:
                delete result[k];
            }
          }
        }
      }
      return result;
    };


    /*
    Just like mergeInfo except only merge into the result object
    UNLESS 'result' already has that property with a non-undefined value.
    
    if
      mergeInfo a, b is just like merge a, b except it modifies and returns a instead of returning a new object
    then
      mergeIntoUnless b, a is just like merge a, b except it modifies and returns b instead of returning a new object
    
    Note: mergeIntoUnless a, b, c, d, e, f is like merge f, e, d, c, b, a
     */

    Merge.mergeIntoUnless = function() {
      var all, i, j, k, ref, result, source, sources, v;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      result = sources[0] || {};
      for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
        source = sources[i];
        for (k in source) {
          v = source[k];
          if (result[k] === void 0) {
            result[k] = v;
          }
        }
      }
      return result;
    };

    Merge.deepMerge = deepMerge = function() {
      var all, array, k, out, ref, v, val;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      ref = out = merge(array = compactFlatten(all));
      for (k in ref) {
        v = ref[k];
        if (isPlainObject(v)) {
          out[k] = _deepMerge((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = array.length; j < len; j++) {
              val = array[j];
              results.push(val[k]);
            }
            return results;
          })());
        }
      }
      return out;
    };

    _deepMerge = function(array) {
      var k, out, ref, v, val;
      ref = out = merge(array = compactFlatten(array));
      for (k in ref) {
        v = ref[k];
        if (isPlainObject(v)) {
          out[k] = _deepMerge((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = array.length; j < len; j++) {
              val = array[j];
              results.push(val[k]);
            }
            return results;
          })());
        }
      }
      return out;
    };

    Merge.hasAllProps = function(o1, o2) {
      var k, v;
      for (k in o1) {
        v = o1[k];
        if (!o2.hasOwnProperty(k)) {
          return false;
        }
      }
      return true;
    };

    Merge.pureMerge = pureMerge = function() {
      var all, j, last, len, source, sources;
      all = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      sources = compactFlatten(all);
      if (sources.length === 0) {
        return null;
      }
      if (sources.length === 1) {
        return sources[0];
      }
      last = sources[sources.length - 1];
      for (j = 0, len = sources.length; j < len; j++) {
        source = sources[j];
        if (source !== last) {
          if (!Merge.hasAllProps(source, last)) {
            return Merge.merge(sources);
          }
        }
      }
      return last;
    };

    return Merge;

  })();

}).call(this);

//# sourceMappingURL=Merge.js.map
