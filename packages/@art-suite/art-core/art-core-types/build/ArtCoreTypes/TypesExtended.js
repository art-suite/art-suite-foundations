// Generated by CoffeeScript 1.12.7
(function() {
  var Core, Types, isFunction, isJsonAtomicType, isObject, isPlainArray, isPlainObject, isString, mergeInto, ref;

  ref = Core = require('./Types'), isPlainObject = ref.isPlainObject, mergeInto = ref.mergeInto, isString = ref.isString, isFunction = ref.isFunction, isObject = ref.isObject, isPlainArray = ref.isPlainArray, isJsonAtomicType = ref.isJsonAtomicType;

  module.exports = Types = (function() {
    var functionName, objectName, stringIsPresent, tEq, throwInequalityError;

    function Types() {}

    throwInequalityError = function(a, b) {
      throw new Error("Value types are not compatible for inequality tests. a: " + (a != null ? a.constructor.name : void 0) + ", b: " + (b != null ? b.constructor.name : void 0));
    };


    /*
     * simplified - as simple as I can make it
     * sacrifices some semantics
    gt = (a, b)->
      if (o = a > b) || a <= b
        return o
      a.gt b
    
     * just a tad more complex and only sacrifices clear errors
    gt = (a, b)->
      if typeof a == typeof b
        if (o = a > b) || a <= b
          return o
      a.gt b
     */

    tEq = function(a, b) {
      return typeof a === typeof b;
    };

    Types.gt = function(a, b) {
      var s;
      if ((a != null) && (b != null)) {
        s = tEq(a, b);
        return (s && a > b) || ((s && a <= b) ? false : a.gt(b));
      } else {
        return throwInequalityError(a, b);
      }
    };

    Types.lt = function(a, b) {
      var s;
      if ((a != null) && (b != null)) {
        s = tEq(a, b);
        return (s && a < b) || ((s && a >= b) ? false : a.lt(b));
      } else {
        return throwInequalityError(a, b);
      }
    };

    Types.gte = function(a, b) {
      var s;
      if ((a != null) && (b != null)) {
        s = tEq(a, b);
        return (s && a >= b) || ((s && a < b) ? false : a.gte(b));
      } else {
        return throwInequalityError(a, b);
      }
    };

    Types.lte = function(a, b) {
      var s;
      if ((a != null) && (b != null)) {
        s = tEq(a, b);
        return (s && a <= b) || ((s && a > b) ? false : a.lte(b));
      } else {
        return throwInequalityError(a, b);
      }
    };


    /*
    like RubyOnRails#present:
      "An object is present if it's not blank."
    
    basic:
      present null, undefined, false or "" returns false (or whatever returnIfNotPresent is set to)
      all other values return something truish - generally themselves
    
      Yes, in ruby/rails, present(false) == false. Though logically true, I've also found it lead
      to unexpected results in production code. I had a false-value where I was expecting a string due
      to a corrupted database value.
    
      Possible argment for present(false) == false: It's easy to accidentally return false when you
      meant to return null or undefined. I think this is how my database got the corrupted false-instead-of
      null-value.
    
      Another argument: present(x) should always be false if x is false.
    
    custom:
      for bar where isFunction bar.present
        present bar returns bar.present()
    
    special-case truish results:
      present 0 or false returns true
    
    for any other value foo,
      present foo returns foo
    
    IN:
      obj:
        object tested for presence
      returnIfNotPresent: [false]
        what to return if not present
    
    OUT:
      returnIfNotPresent, true, or the value passed in
    
    If 'obj' has method: obj.present() => obj.present()
     */

    Types.present = function(obj, returnIfNotPresent) {
      var present;
      if (returnIfNotPresent == null) {
        returnIfNotPresent = false;
      }
      present = isFunction(obj != null ? obj.getPresent : void 0) ? obj.getPresent() : isFunction(obj != null ? obj.present : void 0) ? obj.present() : isString(obj) ? stringIsPresent(obj) : obj !== void 0 && obj !== null && obj !== false;
      if (present) {
        return obj || true;
      } else {
        return returnIfNotPresent;
      }
    };

    Types.stringIsPresent = stringIsPresent = function(str) {
      return isString(str) && !/^(\s+|)$/.test(str);
    };

    Types.functionName = functionName = function(f) {
      var matched;
      return f.name || ((matched = ("" + f).match(/function ([a-zA-Z]+)\(/)) && matched[1]) || "function";
    };

    Types.objectName = objectName = function(obj) {
      var a, name, ref1;
      if (!obj) {
        return "" + obj;
      } else if (a = typeof obj.getNamespacePath === "function" ? obj.getNamespacePath() : void 0) {
        return a;
      } else if (a = obj.classPathName) {
        return a;
      } else if (obj.constructor === Object) {
        return "Object";
      } else if (isFunction(obj)) {
        return functionName(obj);
      } else if (isString(name = (ref1 = obj.constructor) != null ? ref1.name : void 0) && name.length > 0) {
        return name;
      } else if (obj instanceof Object) {
        return "(anonymous instanceof Object)";
      } else {
        return "(objectName unknown)";
      }
    };

    Types.isBrowserObject = function(obj) {
      var name;
      if (!Types.isObject(obj)) {
        return false;
      }
      name = Types.objectName(obj);
      return name.slice(0, 4) === "HTML" || name.slice(0, 22) === "CanvasRenderingContext";
    };

    return Types;

  })();

}).call(this);

//# sourceMappingURL=TypesExtended.js.map
