// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, ClassSystem, ProgressAdapter, Promise, StandardLib, isArray, isFunction, isNumber, log, max, min,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StandardLib = require('art-standard-lib');

  ClassSystem = require('art-class-system');

  BaseObject = ClassSystem.BaseObject;

  isNumber = StandardLib.isNumber, isFunction = StandardLib.isFunction, isArray = StandardLib.isArray, log = StandardLib.log, max = StandardLib.max, min = StandardLib.min, Promise = StandardLib.Promise;

  module.exports = ProgressAdapter = (function(superClass) {
    extend(ProgressAdapter, superClass);


    /*
    IN:
      stepWeights can be a positive integer or an aray of positive, real numbers.
    
        integer N: specifies progress will be made in N even steps from 0 to 1
    
        array of numbers A: specifies progress will be made in A.length steps which
          may not be even. Each step has its own "weight."
    
          Example: stepWeights = [850, 50, 100]
          Will become:
            steps:
              0: 0.00 to 0.85
              1: 0.85 to 0.90
              2: 0.90 to 1.00
    
          Example: stepWeights = [1, 2, 1]
          Will become:
            steps:
              0: 0.00 to 0.25
              1: 0.25 to 0.75
              2: 0.75 to 1.00
    
      progressCallback: progressCallback is a function which is invoked with a number
        between 0 and 1. It is invoked immediatly with 0, then it is invoked by makeProgress()
        and makeProgressCallback()(). It always increments or stays the same. It will
        never go backwards.
     */

    function ProgressAdapter(stepWeights, progressCallback1) {
      this.stepWeights = stepWeights;
      this.progressCallback = progressCallback1;
      if (!(isFunction(this.progressCallback) && (isArray(this.stepWeights) || isNumber(this.stepWeights)))) {
        throw new Error("invalid params");
      }
      this._currentStep = 0;
      this._generateSteps();
      this._currentProgress = 0;
      this._warningCount = 0;
      this.setCurrentProgress(0);
    }

    ProgressAdapter.getter("steps currentStep currentProgress warningCount", {
      currentProgressPercent: function() {
        return (this._currentProgress * 100 | 0) + "%";
      },
      currentProgressBase: function() {
        if (this._currentStep <= 0) {
          return 0;
        } else if (this._currentStep >= this._steps.length) {
          return 1;
        } else {
          return this._steps[this._currentStep];
        }
      }
    });

    ProgressAdapter.setter({
      currentProgress: function(p) {
        return typeof this.progressCallback === "function" ? this.progressCallback(min(1, this._currentProgress = max(p, this._currentProgress))) : void 0;
      }
    });

    ProgressAdapter.prototype.makeProgress = function() {
      this._currentStep++;
      if (this._currentStep > this._steps.length) {
        this._warningCount++;
        console.warn("ProgressAdapter: makeProgress/Callback called too many times!", {
          currentStep: this._currentStep,
          steps: this._steps,
          stepWeights: this.stepWeights
        });
      }
      return this.setCurrentProgress(this.currentProgressBase);
    };

    ProgressAdapter.prototype.makeProgressCallback = function() {
      var rangeEnd, rangeStart;
      this._finishLastProgress();
      rangeStart = this.currentProgressBase;
      this._currentStep++;
      rangeEnd = this.currentProgressBase;
      return (function(_this) {
        return function(progress) {
          return _this.setCurrentProgress(rangeStart + (rangeEnd - rangeStart) * progress);
        };
      })(this);
    };

    ProgressAdapter.prototype._finishLastProgress = function() {
      var progress;
      if (this._currentProgress < (progress = this.currentProgressBase)) {
        return this.setCurrentProgress(progress);
      }
    };

    ProgressAdapter.prototype._executePromiseSequence = function(sequence, lastResult, index, resolve) {
      if (index >= sequence.length) {
        this._finishLastProgress();
        return resolve(lastResult);
      }
      return Promise.resolve(sequence[index](lastResult, this.makeProgressCallback())).then((function(_this) {
        return function(nextResult) {
          return _this._executePromiseSequence(sequence, nextResult, index + 1, resolve);
        };
      })(this));
    };

    ProgressAdapter.prototype.executePromiseSequence = function(sequence) {
      return new Promise((function(_this) {
        return function(resolve) {
          return _this._executePromiseSequence(sequence, null, 0, resolve);
        };
      })(this));
    };


    /*
    IN: (progressCallback, promiseSequence) ->
       * stepWeights implicitly == promiseSequence.length
    IN: (progressCallback, stepWeights, promiseSequence) ->
     */

    ProgressAdapter.executePromiseSequence = function(progressCallback, a, b) {
      var pa, sequence, weights;
      if (b) {
        weights = a;
        sequence = b;
      } else {
        sequence = a;
        weights = sequence.length;
      }
      pa = new ProgressAdapter(weights, progressCallback);
      return pa.executePromiseSequence(sequence);
    };

    ProgressAdapter.prototype._generateSteps = function() {
      var i, j, len, numSteps, ref, s, step, total, w;
      if (isNumber(numSteps = this.stepWeights)) {
        return this._steps = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = numSteps; j < ref; i = j += 1) {
            results.push(i / numSteps);
          }
          return results;
        })();
      } else {
        total = 0;
        ref = this.stepWeights;
        for (j = 0, len = ref.length; j < len; j++) {
          w = ref[j];
          total += w;
        }
        step = 0;
        return this._steps = (function() {
          var k, len1, ref1, results;
          ref1 = this.stepWeights;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            w = ref1[k];
            s = step;
            step += w / total;
            results.push(s);
          }
          return results;
        }).call(this);
      }
    };

    return ProgressAdapter;

  })(BaseObject);

}).call(this);

//# sourceMappingURL=ProgressAdapter.js.map
