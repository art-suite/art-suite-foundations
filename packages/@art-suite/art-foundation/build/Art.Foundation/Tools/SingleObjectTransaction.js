// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, ClassSystem, SingleObjectTransaction, StandardLib, cloneStructure, eq, inspect, removeFirstMatch, rubyTrue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  StandardLib = require('art-standard-lib');

  ClassSystem = require('art-class-system');

  cloneStructure = StandardLib.cloneStructure, removeFirstMatch = StandardLib.removeFirstMatch, eq = StandardLib.eq, inspect = StandardLib.inspect, rubyTrue = StandardLib.rubyTrue;

  BaseObject = ClassSystem.BaseObject;

  module.exports = SingleObjectTransaction = (function(superClass) {
    var setValues;

    extend(SingleObjectTransaction, superClass);

    function SingleObjectTransaction(a) {
      var options;
      SingleObjectTransaction.__super__.constructor.apply(this, arguments);
      this.object = (function() {
        if (a.constructor === Array) {
          if (a.length !== 2) {
            throw new Error("new SingleObjectTransaction: expected length-2 array like: [obj, optionsMap]");
          }
          this.options = a[1];
          return a[0];
        } else {
          this.options = {};
          return a;
        }
      }).call(this);
      if (this.object == null) {
        throw new Error("object must not be null or undefined");
      }
      this.props = [];
      this.from = {};
      options = this.options;
      if (options.properties) {
        this.addProperties(options.properties);
      }
      if (options.property) {
        this.addProp(options.property);
      }
      if (options.from) {
        this.addFromValues(options.from);
      }
      if (options.to) {
        this.addToValues(options.to);
      }
    }

    SingleObjectTransaction.prototype.toString = function() {
      return (inspect(this.object, 0)) + " from:" + (inspect(this.from, 1)) + " to:" + (inspect(this.to, 1));
    };

    SingleObjectTransaction.prototype.inspect = function(inspector) {
      var i, k, len, ref, results;
      if (!inspector) {
        return ClassSystem.Inspect.inspect(this);
      }
      inspector.put(this.object.classPathName + ":");
      ref = this.props;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        k = ref[i];
        inspector.put("\n    " + k + ": ");
        if (rubyTrue(this.from && this.from[k])) {
          inspector.inspect(this.from[k], 1);
        }
        inspector.put(" ... ");
        if (rubyTrue(this.to && this.to[k])) {
          results.push(inspector.inspect(this.to[k], 1));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    SingleObjectTransaction.getter({
      properties: function() {
        return this.props;
      },
      hasToValues: function() {
        return !!this.to;
      },
      valuesChanged: function() {
        var fromValue, k, ref, toValue;
        ref = this.from;
        for (k in ref) {
          fromValue = ref[k];
          toValue = this.to[k];
          if (!eq(fromValue, toValue)) {
            return true;
          }
        }
        return false;
      }
    });

    SingleObjectTransaction.prototype.addFromValues = function(from) {
      var base, k, v;
      for (k in from) {
        v = from[k];
        this.addProp(k);
        this.from[k] = v;
      }
      return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.from) : void 0;
    };

    SingleObjectTransaction.prototype.addToValues = function(to) {
      var base, k, v;
      this.to || (this.to = {});
      for (k in to) {
        v = to[k];
        this.addProp(k);
        this.to[k] = v;
      }
      return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.to) : void 0;
    };

    SingleObjectTransaction.prototype.addProperties = function(props) {
      var i, len, prop, results, results1, v;
      if (props.constructor === Array) {
        results = [];
        for (i = 0, len = props.length; i < len; i++) {
          prop = props[i];
          results.push(this.addProp(prop));
        }
        return results;
      } else {
        results1 = [];
        for (prop in props) {
          v = props[prop];
          results1.push(this.addProp(prop));
        }
        return results1;
      }
    };

    SingleObjectTransaction.prototype.addProp = function(propName) {
      if (indexOf.call(this.props, propName) < 0) {
        return this.props.push(propName);
      }
    };

    SingleObjectTransaction.prototype.deleteProp = function(propName) {
      removeFirstMatch(this.props, propName);
      delete this.from[propName];
      return delete this.to[propName];
    };

    SingleObjectTransaction.prototype.saveValues = function(saveTo) {
      var getterName, i, len, metaProperties, prop, ref, ref1, value;
      this.clearOptimizations();
      metaProperties = this.object.metaProperties;
      ref = this.props;
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        if (!saveTo.hasOwnProperty(prop)) {
          value = saveTo[prop] = cloneStructure((getterName = metaProperties != null ? (ref1 = metaProperties[prop]) != null ? ref1.getterName : void 0 : void 0) ? this.object[getterName]() : this.object[prop]);
        }
      }
      return null;
    };

    SingleObjectTransaction.prototype.saveFromValues = function() {
      return this.saveValues(this.from || (this.from = {}));
    };

    SingleObjectTransaction.prototype.saveToValues = function() {
      return this.saveValues(this.to || (this.to = {}));
    };

    SingleObjectTransaction._setValues = setValues = function(o, values, f) {
      var metaProperties, prop, ref, setterName, v;
      metaProperties = o.metaProperties;
      for (prop in values) {
        v = values[prop];
        if (f) {
          v = f(prop, v);
        }
        if (setterName = metaProperties != null ? (ref = metaProperties[prop]) != null ? ref.setterName : void 0 : void 0) {
          o[setterName](v);
        } else {
          o[prop] = v;
        }
      }
      return null;
    };

    SingleObjectTransaction.prototype.rollBack = function() {
      return setValues(this.object, this.from);
    };

    SingleObjectTransaction.prototype.rollForward = function() {
      return setValues(this.object, this.to);
    };

    SingleObjectTransaction.prototype.clearOptimizations = function() {
      return this.numberDeltas = this.interpolateToObjects = null;
    };

    SingleObjectTransaction.prototype.optimizeInterpolation = function() {
      var field, from, ref, results, to;
      this.numberDeltas = {};
      this.interpolateToObjects = {};
      this.nonInterpolatingFields = {
        to: {},
        from: {}
      };
      ref = this.from;
      results = [];
      for (field in ref) {
        from = ref[field];
        to = this.to[field];
        if (typeof from === "number") {
          results.push(this.numberDeltas[field] = to - from);
        } else if (typeof (from != null ? from.interpolate : void 0) === "function") {
          results.push(this.interpolateToObjects[field] = to);
        } else {
          this.nonInterpolatingFields.from[field] = from;
          results.push(this.nonInterpolatingFields.to[field] = to);
        }
      }
      return results;
    };

    SingleObjectTransaction.prototype.interpolateNumberFields = function(p) {
      return setValues(this.object, this.numberDeltas, (function(_this) {
        return function(field, delta) {
          return _this.from[field] + delta * p;
        };
      })(this));
    };

    SingleObjectTransaction.prototype.interpolateObjectFields = function(p) {
      var e;
      try {
        return setValues(this.object, this.interpolateToObjects, (function(_this) {
          return function(field, toObject) {
            return _this.from[field].interpolate(toObject, p);
          };
        })(this));
      } catch (error) {
        e = error;
        this.log("Art.Foundation.Transaction#interpolateObjectFields(p=" + p + "): error " + e + " deltas: " + (inspect(this.interpolateToObjects)) + " from:   " + (inspect(this.from)) + " to:     " + (inspect(this.to)));
        throw e;
      }
    };

    SingleObjectTransaction.prototype.setNonInterpolatingFields = function(p) {
      return setValues(this.object, this.nonInterpolatingFields[p >= 1 ? "to" : "from"]);
    };

    SingleObjectTransaction.prototype.interpolate = function(p) {
      if (!this.numberDeltas) {
        this.optimizeInterpolation();
      }
      this.interpolateNumberFields(p);
      this.interpolateObjectFields(p);
      return this.setNonInterpolatingFields(p);
    };

    SingleObjectTransaction.getter({
      noChanges: function() {
        return this.props.length === 0;
      }
    });

    SingleObjectTransaction.prototype.optimizeProperties = function() {
      var i, len, prop, ref, results;
      this.clearOptimizations();
      ref = this.props;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        if (!this.from.hasOwnProperty(prop) || !this.to.hasOwnProperty(prop) || eq(this.from[prop], this.to[prop])) {
          results.push(this.deleteProp(prop));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return SingleObjectTransaction;

  })(BaseObject);

}).call(this);

//# sourceMappingURL=SingleObjectTransaction.js.map
