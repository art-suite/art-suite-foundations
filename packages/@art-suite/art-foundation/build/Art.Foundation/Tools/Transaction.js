// Generated by CoffeeScript 1.12.7

/*
Transaction provides a manual, yet easy way to log the before and after values
of fields over many objects.

It is "manual" in that you must:

  Pre-specify all objects you wish to track.
  Specify the properties you wish to track for all objects and/or uniquely for each object.
  Pass in the "from" values or call saveFromValues
  Pass in the "to" values or call saveToValues

Once you have capture the "from" and "to" values of the transaction, you can:

  rollBack and set all properties to their "from" values
  rollForward and set all properties to their "to" values
  interpolate(p) and set all properties to their linearly interpolated value
    between their saved "from" (p=0) and "to" (p=1) values.
    If you use interpolate:
      to/from values should be pair-wise the same type
      only to/from values of the following types will be interpolated:
        numbers
        objects implementing: a.add(b), a.sub(b) and a.mul(number)
      Non-interpolatable types are handled as follows:
        switch p
          when 0 then set to "from" values
          when 1 then set to "to" values
          else left unchanged

Example initializers:

   * example-a: track obj's "foo" and "bar" properties
  new Transaction obj, properties: ["foo", "bar"]

   * same as example-a, but also initialize obj's from-values as obj.foo=1 and obj.bar=2
  new Transaction obj, from: foo:1, bar:2

   * same as example-a, but also initialize obj's to-values as obj.foo=1 and obj.bar=2
  new Transaction obj, to: foo:1, bar:2

   * track obj1 and obj2's "foo" and "bar" properties
  new Transaction [obj1, obj2], properties: ["foo", "bar"]

   * track:
   *   obj1's foo, bar, noo and mar properties, with both from and to values initialized
   *   obj2's goo, har, noo and mar properties, with both from and to values initialized
  new Transaction [
      [obj1,
        from: foo:1, bar:2
        to:   foo:2, bar:3
      ],
      [obj2,
        from: goo:1, har:2
        to:   goo:2, har:3
      ]
    ],
    from: noo:4, mar:5
    to:   noo:4, mar:5
 */

(function() {
  var BaseClass, Map, SingleObjectTransaction, Transaction, cloneByStructure, eq, inspect, mapToKeysArray, mapToValuesArray, ref, rubyTrue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), rubyTrue = ref.rubyTrue, eq = ref.eq, inspect = ref.inspect, Map = ref.Map, cloneByStructure = ref.cloneByStructure, mapToKeysArray = ref.mapToKeysArray, mapToValuesArray = ref.mapToValuesArray;

  BaseClass = require('art-class-system').BaseClass;

  SingleObjectTransaction = require('./SingleObjectTransaction');

  module.exports = Transaction = (function(superClass) {
    extend(Transaction, superClass);

    Transaction.SingleObjectTransaction = SingleObjectTransaction;

    function Transaction(objects, options) {
      if (options == null) {
        options = {};
      }
      Transaction.__super__.constructor.apply(this, arguments);
      this._objects = new Map;
      if (objects.constructor === Array) {
        this.addObjects(objects);
      } else {
        this.addObject(objects);
      }
      if (options.properties) {
        this.addProperties(options.properties);
      }
      if (options.property) {
        this.addProperties([options.property]);
      }
      if (options.from) {
        this.addFromValues(options.from);
      }
      if (options.to) {
        this.addToValues(options.to);
      }
      this.saveFromValues();
    }

    Transaction.prototype.inspect = function(inspector) {
      if (!inspector) {
        return ClassSystem.Inspect.inspect(this);
      }
      inspector.put(this.classPathName + ":");
      return this.inspectParts(inspector);
    };

    Transaction.prototype.inspectParts = function(inspector) {
      return this._objects.each((function(_this) {
        return function(k, v) {
          inspector.put("\n  ");
          return inspector.inspect(v);
        };
      })(this));
    };

    Transaction.getter({
      objects: function() {
        return mapToKeysArray(this._objects);
      }
    });

    Transaction.prototype.properties = function(obj) {
      return this._objects.get(obj).properties;
    };

    Transaction.prototype.from = function(obj) {
      return this._objects.get(obj).from;
    };

    Transaction.prototype.to = function(obj) {
      return this._objects.get(obj).to;
    };

    Transaction.prototype.rollBack = function() {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.rollBack();
        };
      })(this));
    };

    Transaction.prototype.rollForward = function() {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.rollForward();
        };
      })(this));
    };

    Transaction.prototype.interpolate = function(p) {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.interpolate(p);
        };
      })(this));
    };

    Transaction.prototype.optimize = function() {
      this.optimizeProperties();
      return this.optimizeObjects();
    };

    Transaction.getter({
      hasToValues: function() {
        var result;
        result = false;
        this._objects.forEach((function(_this) {
          return function(oi) {
            if (oi.hasToValues) {
              return result = true;
            }
          };
        })(this));
        return result;
      },
      valuesChanged: function() {
        var result;
        result = false;
        this._objects.forEach((function(_this) {
          return function(object) {
            if (object.valuesChanged) {
              return result = true;
            }
          };
        })(this));
        return result;
      }
    });

    Transaction.prototype.toString = function() {
      return (this.className + "\n  ") + (this._objects.map(function(obj, single) {
        return single.toString();
      })).join("  \n");
    };

    Transaction.prototype.addFromValues = function(from) {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.addFromValues(from);
        };
      })(this));
    };

    Transaction.prototype.addToValues = function(to) {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.addToValues(to);
        };
      })(this));
    };

    Transaction.prototype.addProperties = function(properties) {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.addProperties(properties);
        };
      })(this));
    };

    Transaction.prototype.addObject = function(obj) {
      var oi;
      oi = new SingleObjectTransaction(obj);
      return this._objects.set(oi.object, oi);
    };

    Transaction.prototype.addObjects = function(objects) {
      var i, len, obj, results;
      results = [];
      for (i = 0, len = objects.length; i < len; i++) {
        obj = objects[i];
        results.push(this.addObject(obj));
      }
      return results;
    };

    Transaction.prototype.saveFromValues = function() {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.saveFromValues();
        };
      })(this));
    };

    Transaction.prototype.saveToValues = function() {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.saveToValues();
        };
      })(this));
    };

    Transaction.prototype.optimizeProperties = function() {
      return this._objects.forEach((function(_this) {
        return function(oi) {
          return oi.optimizeProperties();
        };
      })(this));
    };

    Transaction.prototype.optimizeObjects = function() {
      var objs;
      objs = this._objects;
      this._objects = new Map;
      return objs.forEach((function(_this) {
        return function(oi) {
          if (!oi.noChanges) {
            return _this._objects.set(oi.object, oi);
          }
        };
      })(this));
    };

    return Transaction;

  })(BaseClass);

}).call(this);

//# sourceMappingURL=Transaction.js.map
