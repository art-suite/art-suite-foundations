"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["objectHasKeys", "getAllPackagesVersionInfo", "eq", "objectDiffReport", "Object", "objectWithout", "compactFlattenAll", "semver"], [global, require('./StandardImport'), {semver: require('semver')}], (objectHasKeys, getAllPackagesVersionInfo, eq, objectDiffReport, Object, objectWithout, compactFlattenAll, semver) => {let stripEmptyKeys; stripEmptyKeys = function(o) {return Caf.object(o, null, (v) => objectHasKeys(v));}; return {options: {verbose: "true/false"}, description: "Show all package versions. This includes all local versions and all published versions, and if they are out of sync, a brief status on what is different.", run: function({verbose}) {let packageFieldsNpmChanges, normalizeVersion; packageFieldsNpmChanges = ["gitHead", "_id", "_nodeVersion", "_npmVersion", "_npmUser", "directories", "maintainers", "_npmOperationalInternal", "_hasShrinkwrap", "author", "bugs", "dist", "repository", "integrity", "shasum", "tarball", "fileCount", "unpackedSize", "signatures", "devDependencies", "description"]; normalizeVersion = (v) => {let to, i, by; ([v] = v.match(/\d+(\.\d+)*/) || []); if (v) {if (!/\d+\.\d+\.\d+/.test(v)) {to = 3 - v.split(".").length; i = 0; by = (i < to) ? 1 : -1; while (by > 0 && i < to || by < 0 && i > to) {let v1; v1 = i; v = v + ".0"; i += by;}; to;};}; return v;}; return getAllPackagesVersionInfo().then((packages) => Caf.object(packages, ({version, publishedVersion, status, package: _package, publishedPackage}) => {let dependencies, versionChanges, otherChanges; return {version, publishedVersion, status: (() => {switch (status) {case "unpublished": return status.white; case "behind": return status.red; case "current": return eq(_package, publishedPackage) ? status.grey : objectHasKeys(dependencies = stripEmptyKeys(objectDiffReport(_package.dependencies, publishedPackage.dependencies))) ? (dependencies.changed ? (versionChanges = {}, Caf.each2(dependencies.changed, ({newItem, oldItem}, key) => {let changeType; newItem = normalizeVersion(newItem); oldItem = normalizeVersion(oldItem); return (!newItem || !oldItem) ? versionChanges.incomparable = compactFlattenAll(versionChanges.incomparable, key) : semver.gt(oldItem, newItem) ? versionChanges.reverted = compactFlattenAll(versionChanges.reverted, key) : (changeType = semver.diff(oldItem, newItem), versionChanges[changeType] = compactFlattenAll(versionChanges[changeType], key));})) : undefined, verbose ? {dependencies, versionChanges} : dependencies.added ? `dependencies have been added: ${Caf.toString(Object.keys(dependencies.added).join(", "))}`.yellow : dependencies.removed ? `dependencies have been removed: ${Caf.toString(Object.keys(dependencies.removed).join(", "))}`.grey : (() => {switch (false) {case !versionChanges.reverted: return `dependencies have reverted: ${Caf.toString(versionChanges.reverted.join(", "))}`.red; case !versionChanges.incomparable: return `dependencies have major-version changes: ${Caf.toString(versionChanges.incomparable.join(", "))}`.yellow; case !versionChanges.major: return `dependencies have major-version changes: ${Caf.toString(versionChanges.major.join(", "))}`.yellow; case !versionChanges.minor: return `dependencies have minor-version changes: ${Caf.toString(versionChanges.minor.join(", "))}`.yellow; case !versionChanges.patch: return `dependencies have patch-version changes: ${Caf.toString(versionChanges.patch.join(", "))}`.grey;};})()) : (otherChanges = stripEmptyKeys(objectDiffReport(objectWithout(_package, ...packageFieldsNpmChanges), objectWithout(publishedPackage, ...packageFieldsNpmChanges), eq)), objectHasKeys(otherChanges) ? verbose ? otherChanges : ("current, but package.json changed").grey : status.grey); default: return status;};})()};}));}};});});
//# sourceMappingURL=versions.js.map
