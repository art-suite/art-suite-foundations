"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["existsSync", "JSON", "readFileSync", "log", "process", "writeFileSync", "consistentJsonStringify", "compactFlatten", "Promise", "present", "glob", "join", "blue", "pluralize", "unlink", "yellow", "getLatestPublishedPackageJson", "missing", "semver"], [global, require('art-standard-lib').terminalColors, require('art-standard-lib'), require('./NpmApi'), require('fs'), require('fs').promises, require('art-communication-status'), require('glob'), require('path'), {semver: require('semver')}], (existsSync, JSON, readFileSync, log, process, writeFileSync, consistentJsonStringify, compactFlatten, Promise, present, glob, join, blue, pluralize, unlink, yellow, getLatestPublishedPackageJson, missing, semver) => {let readJson, globAllPackages, packagePathToPackageFolder, loadAllPackages, removePackageLocks, removeNodeModules, getAllPackagesVersionInfo, execShellCommand; return {readJson: readJson = function(file) {let error; return existsSync(file) ? (() => {try {return JSON.parse(readFileSync(file));} catch (error1) {error = error1; log.error(`Failed to parse: ${Caf.toString(file)}\n\n${Caf.toString(error.message)}`); return process.exit(1);};})() : {};}, writeJson: function(file, data) {return writeFileSync(file, consistentJsonStringify(data, "  ") + "\n");}, globAllPackages: globAllPackages = function(folder) {let folders; folders = Caf.array(compactFlatten([folder]), null, (f) => present(f)); return Promise.then(() => (folders.length > 0) ? Promise.all(Caf.array(folders, (folder) => glob(join(folder, "**", "package.json")))).then(compactFlatten) : glob(join("!(node_modules)", "**", "package.json")));}, packagePathToPackageFolder: packagePathToPackageFolder = function(packagePath) {return packagePath.replace(/(\/)package.json/, "").replace(/^package.json$/, ".");}, loadAllPackages: loadAllPackages = function(folder) {return globAllPackages(folder).then((results) => {let from, into, to, i, temp; return (from = results, into = {}, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let file; file = from[i]; if (!/node_modules\//.test(file)) {into[packagePathToPackageFolder(file)] = readJson(file);}; temp = i++;}; return temp;})()) : undefined, into);});}, removePackageLocks: removePackageLocks = function() {return glob("!(node_modules)/**/package-lock.json").then((results) => {if (results.length > 0) {log(blue(`Removing ${Caf.toString(pluralize(results.length, "package-specific package-lock.json file"))}...`));}; return Promise.all(Caf.array(results, (packageLock) => {log({rm: packageLock}); return unlink(packageLock);})).then(() => (results.length > 0) ? log(blue(`Removed ${Caf.toString(pluralize(results.length, "package-specific package-lock.json file"))}.`)) : undefined);});}, removeNodeModules: removeNodeModules = function() {return glob("!(node_modules)/**/node_modules").then((results) => {if (results.length > 0) {log(blue(`Removing ${Caf.toString(pluralize(results.length, "package-specific node_modules/ directory"))}...`));}; return Promise.all(Caf.array(results, (nodeModules) => {let cmd; log(yellow(cmd = `rm -rf ${Caf.toString(nodeModules)}`)); return execShellCommand(cmd);})).then(() => (results.length > 0) ? log(blue(`Removed ${Caf.toString(pluralize(results.length, "package-specific node_modules/ directory"))}.`)) : undefined);});}, getAllPackagesVersionInfo: getAllPackagesVersionInfo = function() {return loadAllPackages().then((packages) => Promise.deepAll(Caf.object(packages, (_package) => {let name, version; name = _package.name; version = _package.version; return getLatestPublishedPackageJson(name).catch((response) => (response.status === missing) ? null : Promise.reject(response)).then((publishedPackage) => {let publishedVersion; publishedVersion = Caf.exists(publishedPackage) && publishedPackage.version; return {name, version, package: _package, publishedPackage, publishedVersion, status: (!(publishedVersion != null)) ? "unpublished" : semver.gt(version, publishedVersion) ? "ahead" : semver.gt(publishedVersion, version) ? "behind" : "current"};});})));}, cleanMonorepo: function() {return removePackageLocks().then(() => removeNodeModules());}, execShellCommand: execShellCommand = function(cmd) {return new Promise((resolve, reject) => require('child_process').exec(cmd, (error, stdout, stderr) => error ? reject({stderr, stdout}) : resolve(stdout)));}};});});
//# sourceMappingURL=Lib.js.map
