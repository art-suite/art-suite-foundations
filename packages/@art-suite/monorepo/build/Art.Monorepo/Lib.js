"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["existsSync", "JSON", "readFileSync", "log", "process", "writeFileSync", "compactFlatten", "Promise", "getAllNonIgnoredFiles", "present", "glob", "join", "unlink", "blue", "yellow", "pluralize", "grey", "getLatestPublishedPackageJson", "missing", "semver"], [global, require('art-standard-lib').terminalColors, require('art-standard-lib'), require('./NpmApi'), require('fs'), require('fs').promises, require('art-communication-status'), require('glob'), require('path'), {semver: require('semver')}, require('./gitignore')], (existsSync, JSON, readFileSync, log, process, writeFileSync, compactFlatten, Promise, getAllNonIgnoredFiles, present, glob, join, unlink, blue, yellow, pluralize, grey, getLatestPublishedPackageJson, missing, semver) => {let readJson, globAllPackages, packagePathToPackageFolder, loadAllPackages, getSubPackageLockFiles, getSubNodeModulesFolders, rmFile, rmFolder, removePackageLocks, removeNodeModules, fullMonorepoReset, getAllPackagesVersionInfo, monorepoIsClean, execShellCommand; return {readJson: readJson = function(file) {let error; return existsSync(file) ? (() => {try {return JSON.parse(readFileSync(file));} catch (error1) {error = error1; log.error(`Failed to parse: ${Caf.toString(file)}\n\n${Caf.toString(error.message)}`); return process.exit(1);};})() : {};}, writeJson: function(file, data) {return writeFileSync(file, JSON.stringify(data, null, 2) + "\n");}, globAllPackages: globAllPackages = function(folder) {let folders; folders = Caf.array(compactFlatten([folder]), null, (f) => present(f)); return Promise.then(() => (folders.length > 0) ? Promise.all(Caf.array(folders, (folder) => glob(join(folder, "**", "package.json")))).then(compactFlatten) : glob(join("!(node_modules)", "**", "package.json"))).then(getAllNonIgnoredFiles);}, packagePathToPackageFolder: packagePathToPackageFolder = function(packagePath) {return packagePath.replace(/(\/)package.json/, "").replace(/^package.json$/, ".");}, loadAllPackages: loadAllPackages = function(folder) {return globAllPackages(folder).then((results) => {let from, into, to, i, temp; return (from = results, into = {}, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let file; file = from[i]; if (!/node_modules\//.test(file)) {into[packagePathToPackageFolder(file)] = readJson(file);}; temp = i++;}; return temp;})()) : undefined, into);});}, getSubPackageLockFiles: getSubPackageLockFiles = function() {return glob("!(node_modules)/**/package-lock.json");}, getSubNodeModulesFolders: getSubNodeModulesFolders = function() {return glob("!(node_modules)/**/node_modules");}, rmFile: rmFile = function(file) {log({rm: file}); return unlink(file).then(() => log(blue(`Removed: ${Caf.toString(file)}`)));}, rmFolder: rmFolder = function(folder) {let cmd; log(yellow(cmd = `rm -rf ${Caf.toString(folder)}`)); return execShellCommand(cmd).then(() => log(blue(`Removed: ${Caf.toString(folder)}`)));}, removePackageLocks: removePackageLocks = function() {return getSubPackageLockFiles().then((results) => {if (results.length > 0) {log(blue(`Removing ${Caf.toString(pluralize(results.length, "package-specific package-lock.json file"))}...`));}; return Promise.all(Caf.array(results, (packageLock) => rmFile(packageLock))).then(() => (results.length > 0) ? log(blue(`Removed ${Caf.toString(pluralize(results.length, "package-specific package-lock.json file"))}.`)) : undefined);});}, removeNodeModules: removeNodeModules = function() {return getSubNodeModulesFolders().then((results) => {if (results.length > 0) {log(blue(`Removing ${Caf.toString(pluralize(results.length, "package-specific node_modules/ directory"))}...`));}; return Promise.all(Caf.array(results, (nodeModules) => rmFolder(nodeModules))).then(() => (results.length > 0) ? log(blue(`Removed ${Caf.toString(pluralize(results.length, "package-specific node_modules/ directory"))}.`)) : undefined);});}, fullMonorepoReset: fullMonorepoReset = function() {log(yellow("Resetting the monorepo...")); log(grey("This will remove all package-lock.json files and node_modules folders in the entire monorepo.")); return Promise.all([removePackageLocks(), removeNodeModules(), rmFile("package-lock.json"), rmFolder("node_modules")]).then(() => log(blue("Monorepo reset complete.")));}, getAllPackagesVersionInfo: getAllPackagesVersionInfo = function() {return loadAllPackages().then((packages) => Promise.deepAll(Caf.object(packages, (_package) => {let name, version; name = _package.name; version = _package.version; return getLatestPublishedPackageJson(name).catch((response) => (response.status === missing) ? null : Promise.reject(response)).then((publishedPackage) => {let publishedVersion; publishedVersion = Caf.exists(publishedPackage) && publishedPackage.version; return {name, version, package: _package, publishedPackage, publishedVersion, status: (!(publishedVersion != null)) ? "unpublished" : semver.gt(version, publishedVersion) ? "ahead" : semver.gt(publishedVersion, version) ? "behind" : "current"};});})));}, monorepoIsClean: monorepoIsClean = function() {return Promise.all([getSubPackageLockFiles(), getSubNodeModulesFolders()]).then(([packageLockFiles, nodeModulesFolders]) => packageLockFiles.length === 0 && nodeModulesFolders.length === 0);}, cleanMonorepo: function() {return removePackageLocks().then(() => removeNodeModules());}, execShellCommand: execShellCommand = function(cmd) {return new Promise((resolve, reject) => require('child_process').exec(cmd, (error, stdout, stderr) => error ? reject({stderr, stdout}) : resolve(stdout)));}};});});
//# sourceMappingURL=Lib.js.map
