"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["allPackageExec", "merge", "compactFlattenAll", "cleanMonorepo", "green", "Promise"], [global, require('./StandardImport')], (allPackageExec, merge, compactFlattenAll, cleanMonorepo, green, Promise) => {let makeNpmRunCommand, makeNpmCommand; makeNpmRunCommand = function(command) {return (options, args) => allPackageExec(merge(options, {skip: ({scripts}, path) => !((Caf.exists(scripts) && scripts[command]) != null) ? `(package.json does not have a '${Caf.toString(command)}' script)` : undefined, folder: compactFlattenAll(options.folder, args), command: `npm run ${Caf.toString(command)}`, verb: command}));}; makeNpmCommand = function(command) {return {options: {verbose: "true/false", folder: 'find all packages in this path. default: "."'}, args: "Find all packages in any additional paths passed as args.", description: `Runs \`npm run ${Caf.toString(command)}\` in every subfolder with a package.json file.`, run: makeNpmRunCommand(command)};}; return {"update-mono-package": require('./UpdateMonoPackage'), "update-sub-packages": require('./UpdateSubPackages'), test: makeNpmCommand("test"), build: makeNpmCommand("build"), sync: {description: "Sync the root package.json with all package.json files in subfolders. This will ensure all packages are using the same version of every external dependency. It will also ensure all cross-referenced packages within the monorepo are referencing the latest version. Last, it will update the root package.json to contain all external references. It's best to run `npm install` immediately after running this.\n\nThis happens in three steps:\n\n1. Clean: remove all package-lock.json files and all node_modules folders in sub-folders. There should only be one of each in the root of the monorepo.\n2. Update sub-packages: update all dependency versions in all sub-packages to match the root package.json.\n3. Update mono-package: update the root mono-repo's package.json with any new dependencies found in sub-packages as well as updating any cross-referencing between packages within the monorepo.", options: {quiet: "Suppress output."}, run: function(options) {return cleanMonorepo().then(() => require('./UpdateSubPackages').run(options)).then(() => require('./UpdateMonoPackage').run(options)).then(() => green("All package.json files synced."));}}, run: {description: "'npm run X' in all packages. This will run the command in every subfolder with a package.json file.", options: {verbose: "true/false", folder: 'find all packages in this path. default: "."'}, args: "Npm run-command.", run: function(options, args) {return makeNpmRunCommand(args[0])(options, args.slice(1));}}, exec: {description: "Run shell command in every subfolder with a package.json file.", options: {verbose: "true/false", folder: 'find all packages in this path. default: "."'}, args: "Shell command to run.", run: function(options, args) {return allPackageExec(merge(options, {verb: "exec", command: args.join(" ")}));}}, versions: require('./versions'), clean: {description: "Advanced: Delete all package-lock.json files and node_modules folders in all subfolders. There should only be one package-lock.json file and one node_modules folder located in the root of the monorepo.", run: function(options) {return cleanMonorepo().then(() => green("Monorepo is clean."));}}, update: {options: {quiet: "Suppress output."}, description: "Advanced: Run the update-sub-packages then update-mono-package.", run: function(options) {return Promise.then(() => require('./UpdateSubPackages').run(options)).then(() => require('./UpdateMonoPackage').run(options));}}};});});
//# sourceMappingURL=Commands.js.map
