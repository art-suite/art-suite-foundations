"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["objectHasKeys", "allPackageExec", "merge", "cleanMonorepo", "green", "process", "getAllPackagesVersionInfo", "eq", "objectDiffReport", "Object", "objectWithout", "semver", "compactFlattenAll", "Promise"], [global, require('./StandardImport'), {semver: require('semver')}], (objectHasKeys, allPackageExec, merge, cleanMonorepo, green, process, getAllPackagesVersionInfo, eq, objectDiffReport, Object, objectWithout, semver, compactFlattenAll, Promise) => {let stripEmptyKeys; stripEmptyKeys = function(o) {return Caf.object(o, null, (v) => objectHasKeys(v));}; return {"update-mono-package": require('./UpdateMonoPackage'), "update-sub-packages": require('./UpdateSubPackages'), test: function(options) {return allPackageExec(merge(options, {command: "npm test", verb: "test"}));}, sync: function(options) {return cleanMonorepo().then(() => require('./UpdateSubPackages')(options)).then(() => require('./UpdateMonoPackage')(options)).then(() => green("All package.json files synced."));}, run: {options: {command: "Shell command to run.", verbose: "true/false", path: 'find all packages in this path. default: "."'}, run: function(options) {let path; if (path = options.path) {process.chdir(path);}; return allPackageExec(merge(options, {verb: "run"}));}}, versions: function({verbose}) {let packageFieldsNpmChanges; packageFieldsNpmChanges = ["gitHead", "_id", "_nodeVersion", "_npmVersion", "_npmUser", "directories", "maintainers", "_npmOperationalInternal", "_hasShrinkwrap", "author", "bugs", "dist", "repository", "integrity", "shasum", "tarball", "fileCount", "unpackedSize", "signatures", "devDependencies", "description"]; return getAllPackagesVersionInfo().then((packages) => Caf.object(packages, ({version, publishedVersion, status, package: _package, publishedPackage}) => {let dependencies, versionChanges, otherChanges; return {version, publishedVersion, status: (() => {switch (status) {case "unpublished": return status.white; case "behind": return status.red; case "current": return eq(_package, publishedPackage) ? status.grey : objectHasKeys(dependencies = stripEmptyKeys(objectDiffReport(_package.dependencies, publishedPackage.dependencies))) ? (dependencies.changed ? (versionChanges = {}, Caf.each2(dependencies.changed, ({newItem, oldItem}, key) => {let changeType; ([newItem] = newItem.match(/(\d+(\.)?)+/)); ([oldItem] = oldItem.match(/(\d+(\.)?)+/)); return semver.gt(oldItem, newItem) ? versionChanges.reverted = compactFlattenAll(versionChanges.reverted, key) : (changeType = semver.diff(oldItem, newItem), versionChanges[changeType] = compactFlattenAll(versionChanges[changeType], key));})) : undefined, verbose ? {dependencies, versionChanges} : dependencies.added ? `dependencies have been added: ${Caf.toString(Object.keys(dependencies.added).join(", "))}`.yellow : dependencies.removed ? `dependencies have been removed: ${Caf.toString(Object.keys(dependencies.added).join(", "))}`.grey : (() => {switch (false) {case !versionChanges.reverted: return `dependencies have reverted: ${Caf.toString(versionChanges.reverted.join(", "))}`.red; case !versionChanges.major: return `dependencies have major-version changes: ${Caf.toString(versionChanges.major.join(", "))}`.yellow; case !versionChanges.minor: return `dependencies have minor-version changes: ${Caf.toString(versionChanges.minor.join(", "))}`.yellow; case !versionChanges.patch: return `dependencies have patch-version changes: ${Caf.toString(versionChanges.patch.join(", "))}`.grey;};})()) : (otherChanges = stripEmptyKeys(objectDiffReport(objectWithout(_package, ...packageFieldsNpmChanges), objectWithout(publishedPackage, ...packageFieldsNpmChanges), eq)), objectHasKeys(otherChanges) ? verbose ? otherChanges : ("current, but package.json changed").grey : status.grey); default: return status;};})()};}));}, clean: function(options) {return cleanMonorepo().then(() => green("Monorepo is clean."));}, update: function(options) {return Promise.then(() => require('./UpdateSubPackages')(options)).then(() => require('./UpdateMonoPackage')(options));}};});});
//# sourceMappingURL=Commands.js.map
