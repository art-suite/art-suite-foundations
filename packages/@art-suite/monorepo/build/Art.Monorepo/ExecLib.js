"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["log", "blue", "upperCase", "loadAllPackages", "pluralize", "Promise", "readJson", "yellow", "isString", "grey", "execShellCommand", "green", "red", "present", "process"], [global, require('art-standard-lib'), require('./ColorsLib'), require('./Lib')], (log, blue, upperCase, loadAllPackages, pluralize, Promise, readJson, yellow, isString, grey, execShellCommand, green, red, present, process) => {let indent, logRun; indent = function(str, amount = "   ") {return amount + str.replace(/\n/g, `\n${Caf.toString(amount)}`);}; logRun = function(verb, packagePath) {return log(blue(`${Caf.toString(verb)}: `) + packagePath);}; return {allPackageExec: function(options) {let command, verb, verbose, folder, skipTest, temp; command = options.command; verb = options.verb; verbose = options.verbose; folder = options.folder; skipTest = ((temp = options.skip) != null ? temp : (() => false)); verb = upperCase(verb); return loadAllPackages(folder).then((packages) => Caf.array(packages, ({scripts}, packagePath) => packagePath, ({scripts}, packagePath) => Caf.exists(scripts) && scripts.test)).then((packagePaths) => {let passed, skipped, failed; logRun(`${Caf.toString(verb)}ING`, pluralize("package", packagePaths.length)); log(packagePaths); passed = []; skipped = []; failed = []; return Promise.all(Caf.array(packagePaths, (packagePath) => {let packageContents, skipReason; packageContents = readJson(require('path').join(packagePath, "package.json")); return (skipReason = skipTest(packageContents, packagePath, options)) ? (skipped.push(packagePath), logRun("SKIPPED", yellow(packagePath) + (isString(skipReason) ? grey(` ${Caf.toString(skipReason)}`) : ""))) : (logRun(verb, grey(packagePath)), execShellCommand(`cd ${Caf.toString(packagePath)};${Caf.toString(command)}`).then((stdout) => {passed.push(packagePath); if (verbose) {log(blue(`${Caf.toString(packagePath)} > ${Caf.toString(command)} (stdout)`)); log(indent(stdout.trim(), "  "));}; logRun("SUCCESS", green(packagePath)); return verbose ? log("") : undefined;}, ({stdout, stderr}) => {failed.push(packagePath); logRun("FAILED", red(packagePath)); if (present(stdout)) {log(blue(`  ${Caf.toString(packagePath)} > ${Caf.toString(command)} (stdout)`)); log(indent(stdout.trim())); log("");}; return present(stderr) ? (log(blue(`  ${Caf.toString(packagePath)} > ${Caf.toString(command)} (stderr)`)), log(red(indent(stderr.trim()))), log("")) : undefined;}));})).then(() => {log(blue("\nRESULTS:")); log(blue("  succeeded: " + green(passed.length))); if (skipped.length > 0) {log(blue("  skipped: " + yellow(skipped.length)));}; if (failed.length > 0) {Caf.each2(failed, (f) => log(blue("  failed: " + red(f)))); process.exit(1);}; return null;});});}};});});
//# sourceMappingURL=ExecLib.js.map
