"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "log", "blue", "readJson", "clone", "Error", "loadAllPackages", "neq", "writeJson"], [global, require('./StandardImport')], (merge, log, blue, readJson, clone, Error, loadAllPackages, neq, writeJson) => {let addArtMonorepoFeatures; addArtMonorepoFeatures = function(rootPackage) {let temp, base; ((temp = (base = rootPackage.dependencies)[require('../../package').name]) != null ? temp : base[require('../../package').name] = "^" + require('../../package').version); rootPackage.scripts = merge(Caf.object(["test", "build", "sync", "clean", "update", "versions"], (script) => `art-monorepo ${Caf.toString(script)}`), rootPackage.scripts); return rootPackage;}; return {options: {quiet: "Supress output."}, description: "Advanced: Update the root package.json file based on all the package.json files in sub-folders. This includes updating dependency versions, new dependencies, and cross-references between packages in the mono-repo. Run `npm install` after.", run: function({quiet}) {let rootPackage, originalRootPackage, previousSubPackages, HandledError, addDep; if (!quiet) {log(blue("Updating **/package.json >> ./package.json..."));}; rootPackage = readJson("package.json"); originalRootPackage = clone(rootPackage); rootPackage.dependencies = {}; previousSubPackages = {}; HandledError = Caf.defClass(class HandledError extends Error {}); addDep = (type, name, version, subPackage) => {let intoPackageSet, existingDep, alreadyHaveDep, alreadyFileDep, settingFileDep, conflict, previousSubPackage, previousVersion; intoPackageSet = rootPackage[type]; existingDep = intoPackageSet[name]; alreadyHaveDep = !!existingDep; alreadyFileDep = alreadyHaveDep && /^file:/.test(existingDep); settingFileDep = /^file:/.test(version); conflict = alreadyHaveDep && existingDep !== version && alreadyFileDep === settingFileDep; if (conflict) {previousSubPackage = previousSubPackages[type][name]; previousVersion = intoPackageSet[name]; log.warn("CONFLICTING PACKAGE VERSIONS:"); log.withOptions({color: true, unquoted: true, maxLineLength: 78}, {dependency: name, conflictingPackages: {[((subPackage != null) ? subPackage.path : "package") + "/package.json"]: version, [((previousSubPackage != null) ? previousSubPackage.path : "previous_package") + "/package.json"]: previousVersion}}); throw new HandledError(`Missmatch conflict:\n  ${Caf.toString(Caf.exists(subPackage) && subPackage.path)}: ${Caf.toString(name)}: '${Caf.toString(intoPackageSet[name])}'\n  ${Caf.toString(Caf.exists(previousSubPackage) && previousSubPackage.path)}: ${Caf.toString(name)}: '${Caf.toString(version)}'`);} else {if (!alreadyFileDep) {intoPackageSet[name] = version;};}; previousSubPackages[type] = previousSubPackages[type] || {}; return previousSubPackages[type][name] = subPackage;}; return loadAllPackages().then((packages) => {let packageFolderByPackageName; packageFolderByPackageName = {}; Caf.each2(packages, (_package, packageFolder) => {let name, dependencies, devDependencies; _package.path = packageFolder; name = _package.name; dependencies = _package.dependencies; devDependencies = _package.devDependencies; if (packageFolderByPackageName[name]) {log.error(`Two different packages have the same name in their package.json file:\n\n  ${Caf.toString(packageFolder)}\n  ${Caf.toString(packageFolderByPackageName[name])}`); throw new HandledError("Two packages have the same name");} else {if (name != null) {packageFolderByPackageName[name] = packageFolder;};}; Caf.each2(dependencies, (v, k) => addDep("dependencies", k, v, _package)); Caf.each2(devDependencies, (v, k) => addDep("dependencies", k, v, _package)); return (name != null) ? addDep("dependencies", name, `file:${Caf.toString(packageFolder)}`) : undefined;}); addArtMonorepoFeatures(rootPackage); if (neq(originalRootPackage, rootPackage)) {writeJson("package.json", rootPackage); log("Updated ./package.json");} else {log("Everything up to date.");}; return null;}).catch((error) => !(Caf.is(error, HandledError)) ? (() => {throw error;})() : undefined);}};});});
//# sourceMappingURL=UpdateMonoPackage.js.map
