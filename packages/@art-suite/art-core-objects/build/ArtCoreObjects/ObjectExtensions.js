"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["isString", "Error", "isPlainObject", "mergeInto", "isArray", "Object", "isFunction", "compactFlatten", "present", "isObject"], [global, require('@art-suite/art-core-types'), require('@art-suite/art-core-arrays'), require('./Merge')], (isString, Error, isPlainObject, mergeInto, isArray, Object, isFunction, compactFlatten, present, isObject) => {let vivifyObjectPathList, propertyIsPathed, withPropertyPath, toObjectInternal, objectKeyCount, vivifyObjectPath, setPathedProperty, withPathedPropertiesExpanded; vivifyObjectPathList = function(obj, path, setValue) {let from, into, to, i1; from = path; into = from; if (from != null) {to = from.length; i1 = 0; while (i1 < to) {let field, i, temp; field = from[i1]; i = i1; if (field != null) {obj = (() => {switch (false) {case !(setValue != null && i === path.length - 1): return obj[field] = setValue; case !isString(field): return ((temp = obj[field]) != null ? temp : obj[field] = {}); default: return (() => {throw new Error("Expecting string or array or null/undefined");})();};})();}; i1++;};}; into; return obj;}; propertyIsPathed = function(key) {return /[\s\.\/]/.test(key);}; withPropertyPath = function(obj, propertyPath, action) {let result; propertyPath = propertyPath.match(/[^\s\.\/]+/g); result = obj; Caf.each2(propertyPath, (key, i) => {let temp; return (i === propertyPath.length - 1) ? action(obj, key) : obj = ((temp = obj[key]) != null ? temp : obj[key] = {});}); return result;}; toObjectInternal = function(list, out) {let key; key = null; Caf.each2(list, (element) => key ? (out[key] = element, key = null) : isPlainObject(element) ? mergeInto(out, element) : isArray(element) ? toObjectInternal(element, out) : (element != null) ? key = element : undefined); if (key) {out[key] = undefined;}; return out;}; return {countKeys: function(o) {return Object.keys(o).length;}, objectKeyCount: objectKeyCount = function(o) {let count; count = 0; Caf.each2(o, () => count++); return count;}, objectHasKeys: function(o) {return !!Caf.find(o, () => true);}, vivifyObjectPath: vivifyObjectPath = function(obj, ...path) {if (!isPlainObject(obj)) {throw new Error("obj must be an object");}; return vivifyObjectPathList(obj, path);}, vivifyObjectPathAndSet: function(obj, ...path) {let value; if (!isPlainObject(obj)) {throw new Error("obj must be an object");}; path = [...path]; value = path.pop(); vivifyObjectPathList(obj, path, value); return value;}, toObject: function(...all) {let out; return toObjectInternal(all, out = {});}, arrayToMap: function(inputArray, transformFunction = (element) => element) {let outputMap; outputMap = {}; Caf.each2(inputArray, (element) => {let key, value; ([key, value] = transformFunction(element)); return outputMap[key] = value;}); return outputMap;}, select: function(obj, ...args) {let a; if (!obj) {return {};}; return isFunction(a = args[0]) ? Caf.object(obj, null, (v, k) => a(v, k)) : (args = compactFlatten(args), Caf.object(args, (prop) => obj[prop], (prop) => obj[prop] != null || obj.hasOwnProperty(prop)));}, selectAll: function(obj, ...properties) {let result, from, into, to, i; if (!obj) {return {};}; result = {}; from = compactFlatten(properties); into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let prop; prop = from[i]; result[prop] = obj[prop]; i++;};}; into; return result;}, objectWithDefinedValues: function(obj) {return Caf.object(obj, null, (v) => v !== undefined);}, objectWithExistingValues: function(obj) {return Caf.object(obj, null, (v) => v != null);}, objectWithPresentValues: function(obj) {return Caf.object(obj, null, (v) => present(v));}, objectWith: function(obj, k, v) {let o; o = Caf.object(obj); o[k] = v; return o;}, objectWithout: function(obj, ...properties) {if (!obj) {return {};}; properties = compactFlatten(properties); return Caf.find(properties, (prop) => obj.hasOwnProperty(prop)) ? Caf.object(obj, null, (v, prop) => !(Caf.in(prop, properties))) : obj;}, setPathedProperty: setPathedProperty = function(obj, propertyPath, value) {withPropertyPath(obj, propertyPath, (o, k) => o[k] = value); return obj;}, withPathedPropertiesExpanded: withPathedPropertiesExpanded = function(obj, intoObject = {}) {return Caf.each2(obj, (v, k) => {if (isObject(v)) {v = withPathedPropertiesExpanded(v);}; return propertyIsPathed(k) ? setPathedProperty(intoObject, k, v) : intoObject[k] = v;}, null, intoObject);}};});});
//# sourceMappingURL=ObjectExtensions.js.map
