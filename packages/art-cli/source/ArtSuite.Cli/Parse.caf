import &StandardImport

isNonClassFunction = (f) ->
  isFunction f
  && !isClass f

class Parse
  @optionRegExp: /^--(.+)$/
  @evalJsRegExp: /^js:(.*)$/
  @numberRegExp:
    ///i
      ^
      [-+]?
      ( # floating point
        [0-9]*
        \.
        [0-9]+
      | # integer
        [0-9]+
      )

      # exponent
      ([eE][-+]?[0-9]+)?
      $

  @parseArgs: (args)=>
    currentOptionName = :arg
    commands = currentOption = []
    each arg, i in args into parsedOptions = {}
      if option = arg.match @optionRegExp
        currentOption = parsedOptions[currentOptionName = lowerCamelCase option[1]] = []
      else
        currentOption.push
          switch
          when @numberRegExp.test arg then arg / 1
          when @evalJsRegExp.test arg
            evalMatch = arg.match @evalJsRegExp
            try eval evalMatch[1]
            catch error
              log.error
                evaluationError: {}
                  option: currentOptionName
                  source: evalMatch[1]
                  raw:    arg
                  error

          else arg

    {}
      commands
      options: object o, k in parsedOptions
        switch o.length
        when 0 then true
        when 1 then o[0]
        else o

  @selectCommand: (commands, commandNames) ->
    [commandName, args...] = commandNames

    commands = object v, k from commands with-key lowerCamelCase k

    unless isNonClassFunction commandFunction = commands[lowerCamelCase commandName]
      unless isNonClassFunction commandFunction = commands[commandName = commands.default]
        commandFunction = undefined
        commandName = undefined
      args = commandNames

    merge {}
      commandFunction
      commandName
      args: if args.length > 0 then args

  @parseAndSelectCommand: (commands, args) =>
    {options, commands: commandNames} = @parseArgs args
    {commandFunction, commandName, args} = @selectCommand commands, commandNames
    {}
      commandFunction
      commandName
      args
      options
