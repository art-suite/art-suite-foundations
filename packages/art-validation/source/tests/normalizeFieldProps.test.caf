import &StandardImport
{normalizeFieldProps} = Validator

assertIsTrimmedString = (ft) ->
  assert.eq ft.dataType, "string"
  assert.isFunction ft.validate
  assert.isFunction ft.preprocess

testEqNormalizeFieldProps = (a, b) ->
  test "#{formattedInspect inputs: a, outputs: stripFunctions b}" ->
    assert.eq
      stripFunctions normalizeFieldProps a
      stripFunctions b
      """
        this:       normalizeFieldProps #{formattedInspect a}
        should eq:  #{formattedInspect b}


stripFunctions = (o) ->
  switch
  when o is Object then object v from o with stripFunctions v when !isFunction v
  when o is Array then array v from o with stripFunctions v when !isFunction v
  else o

describe
  basic: ->
    testEqNormalizeFieldProps "number",  dataType: :number, fieldType: :number
    testEqNormalizeFieldProps {required: true}, required: true
    testEqNormalizeFieldProps
      {} required: :number
      {} dataType: :number, fieldType: :number, required: true

    testEqNormalizeFieldProps
      {} present: :number
      {} dataType: :number, fieldType: :number, present: true

    testEqNormalizeFieldProps
      {} dood: :number
      {} dood: :number

    testEqNormalizeFieldProps {required: ['trimmedString']}, required: ['trimmedString']

  deprecated: ->
    test "requiredPresent: true", -> assert.throws -> normalizeFieldProps requiredPresent: true

  invalid: ->
    test "normalizeFieldProps 'unknownFieldTypeTag' (an unknown field-type tag)" ->
      normalizeFieldProps :number
      normalizeFieldProps "" required number
      assert.throws -> normalizeFieldProps :unknownFieldTypeTag
      assert.throws -> normalizeFieldProps "" number unknownFieldTypeTag
      assert.throws -> normalizeFieldProps "" unknownFieldTypeTag number

  objectValues: ->
    testEqNormalizeFieldProps {required: foobar: true}, required: true, foobar: true
    testEqNormalizeFieldProps {required: foobar: :123}, required: true, foobar: :123
    testEqNormalizeFieldProps {foobar: required: true}, foobar: required: true

  declarationSequences: ->
  topLevelArrayValues: ->
    testEqNormalizeFieldProps [:required :number          ], required: true, dataType: :number, fieldType: :number
    testEqNormalizeFieldProps [:required :number fad: 123 ], required: true, dataType: :number, fieldType: :number, fad: 123

  multipleTagsInString: ->
    testEqNormalizeFieldProps 'required number',  dataType: :number fieldType: :number required: true
    testEqNormalizeFieldProps 'required present', required: true, present: true

  tagsCanBeMixedWithCustomProps: ->
    testEqNormalizeFieldProps
      :trimmedString foo: true bar: true
      normalizeFieldProps foo: true bar: true fieldType: :trimmedString

    testEqNormalizeFieldProps
      []
        :present
        foo: true
        :required
        bar: true
        :trimmedString
      normalizeFieldProps foo: true bar: true fieldType: :trimmedString required: true present: true

  nestedTypes:
    arrays: ->
      testEqNormalizeFieldProps
        {} array: :number

        array:
          dataType:   :number
          fieldType:  :number

    objects: ->
      testEqNormalizeFieldProps
        {} fields: myCustomSubField: :string

        dataType:  :object
        fieldType: :object
        fields:    myCustomSubField:
          dataType:     :string
          fieldType:    :string

  specialFieldTypes: ->
    testEqNormalizeFieldProps
      fieldType: 'trimmedString'
      {} maxLength: 1024, fieldType: :trimmedString, dataType: :string

  specialProprties: ->
    test "instanceof: Validator", ->
      ft = normalizeFieldProps instanceof: Validator
      assert.true   ft.validate new Validator
      assert.false  ft.validate {}

  customFieldTypes: ->
    test "mapped to another fieldType" ->
      assert.eq
        normalizeFieldProps
          :myCustomField
          myCustomField: :string
        merge
          normalizeFieldProps :string
          fieldType: :myCustomField

    test "mapped to an object definition" ->
      assert.eq
        stripFunctions normalizeFieldProps
          :myCustomField
          myCustomField:
            fields:
              myCustomSubField: :string

        dataType:  :object
        fieldType: :myCustomField
        fields:    myCustomSubField:
          dataType:     :string
          fieldType:    :string

    test "normalizeFields accepts custom fields" ->
      assert.eq
        normalizeFields
          {} foo: :myCustomField
          myCustomField: :string
        foo: merge
          normalizeFieldProps :string
          fieldType: :myCustomField

  recursiveTypesWithCustomFieldTypes: ->
    test "object" ->
      assert.eq
        stripFunctions normalizeFieldProps
          {} fields: data:   :record
          {} record: fields: name: :string

        dataType:     :object
        fieldType:    :object
        fields:       data:
          dataType:     :object
          fieldType:    :record
          fields:       name: dataType: :string, fieldType: :string

    test "array" ->
      assert.eq
        stripFunctions normalizeFieldProps
          {} array:   :record
          {} record: fields: name: :string

        array:
          fieldType:    :record
          dataType:     :object
          fields:       name: dataType: :string, fieldType: :string

  recursiveCustomFieldTypes: ->
    test "a references b" ->
      assert.eq
        stripFunctions normalizeFieldProps
          :myCustomField
          myCustomField:  :myCustomField2
          myCustomField2: :string

        fieldType: :myCustomField, dataType: :string

    test "a references object with b" ->
      assert.eq
        stripFunctions normalizeFieldProps
          :myCustomField
          myCustomField:  fields: myFieldName: :myCustomField2
          myCustomField2: :string

        fieldType:    :myCustomField
        dataType:     :object
        fields: myFieldName: dataType: :string, fieldType: :myCustomField2

    chainedTest "a references a not allowed" ->
      assert.rejects ->
        stripFunctions normalizeFieldProps
          :myCustomField
          myCustomField: :myCustomField
      .then (rejectsWith) -> assert.match rejectsWith.message, ///i recursive .* not\ supported

    .thenTest "after a failed recursion check, we don't wrongly trigger it again" ->
      stripFunctions normalizeFieldProps
        :myCustomField
        myCustomField:  fields: myFieldName: :string

    test "a references object a not allowed" ->
      assert.rejects ->
        stripFunctions normalizeFieldProps
          :myCustomField
          myCustomField:  fields: myFieldName: :myCustomField
      .then (rejectsWith) -> assert.match rejectsWith.message, ///i recursive .* not\ supported

    test "a references b refernces a not allowed" ->
      assert.rejects ->
        stripFunctions normalizeFieldProps
          :myCustomField
          myCustomField:  fields: myFieldName: :myCustomField2
          myCustomField2:  fields: myFieldName: :myCustomField
      .then (rejectsWith) -> assert.match rejectsWith.message, ///i recursive .* not\ supported
  downstream_dependency_regressions: ->
    test "link: 'user'" ->
      assert.eq
        stripFunctions normalizeFieldProps link: :user
        link: :user