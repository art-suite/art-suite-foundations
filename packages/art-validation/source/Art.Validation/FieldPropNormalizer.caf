import &ArtStandardLib, {} &FieldTypes

namespace = require :./namespace

normalizeInstanceOfProp = (ft) ->
  if _instanceof = ft.instanceof
    {validate} = ft
    merge ft,
      validate: (v) ->
        (v instanceof _instanceof) &&
        (!validate || validate v)
  else
    ft

standardTags =
  required: true
  present: true

## normalizeRecursivePlainObjectProps
  IN: plainObjectFieldType: plain object
  OUT: plain object

  converts something like this:
    this: is: a: recursive: field: definition: :number

  into this:
    this: true
    is: true
    a: true
    recursive: true
    field: true
    definition: true
    fieldType: :number
normalizeRecursivePlainObjectProps = (plainObjectFieldType) ->
  if 1 == objectKeyCount plainObjectFieldType
    find singleFieldValue, singleFieldName from plainObjectFieldType when standardTags[singleFieldName] &&
        isPlainObject singleFieldValue
        || isString singleFieldValue
      log.warn "" ArtValidation DEPRECTAED fieldProps: {#{singleFieldName}: object/string}. USE: ["#{singleFieldName}", object/string]
      [] singleFieldName, singleFieldValue

  ? plainObjectFieldType

normalizeDeprecatedProps = (ft) ->
  throw new Error "ArtValidation DEPRECTAED fieldProps: requiredPresent. USE: present: true" if ft.requiredPresent
  ft

normalizeObjectAndArrayFieldProps = (fieldProps, validatorOptions) ->
  {fieldType, fields, array: _array, validate, postValidate, preprocess, minLength, maxLength} = fieldProps
  fieldType ?= :object if fields
  fieldProps = merge FieldTypes[fieldType], fieldProps if isString fieldType
  if fields
    throw new Error "Can only specify `array: ...` or `fields: ...`" if _array
    subValidator = new namespace.Validator fields, merge validatorOptions, exclusive: true
    fieldProps = merge fieldProps, {}
      subValidator.fields
      validate:   validate ? (v) -> isPlainObject(v) && subValidator.isValid v
      preprocess: preprocess ? (v) -> subValidator.preprocess v

  else if _array
    normalizedArray = _normalizeFieldProps _array, validatorOptions
    merge fieldProps,
      dataType:   :array
      fieldType:  :array
      array:      normalizedArray
      validate:   validate ? if normalizedArray.validate || normalizedArray.required
        (_array) ->
          isArray _array
          && !validate || validate _array
          && !normalizedArray.validate || !find v in-array _array when v? && !normalizedArray.validate v with true
          && !normalizedArray.required || !find v in-array _array when !v? with true

      preprocess: preprocess ? if normalizedArray.preprocess
        (_array) -> if isArray _array then array v in _array with normalizedArray.preprocess v else _array

      postValidate: postValidate ? if normalizedArray.postValidate
        (_array) -> !find v in-array _array when !normalizedArray.postValidate v with true

  else fieldProps

fieldPropsWithGeneratedPostValidator = (fieldProps, validatorOptions) ->
  fieldProps extract postValidate, maxLength, minLength, length

  if length?
    if maxLength? || minLength?
      throw new Error "If specifying 'length', you can't also specify maxLength nor minLength"

    maxLength = minLength = length

  if maxLength? || minLength? # not array, because we already create a postValidate for arrays
    merge
      fieldProps
      {}
        maxLength
        minLength
        length
        postValidate: (value, fieldName, fields) ->
          if postValidate && !postValidate value, fieldName, fields then false
          else if value?
            if maxLength? && value.length > maxLength       then false
            else if minLength? && value.length < minLength  then false
            else true

          else true

  else fieldProps

applyFieldtype = (fieldProps, validatorOptions) ->
  if fieldProps extract fieldType
    unless fieldTypeProps = validatorOptions.fieldtypes[fieldType]
      throw new Error "" Unknown field-type: #{JSON.stringify fieldType}

processingCustomFieldtypePath = []
_normalizeFieldProps = (fieldProps, validatorOptions) ->
  switch
  when isPlainObject fieldProps
    normalizedFieldProps = normalizeObjectAndArrayFieldProps
      normalizeInstanceOfProp normalizeDeprecatedProps normalizeRecursivePlainObjectProps fieldProps
      validatorOptions

  when isPlainArray ftArray = fieldProps
    each fieldProps in compactFlatten ftArray into normalizedFieldProps = {}
      mergeInto normalizedFieldProps, _normalizeFieldProps fieldProps, validatorOptions

  when isString ftStrings = fieldProps
    normalizedFieldProps = {}
    each string in-array w ftStrings
      if customFieldType = validatorOptions.customFieldTypes?[string]
        try
          if string in processingCustomFieldtypePath
            throw new Error "" Recursive custom field types are not supported. Recursive path: #{processingCustomFieldtypePath.join ' > '} > #{string}

          processingCustomFieldtypePath.push string

          if isPlainObject(customFieldType) || isString customFieldType
            customFieldTypeProps = _normalizeFieldProps customFieldType, validatorOptions

          else throw new Error "Invalid custom field type #{customFieldType}. Expected string or plain object. Got: #{formattedInspect customFieldType}"

        finally
          processingCustomFieldtypePath.pop()

      if subFt = customFieldTypeProps ? FieldTypes[string]
        normalizedFieldProps.fieldType = string
        mergeIntoUnless normalizedFieldProps, subFt

      else
        normalizedFieldProps[string] = true

    normalizedFieldProps

  when fieldProps == true
    normalizedFieldProps = FieldTypes.any

  else
    throw new Error "fieldProps must be a string, plainObject, or array of strings, plainObjects and/or arrays. Was: #{formattedInspect fieldProps}"

  fieldPropsWithGeneratedPostValidator
    merge FieldTypes[normalizedFieldProps.fieldType], normalizedFieldProps
    validatorOptions

normalizeValidatorOptions = (validatorOptions) ->
  merge
    validatorOptions
    fieldTypes:
      if validatorOptions extract? customFieldTypes
            merge FieldTypes, customFieldTypes
      else  FieldTypes

{}
  normalizeFieldProps = (fieldType, validatorOptions) -> _normalizeFieldProps fieldType, normalizeValidatorOptions validatorOptions
  normalizeFields:      (fields, validatorOptions) -> object fieldType in fields with normalizeFieldProps fieldType, normalizeValidatorOptions validatorOptions
