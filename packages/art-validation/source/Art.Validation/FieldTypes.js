// Generated by CoffeeScript 1.12.7
(function() {
  var DataTypes, FieldTypes, anyDataType, arrayDataType, booleanDataType, dateDataType, emailRegexp, functionDataType, isDate, isHexColor, isId, isNumber, isString, jsonDataType, k, log, lowerCase, normalizeUrl, numberDataType, numberFromString, objectDataType, ref, ref1, stringDataType, toDate, toMilliseconds, toSeconds, urlRegexp, v, validStatus;

  ref = require('art-standard-lib'), isString = ref.isString, isNumber = ref.isNumber, isDate = ref.isDate, isHexColor = ref.isHexColor, toMilliseconds = ref.toMilliseconds, toDate = ref.toDate, toSeconds = ref.toSeconds, lowerCase = ref.lowerCase, emailRegexp = ref.emailRegexp, urlRegexp = ref.urlRegexp, log = ref.log, normalizeUrl = ref.normalizeUrl;

  ref1 = DataTypes = require('./DataTypes'), booleanDataType = ref1.booleanDataType, numberDataType = ref1.numberDataType, stringDataType = ref1.stringDataType, objectDataType = ref1.objectDataType, arrayDataType = ref1.arrayDataType, functionDataType = ref1.functionDataType, dateDataType = ref1.dateDataType, anyDataType = ref1.anyDataType, jsonDataType = ref1.jsonDataType;

  validStatus = require('art-communication-status').validStatus;

  isId = function(v) {
    return isString(v) && v.match(/^[-_a-z0-9]{1,100}$/i);
  };

  isHexColor = function(v) {
    return /^#([a-f0-9]{3})|([a-f0-9]{6})/i.test("" + v);
  };


  /*
  standard FieldType props:
    validate: (v) -> true/false
    preprocess: (v1) -> v2
    required: true/false
    dataType: one of @DataTypes, default: 'string'
  
  You can add your own, too, but they are ignored by this class.
   */

  module.exports = FieldTypes = {
    count: {
      fromString: numberFromString = function(v) {
        return v - 0;
      },
      dataType: numberDataType,
      "default": 0
    },
    boolean: {
      dataType: booleanDataType,
      fromString: function(v) {
        return !!/^ *t *$|true/i.test(v);
      }
    },
    number: {
      dataType: numberDataType,
      fromString: numberFromString
    },
    string: {
      dataType: stringDataType
    },
    object: {
      dataType: objectDataType
    },
    array: {
      dataType: arrayDataType
    },
    any: {
      dataType: anyDataType
    },
    json: {
      dataType: jsonDataType,
      fromString: function(v) {
        return JSON.parse(v);
      }
    },
    id: {
      required: true,
      validate: function(v) {
        return isId(v);
      }
    },
    date: {
      fromString: function(v) {
        return Date.parse(v);
      },
      validate: function(v) {
        if (v instanceof Date) {
          return !isNaN(v - 0);
        } else {
          return isString(v);
        }
      },
      preprocess: function(v) {
        if (isString(v)) {
          return new Date(v);
        } else {
          return v;
        }
      },
      dataType: dateDataType
    },
    timestamp: {
      fromString: function(v) {
        return toMilliseconds(v);
      },
      dataType: numberDataType,
      validate: function(v) {
        return isNumber(v) || isDate(v);
      },
      preprocess: toMilliseconds,
      decode: toDate
    },
    secondsTimestamp: {
      dataType: numberDataType,
      fromString: function(v) {
        return toSeconds(v);
      },
      validate: function(v) {
        return isNumber(v) || isDate(v);
      },
      preprocess: function(v) {
        return toSeconds(v) + .5 | 0;
      },
      decode: toDate
    },
    fractionalSecondsTimestamp: {
      dataType: numberDataType,
      fromString: function(v) {
        return toSeconds(v);
      },
      validate: function(v) {
        return isNumber(v) || isDate(v);
      },
      preprocess: function(v) {
        return toSeconds(v);
      },
      decode: toDate
    },
    color: {
      validate: function(v) {
        return isHexColor(v);
      },
      preprocess: function(v) {
        return "" + v;
      }
    },
    email: {
      validate: function(v) {
        return isString(v) && v.trim().match(emailRegexp);
      },
      preprocess: function(v) {
        return lowerCase(v.trim());
      }
    },
    url: {
      validate: function(v) {
        return isString(v) && v.match(urlRegexp);
      },
      preprocess: function(v) {
        return normalizeUrl(v);
      }
    },
    communicationStatus: {
      validate: function(v) {
        return validStatus(v);
      }
    },
    trimmedString: {
      validate: function(v) {
        return isString(v);
      },
      preprocess: function(v) {
        v = v.trim();
        return v.length > 0 && v;
      },
      maxLength: 1024
    },
    username: {
      minLength: 3,
      maxLength: 30,
      present: true,
      validate: function(v) {
        return isString(v) && /^\s*\w+\s*$/i.test(v);
      },
      preprocess: function(v) {
        return lowerCase(v.trim());
      }
    },
    "function": {
      dataType: functionDataType
    }
  };

  for (k in FieldTypes) {
    v = FieldTypes[k];
    v.fieldType = k;
    v.dataType || (v.dataType = stringDataType);
    v.validate || (v.validate = DataTypes[v.dataType].validate);
  }

}).call(this);

//# sourceMappingURL=FieldTypes.js.map
