"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["test", "assert", "Validator", "w", "isArray", "isString"], [global, require('../StandardImport')], (test, assert, Validator, w, isArray, isString) => {test("can't be array and fields", function() {return assert.rejects(() => new Validator({idList: {array: "number", fields: {name: "string"}}}));}); test("array-basic", function() {let v; v = new Validator({idList: {array: "number"}}); v.validate({idList: []}); v.validate({idList: [1]}); v.validate({idList: [1, 2, 3]}); v.validate({idList: [1, null, 3]}); v.validate({idList: null}); assert.throws(() => v.validate({idList: 123})); assert.throws(() => v.validate({idList: ["string-not-ok"]})); assert.throws(() => v.validate({idList: [{}]})); return assert.throws(() => v.validate({idList: [[]]}));}); test("validate array with required number elements", function() {let v; v = new Validator({ids: {array: "required number"}}); v.validate({}); v.validate({ids: null}); v.validate({ids: [1, 2]}); return assert.rejects(() => v.validate({ids: [1, null, 2]})).then((_with) => assert.match(_with.stack, /ids\[1\].*\bnot\b.*\bvalid/i));}); test("validate array with multiple validation failures", function() {let v; v = new Validator({ids: {array: "required number"}}); return assert.rejects(() => v.validate({ids: [1, null, "wrong"]})).then((_with) => assert.match(_with.stack, /ids\[1\].*and.*ids\[2\].*\bnot\b.*\bvalid/i));}); test("maxLength on array", function() {let v; v = new Validator({idList: {maxLength: 3, array: {fieldType: "number"}}}); v.validate({idList: [1, 2]}); v.validate({idList: [1, 2, 3]}); return assert.throws(() => v.validate({idList: [1, 2, 3, 4]}));}); test("maxLength on array is after preprocess", function() {let v; v = new Validator({idList: {maxLength: 3, array: {fieldType: "number"}}}); v.validate({idList: [1, 2]}); return assert.throws(() => v.validate({idList: [1, 2, 3, 4]}));}); test("maxLength on array value", function() {let v; v = new Validator({idList: {array: {maxLength: 3, fieldType: "string"}}}); v.validate({idList: ["1", "2"]}); return assert.throws(() => v.validate({idList: ["1", "2", "way-too-long"]}));}); test("minLength", function() {let v; v = new Validator({idList: {minLength: 3, array: {fieldType: "number"}}}); v.validate({idList: [1, 2, 3]}); v.validate({idList: [1, 2, 3, 4]}); return assert.throws(() => v.validate({idList: [1, 2]}));}); test("customValidate", function() {let v; v = new Validator({idList: {array: "number", validate: (a) => 10 === Caf.reduce(a, (sum, v) => sum + v, null, 0)}}); v.validate({idList: [1, 2, 3, 4]}); v.validate({idList: [10]}); v.validate({idList: [6, 4]}); return assert.throws(() => v.validate({idList: [1, 2]}));}); test("customPreprocess", function() {let v; v = new Validator({idList: {array: "string", preprocess: (a) => w(a), validate: (a) => isArray(a) || isString(a)}}); v.validate({idList: "a b c"}); v.validate({idList: ["a", "b", "c"]}); return assert.eq(v.preprocess({idList: "a b c"}), {idList: ["a", "b", "c"]});}); test("array-of-objects", function() {let v; v = new Validator({recordList: {array: {fields: {id: "string", count: "number"}}}}); v.validate({recordList: [{id: "a1", count: 10}, {id: "a2", count: 20}]}); assert.throws(() => v.validate({recordList: [123]})); return assert.throws(() => v.validate({recordList: [{id: "a1", count: "aString"}, {id: "a2", count: 20}]}));}); return test("array-of-arrays", function() {let v; v = new Validator({matrix: {length: 3, array: {length: 3, array: "number"}}}); v.validate({matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}); assert.throws(() => v.validate({matrix: [[1, 2, 3, 4], [4, 5, 6], [7, 8, 9]]})); assert.throws(() => v.validate({matrix: [[1, 2, 3], [4, 5, 6]]})); return assert.throws(() => v.validate({matrix: [[1, 2, 3], [4, 5], [7, 8, 9]]}));});});});
//# sourceMappingURL=SubArrayValidation.test.js.map
