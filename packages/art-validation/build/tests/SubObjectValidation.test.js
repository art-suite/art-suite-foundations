"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["test", "Validator", "assert"], [global, require('./StandardImport')], (test, Validator, assert) => {test("fields", function() {let v; v = new Validator({dimensions: {fields: {x: "number", y: "number"}}}); v.validate({dimensions: {x: 1}}); v.validate({dimensions: {}}); v.validate({dimensions: null}); v.validate({dimensions: undefined}); assert.throws(() => v.validate({dimensions: "not a string"})); assert.throws(() => v.validate({dimensions: 1})); assert.throws(() => v.validate({dimensions: []})); assert.throws(() => v.validate({dimensions: {x: "not a string"}})); return assert.throws(() => v.validate({dimensions: {z: 1}}));}); test("sub-object required", function() {let v; v = new Validator({dimensions: {required: {fields: {x: "number", y: "number"}}}}); assert.throws(() => v.validate({dimensions: null})); return assert.throws(() => v.validate({dimensions: undefined}));}); test("object's fields required", function() {let v; v = new Validator({dimensions: {fields: {x: {required: "number"}, y: "number"}}}); v.validate({dimensions: {x: 1, y: 1}}); return assert.throws(() => v.validate({dimensions: {y: 1}}));}); test("preprocess", function() {let v; v = new Validator({normalFoo: {preprocess: (v) => v.trim()}, myFields: {required: {fields: {foo: {preprocess: (v) => v.trim()}}}}}); return assert.eq({myFields: {foo: "hi"}, normalFoo: "hi"}, v.validate({myFields: {foo: "   hi   "}, normalFoo: " hi "}));}); test("validate object type", function() {let v; v = new Validator({user: {fields: {name: "string"}}}); v.validate({user: {name: "frank"}}); return assert.rejects(() => v.validate({user: {name: {}}})).then((_with) => assert.match(_with.stack, /user.*failed.*validation/));}); test("validate object type required field", function() {let v; v = new Validator({user: {fields: {name: ["required", "string"]}}}); v.validate({user: {name: "frank"}}); return assert.rejects(() => v.validate({user: {}})).then((_with) => assert.match(_with.stack, /user.*failed.*validation/));}); return test("double nested", function() {let v; v = new Validator({post: {fields: {user: {fields: {name: ["required", "string"]}}}}}); v.validate({post: {user: {name: "frank"}}}); return assert.rejects(() => v.validate({post: {user: {name: 123}}})).then((_with) => assert.match(_with.stack, /post.*failed.*validation/));});});});
//# sourceMappingURL=SubObjectValidation.test.js.map
