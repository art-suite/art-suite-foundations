"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "describe", "assert", "peek", "isString", "formattedInspect", "Error", "test", "Object", "Array", "isFunction", "Function", "FieldTypes", "merge", "normalizeFields", "chainedTest"], [global, require('./StandardImport')], (Validator, describe, assert, peek, isString, formattedInspect, Error, test, Object, Array, isFunction, Function, FieldTypes, merge, normalizeFields, chainedTest) => {let normalizeFieldProps, assertIsTrimmedString, cleanStackAndThrow, normalizeArgsAndName, testEqNormalizeFieldProps, testEqNormalizeFieldPropsWithFunctionsIdentified, assertDefinitionEq, stripFunctions, identifyFunctions; ({normalizeFieldProps} = Validator); assertIsTrimmedString = function(ft) {assert.eq(ft.dataType, "string"); assert.isFunction(ft.validate); return assert.isFunction(ft.preprocess);}; cleanStackAndThrow = function(stack, error) {let mergedStack; stack = Caf.array(stack.split(/\n/)).join("\n"); mergedStack = Caf.array(`${Caf.toString(error.stack)}\n${Caf.toString(stack)}`.split(/\n/), null, (line) => /testEqNormalizeFieldProps/.test(line)).join("\n").split("at describe"); error.stack = peek(mergedStack); return (() => {throw error;})();}; normalizeArgsAndName = function(args) {let name, testInput, shouldEqualOutput, validatorOptions; if (args.length >= 3 && isString(args[0])) {([name, testInput, shouldEqualOutput, validatorOptions] = args);} else {([testInput, shouldEqualOutput, validatorOptions] = args); name = `${Caf.toString(formattedInspect(testInput).replace(/\n/g, ", "))} >>> ${Caf.toString(formattedInspect(shouldEqualOutput).replace(/\n/g, ", "))}`;}; return {name, testInput, shouldEqualOutput, validatorOptions};}; testEqNormalizeFieldProps = function(...args) {let stack, name, testInput, shouldEqualOutput, validatorOptions; ({stack} = new Error); ({name, testInput, shouldEqualOutput, validatorOptions} = normalizeArgsAndName(args)); return test(name, () => {let error; return (() => {try {return assertDefinitionEq(testInput, shouldEqualOutput, stripFunctions, validatorOptions);} catch (error1) {error = error1; return cleanStackAndThrow(stack, error);};})();});}; testEqNormalizeFieldPropsWithFunctionsIdentified = function(...args) {let stack, name, testInput, shouldEqualOutput, validatorOptions; ({stack} = new Error); ({name, testInput, shouldEqualOutput, validatorOptions} = normalizeArgsAndName(args)); return test(name, () => {let error; return (() => {try {return assertDefinitionEq(testInput, shouldEqualOutput, identifyFunctions, validatorOptions);} catch (error1) {error = error1; return cleanStackAndThrow(stack, error);};})();});}; assertDefinitionEq = function(a, b, cleanThings, validatorOptions) {return assert.eq(cleanThings(normalizeFieldProps(a, validatorOptions)), cleanThings(b), `this:             normalizeFieldProps ${Caf.toString(formattedInspect(a))}\nshould eq:        ${Caf.toString(formattedInspect(b))}\nvalidatorOptions: ${Caf.toString(formattedInspect(validatorOptions))}`);}; stripFunctions = function(o) {return (() => {switch (false) {case !(Caf.is(o, Object)): return Caf.object(o, (v) => stripFunctions(v), (v) => !isFunction(v)); case !(Caf.is(o, Array)): return Caf.array(o, (v) => stripFunctions(v), (v) => !isFunction(v)); default: return o;};})();}; identifyFunctions = function(o) {return (() => {switch (false) {case !(Caf.is(o, Object)): return Caf.object(o, (v) => identifyFunctions(v)); case !(Caf.is(o, Array)): return Caf.array(o, (v) => identifyFunctions(v)); case !(Caf.is(o, Function)): return "function"; default: return o;};})();}; return describe({basicDefinitions: function() {test('fieldType name (e.g. "number") selects the functions for that fieldType', () => assert.eq(normalizeFieldProps("number"), FieldTypes.number)); test('explicit fieldType name (e.g. "number") selects the functions for that fieldType', () => assert.eq(normalizeFieldProps({fieldType: "number"}), FieldTypes.number)); test("just custom functions, returned as-is", () => {let definition; return assert.eq(normalizeFieldProps(definition = {preprocess: (a) => a, validated: (a) => true, postValidated: (a) => true}), definition);}); test("can override fieldType's definition", () => {let definition; return assert.eq(normalizeFieldProps(["number", definition = {preprocess: (a) => a}]), merge(FieldTypes.number, definition));}); test("'required' tag", () => assert.eq(normalizeFieldProps("required"), {required: true})); return test("'present' tag", () => assert.eq(normalizeFieldProps("present"), {present: true}));}, deprecated: {hard: function() {return test("requiredPresent: true", () => assert.throws(() => normalizeFieldProps({requiredPresent: true})));}, soft: function() {testEqNormalizeFieldProps({required: "number"}, {dataType: "number", fieldType: "number", required: true}, {quiet: true}); testEqNormalizeFieldProps({present: "number"}, {dataType: "number", fieldType: "number", present: true}, {quiet: true}); return testEqNormalizeFieldProps({required: ["trimmedString"]}, {required: ["trimmedString"]});}}, invalid: function() {test("explicit, unknown field type is an error", () => assert.rejects(() => normalizeFieldProps({fieldType: "unknownFieldType"})).then((rejectsWith) => assert.match(rejectsWith.message, /unknown.*unknownFieldType/i))); return test("sub-object with unknown field-type", () => assert.rejects(() => normalizeFieldProps({fields: {data: {fieldType: "unknownFieldType"}}})).then((rejectsWith) => assert.match(rejectsWith.message, /unknown.*unknownFieldType/i)));}, tags: {"unknown-field-types-are-treated-as-tags": function() {return testEqNormalizeFieldProps("unknownFieldType", {unknownFieldType: true});}, asObjectProperties: function() {testEqNormalizeFieldProps({required: true}, {required: true}); return testEqNormalizeFieldProps({present: true}, {present: true});}, asSimpleStrings: function() {testEqNormalizeFieldProps("required", {required: true}); return testEqNormalizeFieldProps("present", {present: true});}, asArrays: function() {testEqNormalizeFieldProps(["required", "present"], {required: true, present: true}); testEqNormalizeFieldProps(["required", "number"], {dataType: "number", fieldType: "number", required: true}); return testEqNormalizeFieldProps(["required", "present", "number"], {dataType: "number", fieldType: "number", required: true, present: true});}, asCompoundStrings: function() {testEqNormalizeFieldProps("required present", {required: true, present: true}); testEqNormalizeFieldProps("required number", {dataType: "number", fieldType: "number", required: true}); return testEqNormalizeFieldProps("required present number", {dataType: "number", fieldType: "number", required: true, present: true});}, tagsCanBeMixedWithCustomProps: function() {testEqNormalizeFieldProps("fieldType then object-props", ["trimmedString", {foo: true, bar: true}], normalizeFieldProps({foo: true, bar: true, fieldType: "trimmedString"})); return testEqNormalizeFieldProps("alternating tags and object-props", ["present", {foo: true}, "required", {bar: true}, "trimmedString"], normalizeFieldProps({foo: true, bar: true, fieldType: "trimmedString", required: true, present: true}));}}, "properties-on-a-custom-field-are-not-interpreted": function() {testEqNormalizeFieldProps({foobar: "number"}, {foobar: "number"}); testEqNormalizeFieldProps({foobar: {required: true}}, {foobar: {required: true}}); return testEqNormalizeFieldProps({foobar: {required: "number"}}, {foobar: {required: "number"}});}, nestedObjectAndArrayFields: function() {testEqNormalizeFieldProps("arrays", {array: "number"}, {dataType: "array", fieldType: "array", array: {dataType: "number", fieldType: "number"}}); testEqNormalizeFieldProps("objects", {fields: {myCustomSubField: "string"}}, {dataType: "object", fieldType: "object", fields: {myCustomSubField: {dataType: "string", fieldType: "string"}}}); testEqNormalizeFieldProps("arrays of objects", {array: {fields: {myCustomSubField: "string"}}}, {dataType: "array", fieldType: "array", array: {dataType: "object", fieldType: "object", fields: {myCustomSubField: {dataType: "string", fieldType: "string"}}}}); return testEqNormalizeFieldProps("object with array field", {fields: {coordinates: {array: "number"}}}, {dataType: "object", fieldType: "object", fields: {coordinates: {dataType: "array", fieldType: "array", array: {dataType: "number", fieldType: "number"}}}});}, buildInValidators: function() {testEqNormalizeFieldPropsWithFunctionsIdentified({instanceof: Validator}, {instanceof: "function", validate: "function"}); testEqNormalizeFieldPropsWithFunctionsIdentified({minLength: 5}, {minLength: 5, postValidate: "function"}); testEqNormalizeFieldPropsWithFunctionsIdentified({maxLength: 5}, {maxLength: 5, postValidate: "function"}); return testEqNormalizeFieldPropsWithFunctionsIdentified({length: 5}, {length: 5, maxLength: 5, minLength: 5, postValidate: "function"});}, customFieldTypes: {basic: function() {test("mapped to another fieldType", () => assert.eq(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: "string"}}), merge(normalizeFieldProps("string"), {fieldType: "myCustomField"}))); test("mapped to an object definition", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: {fields: {myCustomSubField: "string"}}}})), {dataType: "object", fieldType: "myCustomField", fields: {myCustomSubField: {dataType: "string", fieldType: "string"}}})); return test("normalizeFields accepts custom fields", () => assert.eq(normalizeFields({foo: "myCustomField"}, {customFieldTypes: {myCustomField: "string"}}), {foo: merge(normalizeFieldProps("string"), {fieldType: "myCustomField"})}));}, recursiveTypesWithCustomFieldTypes: function() {test("object", () => assert.eq(stripFunctions(normalizeFieldProps({fields: {data: "record"}}, {customFieldTypes: {record: {fields: {name: "string"}}}})), {dataType: "object", fieldType: "object", fields: {data: {dataType: "object", fieldType: "record", fields: {name: {dataType: "string", fieldType: "string"}}}}})); return test("array", () => assert.eq(stripFunctions(normalizeFieldProps({array: "record"}, {customFieldTypes: {record: {fields: {name: "string"}}}})), {dataType: "array", fieldType: "array", array: {fieldType: "record", dataType: "object", fields: {name: {dataType: "string", fieldType: "string"}}}}));}, recursiveCustomFieldTypes: function() {test("a references b", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: "myCustomField2", myCustomField2: "string"}})), {fieldType: "myCustomField", dataType: "string"})); test("a references object with b", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: {fields: {myFieldName: "myCustomField2"}}, myCustomField2: "string"}})), {fieldType: "myCustomField", dataType: "object", fields: {myFieldName: {dataType: "string", fieldType: "myCustomField2"}}})); chainedTest("a references a not allowed", () => assert.rejects(() => stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: "myCustomField"}}))).then((rejectsWith) => assert.match(rejectsWith.message, /recursive.*not supported/i))).thenTest("after a failed recursion check, we don't wrongly trigger it again", () => stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: {fields: {myFieldName: "string"}}}}))); test("a references object a not allowed", () => assert.rejects(() => stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: {fields: {myFieldName: "myCustomField"}}}}))).then((rejectsWith) => assert.match(rejectsWith.message, /recursive.*not supported/i))); return test("a references b refernces a not allowed", () => assert.rejects(() => stripFunctions(normalizeFieldProps("myCustomField", {customFieldTypes: {myCustomField: {fields: {myFieldName: "myCustomField2"}}, myCustomField2: {fields: {myFieldName: "myCustomField"}}}}))).then((rejectsWith) => assert.match(rejectsWith.message, /recursive.*not supported/i)));}}, regressions: {art_pipelines_link_fields_filter: function() {test("'link required'", () => assert.eq(stripFunctions(normalizeFieldProps("link required")), {link: true, required: true})); test("link: 'user'", () => assert.eq(stripFunctions(normalizeFieldProps({link: "user"})), {link: "user"})); return test("each", () => {let Foo; return normalizeFields({type: {required: {fieldType: "string"}}, session: {required: {fieldType: "object"}}, parentRequest: {instanceof: Foo = Caf.defClass(class Foo extends Object {})}, originatedOnServer: "boolean", props: "object", key: "string"}, {quiet: true});});}, art_pipelines: function() {return testEqNormalizeFieldProps({fields: {data: "record"}}, {fields: {data: {fields: {name: {dataType: "string", fieldType: "string"}}, dataType: "object", fieldType: "record"}}, dataType: "object", fieldType: "object"}, {customFieldTypes: {record: {fields: {name: "string"}}}});}, array_and_lengths: function() {testEqNormalizeFieldProps("length-tests on the array itself", {array: "string", maxLength: 10}, {dataType: "array", fieldType: "array", array: {dataType: "string", fieldType: "string"}, maxLength: 10}); return testEqNormalizeFieldProps("length-tests on elements within the array", {array: ["string", {maxLength: 10}]}, {dataType: "array", fieldType: "array", array: {dataType: "string", fieldType: "string", maxLength: 10}});}}});});});
//# sourceMappingURL=normalizeFieldProps.test.js.map
