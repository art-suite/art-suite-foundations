"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "describe", "assert", "test", "formattedInspect", "Object", "Array", "Function", "w", "merge", "normalizeFields"], [global, require('./StandardImport')], (Validator, describe, assert, test, formattedInspect, Object, Array, Function, w, merge, normalizeFields) => {let normalizeFieldProps, assertIsTrimmedString, testEq, stripFunctions; ({normalizeFieldProps} = Validator); assertIsTrimmedString = function(ft) {assert.eq(ft.dataType, "string"); assert.isFunction(ft.validate); return assert.isFunction(ft.preprocess);}; testEq = function(f, a, b) {return test(`${Caf.toString(f.name)} ${Caf.toString(formattedInspect(a))} should-eq ${Caf.toString(formattedInspect(b))}`, () => assert.eq(stripFunctions(f(a)), stripFunctions(b)));}; stripFunctions = function(o) {return (() => {switch (false) {case !(Caf.is(o, Object)): return Caf.object(o, (v) => stripFunctions(v)); case !(Caf.is(o, Array)): return Caf.array(o, (v) => stripFunctions(v)); case !(Caf.is(o, Function)): return "function"; default: return o;};})();}; return describe({basic: function() {testEq(normalizeFieldProps, {required: true}, {required: true}); testEq(normalizeFieldProps, {dood: "trimmedString"}, {dood: "trimmedString"}); return testEq(normalizeFieldProps, {required: ["trimmedString"]}, {required: ["trimmedString"]});}, depricated: function() {test("requiredPresent: true", () => assert.throws(() => normalizeFieldProps({requiredPresent: true}))); test("required: 'foo'", () => assert.throws(() => normalizeFieldProps({required: "foo"}))); return test("present: 'foo'", () => assert.throws(() => normalizeFieldProps({present: "foo"})));}, objectValues: function() {testEq(normalizeFieldProps, {required: {foobar: true}}, {required: true, foobar: true}); return testEq(normalizeFieldProps, {foobar: {required: true}}, {required: true, foobar: true});}, topLevelArrayValues: function() {testEq(normalizeFieldProps, [w("foobar")], {foobar: true}); testEq(normalizeFieldProps, [w("required foobar")], {required: true, foobar: true}); return testEq(normalizeFieldProps, [w("required foobar", {fad: 123})], {required: true, foobar: true, fad: 123});}, topLevelStringValues: function() {testEq(normalizeFieldProps, "foobar", {foobar: true}); testEq(normalizeFieldProps, "foo bar", {foo: true, bar: true}); test("'trimmedString'", () => assertIsTrimmedString(normalizeFieldProps("trimmedString"))); return test("'trimmedString foo bar'", () => {let ft; ft = normalizeFieldProps("trimmedString foo bar"); assertIsTrimmedString(ft); assert.eq(true, ft.foo); return assert.eq(true, ft.bar);});}, nestedTypes: {arrays: function() {return testEq(normalizeFieldProps, {array: "number"}, {array: {dataType: "number", fromString: "function", fieldType: "number", validate: "function"}, validate: "function", preprocess: "function", postValidate: "function"});}, objects: function() {return testEq(normalizeFieldProps, {fields: {myCustomSubField: "string"}}, {dataType: "object", fieldType: "object", validate: "function", fields: {myCustomSubField: {dataType: "string", fieldType: "string", validate: "function"}}, preprocess: "function", postValidate: "function"});}}, specialFields: function() {test("fieldType: 'trimmedString'", () => assertIsTrimmedString(normalizeFieldProps({fieldType: "trimmedString"}))); return test("instanceof: Validator", () => {let ft; ft = normalizeFieldProps({instanceof: Validator}); assert.eq(true, ft.validate(new Validator)); return assert.eq(false, ft.validate({}));});}, customFieldTypes: function() {test("mapped to another fieldType", () => assert.eq(normalizeFieldProps("myCustomField", {myCustomField: "string"}), merge(normalizeFieldProps("string"), {fieldType: "myCustomField"}))); test("mapped to an object definition", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: {fields: {myCustomSubField: "string"}}})), {dataType: "object", fieldType: "myCustomField", validate: "function", fields: {myCustomSubField: {dataType: "string", fieldType: "string", validate: "function"}}, preprocess: "function", postValidate: "function"})); return test("normalizeFields accepts custom fields", () => assert.eq(normalizeFields({foo: "myCustomField"}, {myCustomField: "string"}), {foo: merge(normalizeFieldProps("string"), {fieldType: "myCustomField"})}));}});});});
//# sourceMappingURL=normalizeFieldProps.test.js.map
