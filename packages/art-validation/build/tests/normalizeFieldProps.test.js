"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "describe", "assert", "test", "formattedInspect", "Object", "Array", "isFunction", "merge", "normalizeFields", "chainedTest"], [global, require('./StandardImport')], (Validator, describe, assert, test, formattedInspect, Object, Array, isFunction, merge, normalizeFields, chainedTest) => {let normalizeFieldProps, assertIsTrimmedString, testEqNormalizeFieldProps, stripFunctions; ({normalizeFieldProps} = Validator); assertIsTrimmedString = function(ft) {assert.eq(ft.dataType, "string"); assert.isFunction(ft.validate); return assert.isFunction(ft.preprocess);}; testEqNormalizeFieldProps = function(a, b) {return test(`${Caf.toString(formattedInspect({inputs: a, outputs: stripFunctions(b)}))}`, () => assert.eq(stripFunctions(normalizeFieldProps(a)), stripFunctions(b), `this:       normalizeFieldProps ${Caf.toString(formattedInspect(a))}\nshould eq:  ${Caf.toString(formattedInspect(b))}`));}; stripFunctions = function(o) {return (() => {switch (false) {case !(Caf.is(o, Object)): return Caf.object(o, (v) => stripFunctions(v), (v) => !isFunction(v)); case !(Caf.is(o, Array)): return Caf.array(o, (v) => stripFunctions(v), (v) => !isFunction(v)); default: return o;};})();}; return describe({basic: function() {testEqNormalizeFieldProps("number", {dataType: "number", fieldType: "number"}); testEqNormalizeFieldProps({required: true}, {required: true}); testEqNormalizeFieldProps({required: "number"}, {dataType: "number", fieldType: "number", required: true}); testEqNormalizeFieldProps({present: "number"}, {dataType: "number", fieldType: "number", present: true}); testEqNormalizeFieldProps({dood: "number"}, {dood: "number"}); return testEqNormalizeFieldProps({required: ["trimmedString"]}, {required: ["trimmedString"]});}, deprecated: function() {return test("requiredPresent: true", () => assert.throws(() => normalizeFieldProps({requiredPresent: true})));}, invalid: function() {return test("normalizeFieldProps 'unknownFieldTypeTag' (an unknown field-type tag)", () => {normalizeFieldProps("number"); normalizeFieldProps("required number"); assert.throws(() => normalizeFieldProps("unknownFieldTypeTag")); assert.throws(() => normalizeFieldProps("number unknownFieldTypeTag")); return assert.throws(() => normalizeFieldProps("unknownFieldTypeTag number"));});}, objectValues: function() {testEqNormalizeFieldProps({required: {foobar: true}}, {required: true, foobar: true}); testEqNormalizeFieldProps({required: {foobar: "123"}}, {required: true, foobar: "123"}); return testEqNormalizeFieldProps({foobar: {required: true}}, {foobar: {required: true}});}, declarationSequences: function() {}, topLevelArrayValues: function() {testEqNormalizeFieldProps(["required", "number"], {required: true, dataType: "number", fieldType: "number"}); return testEqNormalizeFieldProps(["required", "number", {fad: 123}], {required: true, dataType: "number", fieldType: "number", fad: 123});}, multipleTagsInString: function() {testEqNormalizeFieldProps("required number", {dataType: "number", fieldType: "number", required: true}); return testEqNormalizeFieldProps("required present", {required: true, present: true});}, tagsCanBeMixedWithCustomProps: function() {testEqNormalizeFieldProps(["trimmedString", {foo: true, bar: true}], normalizeFieldProps({foo: true, bar: true, fieldType: "trimmedString"})); return testEqNormalizeFieldProps(["present", {foo: true}, "required", {bar: true}, "trimmedString"], normalizeFieldProps({foo: true, bar: true, fieldType: "trimmedString", required: true, present: true}));}, nestedTypes: {arrays: function() {return testEqNormalizeFieldProps({array: "number"}, {array: {dataType: "number", fieldType: "number"}});}, objects: function() {return testEqNormalizeFieldProps({fields: {myCustomSubField: "string"}}, {dataType: "object", fieldType: "object", fields: {myCustomSubField: {dataType: "string", fieldType: "string"}}});}}, specialFieldTypes: function() {return testEqNormalizeFieldProps({fieldType: "trimmedString"}, {maxLength: 1024, fieldType: "trimmedString", dataType: "string"});}, specialProprties: function() {return test("instanceof: Validator", () => {let ft; ft = normalizeFieldProps({instanceof: Validator}); assert.true(ft.validate(new Validator)); return assert.false(ft.validate({}));});}, customFieldTypes: function() {test("mapped to another fieldType", () => assert.eq(normalizeFieldProps("myCustomField", {myCustomField: "string"}), merge(normalizeFieldProps("string"), {fieldType: "myCustomField"}))); test("mapped to an object definition", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: {fields: {myCustomSubField: "string"}}})), {dataType: "object", fieldType: "myCustomField", fields: {myCustomSubField: {dataType: "string", fieldType: "string"}}})); return test("normalizeFields accepts custom fields", () => assert.eq(normalizeFields({foo: "myCustomField"}, {myCustomField: "string"}), {foo: merge(normalizeFieldProps("string"), {fieldType: "myCustomField"})}));}, recursiveTypesWithCustomFieldTypes: function() {test("object", () => assert.eq(stripFunctions(normalizeFieldProps({fields: {data: "record"}}, {record: {fields: {name: "string"}}})), {dataType: "object", fieldType: "object", fields: {data: {dataType: "object", fieldType: "record", fields: {name: {dataType: "string", fieldType: "string"}}}}})); return test("array", () => assert.eq(stripFunctions(normalizeFieldProps({array: "record"}, {record: {fields: {name: "string"}}})), {array: {fieldType: "record", dataType: "object", fields: {name: {dataType: "string", fieldType: "string"}}}}));}, recursiveCustomFieldTypes: function() {test("a references b", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: "myCustomField2", myCustomField2: "string"})), {fieldType: "myCustomField", dataType: "string"})); test("a references object with b", () => assert.eq(stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: {fields: {myFieldName: "myCustomField2"}}, myCustomField2: "string"})), {fieldType: "myCustomField", dataType: "object", fields: {myFieldName: {dataType: "string", fieldType: "myCustomField2"}}})); chainedTest("a references a not allowed", () => assert.rejects(() => stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: "myCustomField"}))).then((rejectsWith) => assert.match(rejectsWith.message, /recursive.*not supported/i))).thenTest("after a failed recursion check, we don't wrongly trigger it again", () => stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: {fields: {myFieldName: "string"}}}))); test("a references object a not allowed", () => assert.rejects(() => stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: {fields: {myFieldName: "myCustomField"}}}))).then((rejectsWith) => assert.match(rejectsWith.message, /recursive.*not supported/i))); return test("a references b refernces a not allowed", () => assert.rejects(() => stripFunctions(normalizeFieldProps("myCustomField", {myCustomField: {fields: {myFieldName: "myCustomField2"}}, myCustomField2: {fields: {myFieldName: "myCustomField"}}}))).then((rejectsWith) => assert.match(rejectsWith.message, /recursive.*not supported/i)));}, downstream_dependency_regressions: function() {return test("link: 'user'", () => assert.eq(stripFunctions(normalizeFieldProps({link: "user"})), {link: "user"}));}});});});
//# sourceMappingURL=normalizeFieldProps.test.js.map
