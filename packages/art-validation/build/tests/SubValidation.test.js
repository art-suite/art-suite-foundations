"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["describe", "test", "Validator", "assert", "w", "isArray", "isString"], [global, require('./StandardImport')], (describe, test, Validator, assert, w, isArray, isString) => {return describe({arrayValidation: function() {test("array-basic", () => {let v; v = new Validator({idList: {array: "number"}}); v.validate({idList: []}); v.validate({idList: [1]}); v.validate({idList: [1, 2, 3]}); v.validate({idList: [1, null, 3]}); v.validate({idList: null}); assert.throws(() => v.validate({idList: 123})); assert.throws(() => v.validate({idList: ["string-not-ok"]})); assert.throws(() => v.validate({idList: [{}]})); return assert.throws(() => v.validate({idList: [[]]}));}); test("validate array with required number elements", () => {let v; v = new Validator({ids: {array: "required number"}}); v.validate({}); v.validate({ids: null}); v.validate({ids: [1, 2]}); return assert.rejects(() => v.validate({ids: [1, null, 2]})).then((_with) => assert.match(_with.stack, /invalid ids/));}); test("maxLength", () => {let v; v = new Validator({idList: {array: {maxLength: 3, fieldType: "number"}}}); v.validate({idList: [1, 2]}); v.validate({idList: [1, 2, 3]}); return assert.throws(() => v.validate({idList: [1, 2, 3, 4]}));}); test("minLength", () => {let v; v = new Validator({idList: {array: {minLength: 3, fieldType: "number"}}}); v.validate({idList: [1, 2, 3]}); v.validate({idList: [1, 2, 3, 4]}); return assert.throws(() => v.validate({idList: [1, 2]}));}); test("customValidate", () => {let v; v = new Validator({idList: {array: "number", validate: (a) => 10 === Caf.reduce(a, (sum, v) => sum + v, null, 0)}}); v.validate({idList: [1, 2, 3, 4]}); v.validate({idList: [10]}); v.validate({idList: [6, 4]}); return assert.throws(() => v.validate({idList: [1, 2]}));}); test("customPreprocess", () => {let v; v = new Validator({idList: {array: "string", preprocess: (a) => w(a), validate: (a) => isArray(a) || isString(a)}}); v.validate({idList: "a b c"}); v.validate({idList: ["a", "b", "c"]}); return assert.eq(v.preprocess({idList: "a b c"}), {idList: ["a", "b", "c"]});}); test("array-of-objects", () => {let v; v = new Validator({recordList: {array: {fields: {id: "string", count: "number"}}}}); v.validate({recordList: [{id: "a1", count: 10}, {id: "a2", count: 20}]}); assert.throws(() => v.validate({recordList: [123]})); return assert.throws(() => v.validate({recordList: [{id: "a1", count: "aString"}, {id: "a2", count: 20}]}));}); return test("array-of-arrays", () => {let v; v = new Validator({matrix: {array: {length: 3, array: ["number", {length: 3}]}}}); v.validate({matrix: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}); assert.throws(() => v.validate({matrix: [[1, 2, 3, 4], [4, 5, 6], [7, 8, 9]]})); assert.throws(() => v.validate({matrix: [[1, 2, 3], [4, 5, 6]]})); return assert.throws(() => v.validate({matrix: [[1, 2, 3], [4, 5], [7, 8, 9]]}));});}, object: function() {test("fields", () => {let v; v = new Validator({dimensions: {fields: {x: "number", y: "number"}}}); v.validate({dimensions: {x: 1}}); v.validate({dimensions: {}}); v.validate({dimensions: null}); v.validate({dimensions: undefined}); assert.throws(() => v.validate({dimensions: "not a string"})); assert.throws(() => v.validate({dimensions: 1})); assert.throws(() => v.validate({dimensions: []})); assert.throws(() => v.validate({dimensions: {x: "not a string"}})); return assert.throws(() => v.validate({dimensions: {z: 1}}));}); test("required fields", () => {let v; v = new Validator({dimensions: {required: {fields: {x: "number", y: "number"}}}}); assert.throws(() => v.validate({dimensions: null})); return assert.throws(() => v.validate({dimensions: undefined}));}); test("preprocess", () => {let v; v = new Validator({normalFoo: {preprocess: (v) => v.trim()}, myFields: {required: {fields: {foo: {preprocess: (v) => v.trim()}}}}}); return assert.eq({myFields: {foo: "hi"}, normalFoo: "hi"}, v.validate({myFields: {foo: "   hi   "}, normalFoo: " hi "}));}); test("validate object type", () => {let v; v = new Validator({user: {fields: {name: "string"}}}); v.validate({user: {name: "frank"}}); return assert.rejects(() => v.validate({user: {name: {}}})).then((_with) => assert.match(_with.stack, /invalid user/));}); test("validate object type required field", () => {let v; v = new Validator({user: {fields: {name: ["required", "string"]}}}); v.validate({user: {name: "frank"}}); return assert.rejects(() => v.validate({user: {}})).then((_with) => assert.match(_with.stack, /invalid user/));}); return test("double nested", () => {let v; v = new Validator({post: {fields: {user: {fields: {name: ["required", "string"]}}}}}); v.validate({post: {user: {name: "frank"}}}); return assert.rejects(() => v.validate({post: {user: {name: 123}}})).then((_with) => assert.match(_with.stack, /invalid post/));});}});});});
//# sourceMappingURL=SubValidation.test.js.map
