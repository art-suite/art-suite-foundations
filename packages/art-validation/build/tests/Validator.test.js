"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Validator", "describe", "assert", "test", "formattedInspect", "w", "isString", "Promise", "findEmailRegexp"], [global, require('./StandardImport')], (Validator, describe, assert, test, formattedInspect, w, isString, Promise, findEmailRegexp) => {let normalizeFieldProps, assertIsTrimmedString, testEq; ({normalizeFieldProps} = Validator); assertIsTrimmedString = function(ft) {assert.eq(ft.dataType, "string"); assert.isFunction(ft.validate); return assert.isFunction(ft.preprocess);}; testEq = function(f, a, b) {return test(`${Caf.toString(f.name)} ${Caf.toString(formattedInspect(a))} should-eq ${Caf.toString(formattedInspect(b))}`, () => assert.eq(f(a), b));}; return describe({normalizeFieldProps: {basic: function() {testEq(normalizeFieldProps, {required: true}, {required: true}); testEq(normalizeFieldProps, {dood: "trimmedString"}, {dood: "trimmedString"}); return testEq(normalizeFieldProps, {required: ["trimmedString"]}, {required: ["trimmedString"]});}, depricated: function() {test("requiredPresent: true", () => assert.throws(() => normalizeFieldProps({requiredPresent: true}))); test("required: 'foo'", () => assert.throws(() => normalizeFieldProps({required: "foo"}))); return test("present: 'foo'", () => assert.throws(() => normalizeFieldProps({present: "foo"})));}, objectValues: function() {testEq(normalizeFieldProps, {required: {foobar: true}}, {required: true, foobar: true}); return testEq(normalizeFieldProps, {foobar: {required: true}}, {required: true, foobar: true});}, topLevelArrayValues: function() {testEq(normalizeFieldProps, [w("foobar")], {foobar: true}); testEq(normalizeFieldProps, [w("required foobar")], {required: true, foobar: true}); return testEq(normalizeFieldProps, [w("required foobar", {fad: 123})], {required: true, foobar: true, fad: 123});}, topLevelStringValues: function() {testEq(normalizeFieldProps, "foobar", {foobar: true}); testEq(normalizeFieldProps, "foo bar", {foo: true, bar: true}); test("'trimmedString'", () => assertIsTrimmedString(normalizeFieldProps("trimmedString"))); return test("'trimmedString foo bar'", () => {let ft; ft = normalizeFieldProps("trimmedString foo bar"); assertIsTrimmedString(ft); assert.eq(true, ft.foo); return assert.eq(true, ft.bar);});}, specialFields: function() {test("fieldType: 'trimmedString'", () => assertIsTrimmedString(normalizeFieldProps({fieldType: "trimmedString"}))); return test("instanceof: Validator", () => {let ft; ft = normalizeFieldProps({instanceof: Validator}); assert.eq(true, ft.validate(new Validator)); return assert.eq(false, ft.validate({}));});}}, new: function() {return test("new Validator", () => new Validator);}, exclusive: function() {test("exclusive only allows declared fields", () => {let v; v = new Validator({id: "trimmedString"}, {exclusive: true}); v.validate({id: "hi"}); assert.throws(() => v.validate({id: "id", foo: "bar"})); assert.throws(() => v.validateUpdate({id: "id", foo: "bar"})); v.validate({id: "id"}); return v.validateUpdate({id: "id"});}); test("inclusive", () => {let v; v = new Validator({id: "trimmedString"}); v.validate({id: "hi"}); v.validate({id: "id", foo: "bar"}); return v.validateUpdate({id: "id", foo: "bar"});}); return test("true is sufficient for declaring expected fields", () => {let v; v = new Validator({id: true, foo: true}, {exclusive: true}); v.validate({id: "hi"}); v.validate({id: "id", foo: "bar"}); return v.validateUpdate({id: "id", foo: "bar"});});}, trimmedString: function() {test("id: 'trimmedString'", () => {let v; v = new Validator({id: "trimmedString"}); v.validate({id: "ok"}); v.validate({}); return assert.throws(() => v.validate({id: 123}));}); test("required: 'trimmedString'", () => {let v; v = new Validator({id: {required: {fieldType: "trimmedString"}}}); v.validate({id: "hi"}); assert.throws(() => v.validate({id: 123})); return assert.throws(() => v.validate());}); return test("requiredPresent: 'trimmedString'", () => {let v; v = new Validator({id: {required: {present: {fieldType: "trimmedString"}}}}); assert.throws(() => [v.validate({id: 123}), "with number"]); assert.throws(() => [v.validate(), "missing"]); assert.throws(() => [v.validate({id: ""}), "id:''"]); assert.throws(() => [v.validate({id: "  "}), "id:'  '"]); return v.validate({id: "hi"});});}, declarationTypes: function() {test("fieldType: 'id'", () => {let v; v = new Validator({id: {fieldType: "id"}}); assert.throws(() => v.validate({})); v.validateUpdate({}); v.validate({id: "123"}); return assert.rejects(() => v.validate({id: 123})).then(({info}) => assert.eq(info.errors, {id: "invalid"}));}); test("validate: ->", () => {let v; v = new Validator({id: {validate: (v) => isString(v)}}); v.validate({}); v.validateUpdate({}); v.validate({id: "123"}); return assert.rejects(() => v.validate({id: 123})).then(({info}) => assert.eq(info.errors, {id: "invalid"}));}); test("preprocess: ->", () => {let v, id; v = new Validator({id: {preprocess: (v) => `${Caf.toString(v)}a`}}); ({id} = v.validateUpdate({id: "123"})); assert.eq(id, "123a"); ({id} = v.validateUpdate({id: 456})); return assert.eq(id, "456a");}); test("present: true", () => {let v; v = new Validator({id: {present: true}}); v.validate({id: "123"}); assert.throws(() => v.validate({id: ""})); assert.throws(() => v.validate({id: null})); assert.throws(() => v.validate({id: undefined})); assert.throws(() => v.validateUpdate({id: ""})); assert.throws(() => v.validateUpdate({id: null})); assert.throws(() => v.validateUpdate({id: undefined})); assert.throws(() => v.validate({id: false})); assert.throws(() => v.validateUpdate({id: false})); v.validate({id: 123}); v.validate({id: "abc"}); v.validateUpdate({id: 123}); return v.validateUpdate({id: "abc"});}); test("required: true", () => {let v; v = new Validator({id: {required: true}}); v.validate({id: 123}); return assert.rejects(() => v.validate({id: null})).then(({info}) => assert.eq(info.errors, {id: "missing"})).then(() => assert.rejects(() => v.validate({id: undefined}))).then(({info}) => assert.eq(info.errors, {id: "missing"}));}); return test("instanceof: Foo", () => {let Foo, Bar, v; Foo = Caf.defClass(class Foo extends Object {}); Bar = Caf.defClass(class Bar extends Foo {}); v = new Validator({foo: {instanceof: Foo}}); Promise.resolve(); v.validate({foo: new Foo}); v.validate({foo: new Bar}); v.validate({foo: null}); return assert.rejects(() => v.validate({foo: {}})).then(({info}) => assert.eq(info.errors, {foo: "invalid"}));});}, defaults: {preUpdate: function() {return test("default: undefined", () => {let v3; v3 = new Validator({count: {fieldType: "number", default: 1}}); return assert.eq({}, v3.validateUpdate({}));});}, preCreate: function() {test("default: 0", () => {let v1; v1 = new Validator({count: {fieldType: "number", default: 0}}); return assert.eq({count: 0}, v1.validate({}));}); test("default: 1, validate {}", () => {let v2; v2 = new Validator({count: {fieldType: "number", default: 1}}); return assert.eq({count: 1}, v2.validate({}));}); test("default: 1, validate()", () => {let v2; v2 = new Validator({count: {fieldType: "number", default: 1}}); return assert.eq({count: 1}, v2.validate());}); test("default: null", () => {let v3; v3 = new Validator({count: {fieldType: "number", default: null}}); return assert.eq({count: null}, v3.validate({}));}); test("default: undefined", () => {let v3; v3 = new Validator({count: {fieldType: "number", default: undefined}}); return assert.eq({}, v3.validate({}));}); return test("default applied before preprocess", () => {let v1; v1 = new Validator({text: {fieldType: "trimmedString", default: " hi "}}); return assert.eq({text: "hi"}, v1.validate({}));});}}, compoundTests: function() {return test("require: validate: ->", () => {let v; v = new Validator({foo: {required: {validate: (v) => v.match(RegExp(`^email\\:${Caf.toString(findEmailRegexp.source)}\$`))}}}); assert.throws(() => v.validate({id: 123})); assert.throws(() => v.validate({foo: "test@test.com"})); assert.throws(() => v.validate({foo: "email:metest"})); return assert.rejects(() => v.validate({foo: "email:me"})).then(({info}) => assert.eq(info.errors, {foo: "invalid"})).then(() => assert.rejects(() => v.validateUpdate({foo: "email:me"}))).then(({info, stack}) => assert.eq(info.errors, {foo: "invalid"})).then(() => v.validateUpdate());});}});});});
//# sourceMappingURL=Validator.test.js.map
