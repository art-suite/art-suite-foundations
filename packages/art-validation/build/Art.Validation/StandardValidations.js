"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "isPlainObject", "objectKeyCount", "ConfigurationError", "present"], [global, require('./StandardImport')], (merge, isPlainObject, objectKeyCount, ConfigurationError, present) => {let normalizeInstanceofValidation, normalizeLengthValidation, normalizePresentValidation; return {normalizeInstanceofValidation: normalizeInstanceofValidation = function(fieldProps, validatorOptions) {let _instanceof, validate; return (_instanceof = fieldProps.instanceof) ? (({validate} = fieldProps), merge(fieldProps, {validate: (v) => v instanceof _instanceof && (!validate || validate(v))})) : fieldProps;}, normalizeLengthValidation: normalizeLengthValidation = function(fieldProps, validatorOptions) {let postValidate, maxLength, minLength; postValidate = fieldProps.postValidate; maxLength = fieldProps.maxLength; minLength = fieldProps.minLength; return (maxLength != null || minLength != null) ? merge(fieldProps, {maxLength, minLength, postValidate: (value, fieldName, fields) => {let length; return (postValidate && !postValidate(value, fieldName, fields)) ? false : (length = isPlainObject(value) ? objectKeyCount(value) : value.length, (maxLength != null && length > maxLength) ? false : (minLength != null && length < minLength) ? false : true);}}) : fieldProps;}, preExpandStandardValidationProps: function(fieldProps, validatorOptions) {let length, maxLength, minLength, message; length = fieldProps.length; maxLength = fieldProps.maxLength; minLength = fieldProps.minLength; return (length != null) ? ((maxLength != null && maxLength !== length || minLength != null && minLength !== length) ? (message = "Invalid fieldProps: If specifying 'length', you can't also specify maxLength or minLength", validatorOptions.getNiceErrorMessage ? message = validatorOptions.getNiceErrorMessage(message, fieldProps) : undefined, (() => {throw new ConfigurationError(message);})()) : undefined, merge(fieldProps, {length, minLength: length, maxLength: length})) : fieldProps;}, normalizePresentValidation: normalizePresentValidation = function(fieldProps, validatorOptions) {let validate, getValidationErrors; return fieldProps.present ? ((validate = fieldProps.validate, getValidationErrors = fieldProps.getValidationErrors), merge(fieldProps, {required: true, validate: (value, fieldName, fields) => present(value) && (!validate || validate(value, fieldName, fields)), getValidationErrors: (value, fieldPath, forCreate) => [(!present(value)) ? {value, fieldPath, errorIs: "not present"} : undefined, getValidationErrors ? Caf.isF(getValidationErrors) && getValidationErrors(value, fieldPath, forCreate) : undefined]})) : fieldProps;}, normalizeAllStandardValidations: function(fieldProps, validatorOptions) {return normalizeLengthValidation(normalizeInstanceofValidation(normalizePresentValidation(fieldProps, validatorOptions), validatorOptions), validatorOptions);}};});});
//# sourceMappingURL=StandardValidations.js.map
