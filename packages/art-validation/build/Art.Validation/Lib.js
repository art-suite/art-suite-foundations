"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "isPlainObject", "shallowClone", "mergeIntoUnless", "Error", "isString", "FieldTypes", "isArray", "isPlainArray", "w", "formattedInspect"], [global, require('art-standard-lib'), {FieldTypes: require('./FieldTypes')}], (merge, isPlainObject, shallowClone, mergeIntoUnless, Error, isString, FieldTypes, isArray, isPlainArray, w, formattedInspect) => {let namespace, Validator, loadValidator, normalizeInstanceOfProp, normalizePlainObjectProps, normalizeDepricatedProps, normalizeFieldTypeProp, normalizeFieldProps, initNormalizedArrayFieldProps, fieldPropsWithGeneratedPostValidator; namespace = require("./namespace"); Validator = null; loadValidator = function() {return Validator != null ? Validator : Validator = require('./Validator');}; return {normalizeInstanceOfProp: normalizeInstanceOfProp = function(ft) {let _instanceof, validate; return (_instanceof = ft.instanceof) ? (({validate} = ft), merge(ft, {validate: (v) => v instanceof _instanceof && (!validate || validate(v))})) : ft;}, normalizePlainObjectProps: normalizePlainObjectProps = function(ft) {let out; out = null; Caf.each2(ft, (v, k) => {let subObject; return isPlainObject(subObject = v) ? (!out ? out = shallowClone(ft) : undefined, out[k] = true, mergeIntoUnless(out, normalizePlainObjectProps(subObject))) : undefined;}, (v, k) => k !== "fields" && k !== "array"); return out || ft;}, normalizeDepricatedProps: normalizeDepricatedProps = function(ft) {if (ft.requiredPresent) {throw new Error("DEPRICATED: requiredPresent. Use: present: true");}; if (isString(ft.required)) {throw new Error("DEPRICATED: required can no longer specifiy the field-type. Use: required: fieldType: myFieldTypeString OR 'required myFieldTypeString'");}; if (isString(ft.present)) {throw new Error("DEPRICATED: present can no longer specifiy the field-type. Use: present: fieldType: myFieldTypeString OR 'present myFieldTypeString'");}; return ft;}, normalizeFieldTypeProp: normalizeFieldTypeProp = function(ft) {let fieldType, fields, _array, validate, preprocess, subValidator, normalizedArray; ({fieldType, fields, array: _array, validate, preprocess} = ft); if (fields) {fieldType != null ? fieldType : fieldType = "object";}; if (isString(fieldType)) {ft = merge(FieldTypes[fieldType], ft);}; if (fields) {loadValidator(); subValidator = new Validator(fields); ft = merge(ft, {fields: subValidator.fields, validate: validate != null ? validate : ((v) => isPlainObject(v) && subValidator.isValid(v)), preprocess: preprocess != null ? preprocess : ((v) => subValidator.preprocess(v))});}; if (_array) {ft = merge(ft, {array: normalizedArray = normalizeFieldProps(_array), validate: validate != null ? validate : ((_array) => isArray(_array) && !Caf.find(_array, (v) => true, (v) => (v != null) ? !normalizedArray.validate(v) : normalizedArray.required)), preprocess: preprocess != null ? preprocess : normalizedArray.preprocess && ((_array) => _array && Caf.array(_array, (v) => normalizedArray.preprocess(v)))});}; return ft;}, normalizeFieldProps: normalizeFieldProps = function(ft, customFieldTypes) {let fieldProps, ftArray, processed, strings; fieldProps = (() => {switch (false) {case !isPlainObject(ft): return normalizeFieldTypeProp(normalizeInstanceOfProp(normalizeDepricatedProps(normalizePlainObjectProps(ft)))); case !isPlainArray(ftArray = ft): processed = Caf.array(ftArray, (ft) => normalizeFieldProps(ft)); return merge(...processed); case !isString(strings = ft): ft = {}; Caf.each2(w(strings), (string) => {let customFieldType, customFieldTypeProps, subFt; if (customFieldType = Caf.exists(customFieldTypes) && customFieldTypes[string]) {if (isPlainObject(customFieldType)) {customFieldTypeProps = normalizeFieldProps(customFieldType);} else {if (isString(customFieldType)) {if (!(customFieldTypeProps = FieldTypes[customFieldType])) {throw new Error(`Custom field type ${Caf.toString(customFieldType)} maps to an invalid standard field type: ${Caf.toString(customFieldType)}`);};} else {throw new Error(`Invalid custom field type ${Caf.toString(customFieldType)}. Expected string or plain object. Got: ${Caf.toString(formattedInspect(customFieldType))}`);};};}; return (subFt = customFieldTypeProps != null ? customFieldTypeProps : FieldTypes[string]) ? (ft.fieldType = string, mergeIntoUnless(ft, subFt)) : ft[string] = true;}); return ft; case !(ft === true): return FieldTypes.any; default: return (() => {throw new Error(`fieldType must be a string or plainObject. Was: ${Caf.toString(formattedInspect(ft))}`);})();};})(); return fieldPropsWithGeneratedPostValidator(merge(FieldTypes[fieldProps.fieldType], fieldProps));}, initNormalizedArrayFieldProps: initNormalizedArrayFieldProps = function(rawArrayFieldProps, intoFieldProps = {}) {let preprocess, validate, postValidate, length, maxLength, minLength, arrayFieldProps, customValidate, customPreprocess, customPostValidate, temp, temp2, temp3; ({preprocess, validate, postValidate, length, maxLength = length, minLength = length} = arrayFieldProps = normalizeFieldProps(rawArrayFieldProps)); ({validate: customValidate, preprocess: customPreprocess, postValidate: customPostValidate} = intoFieldProps); ((temp = intoFieldProps.validate) != null ? temp : intoFieldProps.validate = (a) => {let from, into, to, i, temp1; return isArray(a) && ((minLength != null) ? a.length >= minLength : true) && ((maxLength != null) ? a.length <= maxLength : true) && ((validate != null) ? !(from = a, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (!validate(v)) {into = v; break;}; temp1 = i++;}; return temp1;})()) : undefined, into) : true) && true;}); ((temp2 = intoFieldProps.preprocess) != null ? temp2 : intoFieldProps.preprocess = (a) => {let from, into, to, i, temp1; if (a != null && preprocess != null) {a = (from = a, into = [], (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; into.push(preprocess(v)); temp1 = i++;}; return temp1;})()) : undefined, into);}; return a;}); ((temp3 = intoFieldProps.postValidate) != null ? temp3 : intoFieldProps.postValidate = (a) => {let from, into, to, i, temp1; return isArray(a) && ((minLength != null) ? a.length >= minLength : true) && ((maxLength != null) ? a.length <= maxLength : true) && ((postValidate != null) ? !(from = a, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (!postValidate(v)) {into = v; break;}; temp1 = i++;}; return temp1;})()) : undefined, into) : true) && true;}); return intoFieldProps;}, fieldPropsWithGeneratedPostValidator: fieldPropsWithGeneratedPostValidator = function(fieldProps) {let postValidate, maxLength, minLength, fields, rawArrayFieldProps, validator; postValidate = fieldProps.postValidate; maxLength = fieldProps.maxLength; minLength = fieldProps.minLength; fields = fieldProps.fields; rawArrayFieldProps = fieldProps.array; if (rawArrayFieldProps && fields) {throw new Error("can only specify `array:` or `fields:`");}; if (maxLength != null || minLength != null || fields != null || rawArrayFieldProps) {if (rawArrayFieldProps) {initNormalizedArrayFieldProps(rawArrayFieldProps, fieldProps);} else {if (fields) {validator = new (namespace.Validator)(fields, {exclusive: true}); fieldProps.preprocess = (value, forCreate) => validator.preprocessFields(value, forCreate);}; fieldProps.postValidate = (value, fieldName, fields) => (postValidate && !postValidate(value, fieldName, fields)) ? false : (value != null) ? (maxLength != null && value.length > maxLength) ? false : (minLength != null && value.length < minLength) ? false : (() => {try {Caf.exists(validator) && validator.validate(value); return true;} catch (error) {return false;};})() : true;};}; return fieldProps;}};});});
//# sourceMappingURL=Lib.js.map
