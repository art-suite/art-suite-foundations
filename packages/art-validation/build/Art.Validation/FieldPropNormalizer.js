"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "objectKeyCount", "mergeIntoUnless", "isString", "FieldTypes", "isPlainObject", "Error", "isArray", "isPlainArray", "compactFlatten", "w", "formattedInspect", "mergeInto", "JSON"], [global, require('art-standard-lib'), {FieldTypes: require('./FieldTypes')}], (merge, objectKeyCount, mergeIntoUnless, isString, FieldTypes, isPlainObject, Error, isArray, isPlainArray, compactFlatten, w, formattedInspect, mergeInto, JSON) => {let namespace, normalizeInstanceOfProp, allowedBooleanProps, normalizeRecursivePlainObjectProps, normalizeDeprecatedProps, normalizeFieldTypeProp, fieldPropsWithGeneratedPostValidator, normalizeLengthChecks, processingCustomFieldtypePath, _normalizeFieldProps, noCustomFieldTypes, normalizeFieldProps; namespace = require("./namespace"); normalizeInstanceOfProp = function(ft) {let _instanceof, validate; return (_instanceof = ft.instanceof) ? (({validate} = ft), merge(ft, {validate: (v) => v instanceof _instanceof && (!validate || validate(v))})) : ft;}; allowedBooleanProps = {required: true, present: true}; normalizeRecursivePlainObjectProps = function(plainObjectFieldType) {let temp; return ((temp = (1 === objectKeyCount(plainObjectFieldType)) ? Caf.find(plainObjectFieldType, (singleFieldValue, singleFieldName) => mergeIntoUnless({[singleFieldName]: true}, isString(singleFieldValue) ? FieldTypes[singleFieldValue] : normalizeRecursivePlainObjectProps(singleFieldValue)), (singleFieldValue, singleFieldName) => allowedBooleanProps[singleFieldName] && (isPlainObject(singleFieldValue) || isString(singleFieldValue))) : undefined) != null ? temp : plainObjectFieldType);}; normalizeDeprecatedProps = function(ft) {if (ft.requiredPresent) {throw new Error("DEPRECATED: requiredPresent. Use: present: true");}; return ft;}; normalizeFieldTypeProp = function(ft, customFieldTypes) {let fieldType, fields, _array, validate, postValidate, preprocess, minLength, maxLength, subValidator, normalizedArray; ({fieldType, fields, array: _array, validate, postValidate, preprocess, minLength, maxLength} = ft); if (fields) {fieldType != null ? fieldType : fieldType = "object";}; if (isString(fieldType)) {ft = merge(FieldTypes[fieldType], ft);}; return fields ? (_array ? (() => {throw new Error("Can only specify `array: ...` or `fields: ...`");})() : undefined, subValidator = new (namespace.Validator)(fields, {customFieldTypes, exclusive: true}), ft = merge(ft, {fields: subValidator.fields, validate: validate != null ? validate : ((v) => isPlainObject(v) && subValidator.isValid(v)), preprocess: preprocess != null ? preprocess : ((v) => subValidator.preprocess(v))})) : _array ? (normalizedArray = _normalizeFieldProps(_array, customFieldTypes), merge(ft, {dataType: "array", fieldType: "array", array: normalizedArray, validate: validate != null ? validate : (normalizedArray.validate || normalizedArray.required) ? (_array) => {let from, into, to, i, from1, into1, to1, i1, temp, temp1; return isArray(_array) && (!validate || validate(_array)) && (!normalizedArray.validate || !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (v != null && !normalizedArray.validate(v)) {into = true; break;}; temp = i++;}; return temp;})()) : undefined, into)) && (!normalizedArray.required || !(from1 = _array, into1 = null, (from1 != null) ? (to1 = from1.length, i1 = 0, (() => {while (i1 < to1) {let v; v = from1[i1]; if (!(v != null)) {into1 = true; break;}; temp1 = i1++;}; return temp1;})()) : undefined, into1));} : undefined, preprocess: preprocess != null ? preprocess : normalizedArray.preprocess ? (_array) => isArray(_array) ? Caf.array(_array, (v) => normalizedArray.preprocess(v)) : _array : undefined, postValidate: postValidate != null ? postValidate : normalizedArray.postValidate ? (_array) => {let from, into, to, i, temp; return !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (!normalizedArray.postValidate(v)) {into = true; break;}; temp = i++;}; return temp;})()) : undefined, into);} : undefined})) : ft;}; fieldPropsWithGeneratedPostValidator = function(fieldProps, customFieldTypes) {let preprocess, validate, postValidate, maxLength, minLength, fields; preprocess = fieldProps.preprocess; validate = fieldProps.validate; postValidate = fieldProps.postValidate; maxLength = fieldProps.maxLength; minLength = fieldProps.minLength; fields = fieldProps.fields; if (maxLength != null || minLength != null) {fieldProps.postValidate = (value, fieldName, fields) => (postValidate && !postValidate(value, fieldName, fields)) ? false : (value != null) ? (maxLength != null && value.length > maxLength) ? false : (minLength != null && value.length < minLength) ? false : true : true;}; return fieldProps;}; normalizeLengthChecks = function(ft) {let length; return ((length = ft.length) != null) ? merge(ft, {maxLength: length, minLength: length}) : ft;}; processingCustomFieldtypePath = []; _normalizeFieldProps = function(ft, customFieldTypes) {let fieldProps, ftArray, out, strings, from, into, to, i; fieldProps = (() => {switch (false) {case !isPlainObject(ft): return normalizeFieldTypeProp(normalizeInstanceOfProp(normalizeDeprecatedProps(normalizeRecursivePlainObjectProps(normalizeLengthChecks(ft)))), customFieldTypes); case !isPlainArray(ftArray = ft): return Caf.each2(compactFlatten(ftArray), (ft) => mergeInto(out, _normalizeFieldProps(ft, customFieldTypes)), null, out = {}); case !isString(strings = ft): ft = {}; from = w(strings); into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let string, customFieldType, customFieldTypeProps, subFt; string = from[i]; if (customFieldType = Caf.exists(customFieldTypes) && customFieldTypes[string]) {try {if (Caf.in(string, processingCustomFieldtypePath)) {throw new Error(`Recursive custom field types are not supported. Recursive path: ${Caf.toString(processingCustomFieldtypePath.join(" > "))} > ${Caf.toString(string)}`);}; processingCustomFieldtypePath.push(string); if (isPlainObject(customFieldType) || isString(customFieldType)) {customFieldTypeProps = _normalizeFieldProps(customFieldType, customFieldTypes);} else {throw new Error(`Invalid custom field type ${Caf.toString(customFieldType)}. Expected string or plain object. Got: ${Caf.toString(formattedInspect(customFieldType))}`);};} finally {processingCustomFieldtypePath.pop();};}; if (subFt = customFieldTypeProps != null ? customFieldTypeProps : FieldTypes[string]) {ft.fieldType = string; mergeIntoUnless(ft, subFt);} else {if (allowedBooleanProps[string]) {ft[string] = true;} else {throw new Error(`Unknown field-type: ${Caf.toString(JSON.stringify(string))}`);};}; i++;};}; into; return ft; case !(ft === true): return FieldTypes.any; default: return (() => {throw new Error(`fieldType must be a string or plainObject. Was: ${Caf.toString(formattedInspect(ft))}`);})();};})(); return fieldPropsWithGeneratedPostValidator(merge(FieldTypes[fieldProps.fieldType], fieldProps), customFieldTypes);}; noCustomFieldTypes = {}; return {normalizeFieldProps: normalizeFieldProps = function(fieldType, customFieldTypes) {return _normalizeFieldProps(fieldType, customFieldTypes != null ? customFieldTypes : noCustomFieldTypes);}, normalizeFields: function(fields, customFieldTypes) {return Caf.object(fields, (fieldType) => normalizeFieldProps(fieldType, customFieldTypes));}};});});
//# sourceMappingURL=FieldPropNormalizer.js.map
