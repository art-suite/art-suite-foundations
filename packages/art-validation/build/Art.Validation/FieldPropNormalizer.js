"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["merge", "objectKeyCount", "log", "isPlainObject", "isString", "Error", "FieldTypes", "isArray", "JSON", "isPlainArray", "compactFlatten", "w", "formattedInspect", "mergeInto", "mergeIntoUnless"], [global, require('art-standard-lib'), {FieldTypes: require('./FieldTypes')}], (merge, objectKeyCount, log, isPlainObject, isString, Error, FieldTypes, isArray, JSON, isPlainArray, compactFlatten, w, formattedInspect, mergeInto, mergeIntoUnless) => {let namespace, normalizeInstanceOfProp, standardTags, normalizeRecursivePlainObjectProps, normalizeDeprecatedProps, normalizeObjectAndArrayFieldProps, fieldPropsWithGeneratedPostValidator, applyFieldtype, processingCustomFieldtypePath, _normalizeFieldProps, normalizeValidatorOptions, normalizeFieldProps; namespace = require("./namespace"); normalizeInstanceOfProp = function(ft) {let _instanceof, validate; return (_instanceof = ft.instanceof) ? (({validate} = ft), merge(ft, {validate: (v) => v instanceof _instanceof && (!validate || validate(v))})) : ft;}; standardTags = {required: true, present: true}; normalizeRecursivePlainObjectProps = function(plainObjectFieldType) {let temp; return ((temp = (1 === objectKeyCount(plainObjectFieldType)) ? Caf.find(plainObjectFieldType, (singleFieldValue, singleFieldName) => {log.warn(`ArtValidation DEPRECTAED fieldProps: {${Caf.toString(singleFieldName)}: object/string}. USE: ["${Caf.toString(singleFieldName)}", object/string]`); return [singleFieldName, singleFieldValue];}, (singleFieldValue, singleFieldName) => standardTags[singleFieldName] && (isPlainObject(singleFieldValue) || isString(singleFieldValue))) : undefined) != null ? temp : plainObjectFieldType);}; normalizeDeprecatedProps = function(ft) {if (ft.requiredPresent) {throw new Error("ArtValidation DEPRECTAED fieldProps: requiredPresent. USE: present: true");}; return ft;}; normalizeObjectAndArrayFieldProps = function(fieldProps, validatorOptions) {let fieldType, fields, _array, validate, postValidate, preprocess, minLength, maxLength, subValidator, normalizedArray; ({fieldType, fields, array: _array, validate, postValidate, preprocess, minLength, maxLength} = fieldProps); if (fields) {fieldType != null ? fieldType : fieldType = "object";}; if (isString(fieldType)) {fieldProps = merge(FieldTypes[fieldType], fieldProps);}; return fields ? (_array ? (() => {throw new Error("Can only specify `array: ...` or `fields: ...`");})() : undefined, subValidator = new (namespace.Validator)(fields, merge(validatorOptions, {exclusive: true})), fieldProps = merge(fieldProps, {fields: subValidator.fields, validate: validate != null ? validate : ((v) => isPlainObject(v) && subValidator.isValid(v)), preprocess: preprocess != null ? preprocess : ((v) => subValidator.preprocess(v))})) : _array ? (normalizedArray = _normalizeFieldProps(_array, validatorOptions), merge(fieldProps, {dataType: "array", fieldType: "array", array: normalizedArray, validate: validate != null ? validate : (normalizedArray.validate || normalizedArray.required) ? (_array) => {let from, into, to, i, from1, into1, to1, i1, temp, temp1; return isArray(_array) && (!validate || validate(_array)) && (!normalizedArray.validate || !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (v != null && !normalizedArray.validate(v)) {into = true; break;}; temp = i++;}; return temp;})()) : undefined, into)) && (!normalizedArray.required || !(from1 = _array, into1 = null, (from1 != null) ? (to1 = from1.length, i1 = 0, (() => {while (i1 < to1) {let v; v = from1[i1]; if (!(v != null)) {into1 = true; break;}; temp1 = i1++;}; return temp1;})()) : undefined, into1));} : undefined, preprocess: preprocess != null ? preprocess : normalizedArray.preprocess ? (_array) => isArray(_array) ? Caf.array(_array, (v) => normalizedArray.preprocess(v)) : _array : undefined, postValidate: postValidate != null ? postValidate : normalizedArray.postValidate ? (_array) => {let from, into, to, i, temp; return !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (!normalizedArray.postValidate(v)) {into = true; break;}; temp = i++;}; return temp;})()) : undefined, into);} : undefined})) : fieldProps;}; fieldPropsWithGeneratedPostValidator = function(fieldProps, validatorOptions) {let postValidate, maxLength, minLength, length; postValidate = fieldProps.postValidate; maxLength = fieldProps.maxLength; minLength = fieldProps.minLength; length = fieldProps.length; if (length != null) {if (maxLength != null || minLength != null) {throw new Error("If specifying 'length', you can't also specify maxLength nor minLength");}; maxLength = minLength = length;}; return (maxLength != null || minLength != null) ? merge(fieldProps, {maxLength, minLength, length, postValidate: (value, fieldName, fields) => (postValidate && !postValidate(value, fieldName, fields)) ? false : (value != null) ? (maxLength != null && value.length > maxLength) ? false : (minLength != null && value.length < minLength) ? false : true : true}) : fieldProps;}; applyFieldtype = function(fieldProps, validatorOptions) {let fieldType, fieldTypeProps; return (fieldType = fieldProps.fieldType) ? !(fieldTypeProps = validatorOptions.fieldtypes[fieldType]) ? (() => {throw new Error(`Unknown field-type: ${Caf.toString(JSON.stringify(fieldType))}`);})() : undefined : undefined;}; processingCustomFieldtypePath = []; _normalizeFieldProps = function(fieldProps, validatorOptions) {let normalizedFieldProps, ftArray, ftStrings, from, into, to, i; switch (false) {case !isPlainObject(fieldProps): normalizedFieldProps = normalizeObjectAndArrayFieldProps(normalizeInstanceOfProp(normalizeDeprecatedProps(normalizeRecursivePlainObjectProps(fieldProps))), validatorOptions); break; case !isPlainArray(ftArray = fieldProps): Caf.each2(compactFlatten(ftArray), (fieldProps) => mergeInto(normalizedFieldProps, _normalizeFieldProps(fieldProps, validatorOptions)), null, normalizedFieldProps = {}); break; case !isString(ftStrings = fieldProps): normalizedFieldProps = {}; from = w(ftStrings); into = from; if (from != null) {to = from.length; i = 0; while (i < to) {let string, customFieldType, customFieldTypeProps, subFt, base; string = from[i]; if (customFieldType = Caf.exists(base = validatorOptions.customFieldTypes) && base[string]) {try {if (Caf.in(string, processingCustomFieldtypePath)) {throw new Error(`Recursive custom field types are not supported. Recursive path: ${Caf.toString(processingCustomFieldtypePath.join(" > "))} > ${Caf.toString(string)}`);}; processingCustomFieldtypePath.push(string); if (isPlainObject(customFieldType) || isString(customFieldType)) {customFieldTypeProps = _normalizeFieldProps(customFieldType, validatorOptions);} else {throw new Error(`Invalid custom field type ${Caf.toString(customFieldType)}. Expected string or plain object. Got: ${Caf.toString(formattedInspect(customFieldType))}`);};} finally {processingCustomFieldtypePath.pop();};}; if (subFt = customFieldTypeProps != null ? customFieldTypeProps : FieldTypes[string]) {normalizedFieldProps.fieldType = string; mergeIntoUnless(normalizedFieldProps, subFt);} else {normalizedFieldProps[string] = true;}; i++;};}; into; normalizedFieldProps; break; case !(fieldProps === true): normalizedFieldProps = FieldTypes.any; break; default: throw new Error(`fieldProps must be a string, plainObject, or array of strings, plainObjects and/or arrays. Was: ${Caf.toString(formattedInspect(fieldProps))}`);}; return fieldPropsWithGeneratedPostValidator(merge(FieldTypes[normalizedFieldProps.fieldType], normalizedFieldProps), validatorOptions);}; normalizeValidatorOptions = function(validatorOptions) {let customFieldTypes; return merge(validatorOptions, {fieldTypes: (Caf.exists(validatorOptions) ? customFieldTypes = validatorOptions.customFieldTypes : undefined) ? merge(FieldTypes, customFieldTypes) : FieldTypes});}; return {normalizeFieldProps: normalizeFieldProps = function(fieldType, validatorOptions) {return _normalizeFieldProps(fieldType, normalizeValidatorOptions(validatorOptions));}, normalizeFields: function(fields, validatorOptions) {return Caf.object(fields, (fieldType) => normalizeFieldProps(fieldType, normalizeValidatorOptions(validatorOptions)));}};});});
//# sourceMappingURL=FieldPropNormalizer.js.map
