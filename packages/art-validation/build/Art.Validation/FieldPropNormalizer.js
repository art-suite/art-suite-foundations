"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["objectKeyCount", "log", "isPlainObject", "isString", "Error", "merge", "isArray", "FieldTypes", "compactFlatten", "compactFlattenAll", "w", "Object", "present", "normalizeAllStandardValidations", "mergeInto", "preExpandStandardValidationProps", "compact", "formattedInspect"], [global, require('art-standard-lib'), require('./StandardValidations'), {FieldTypes: require('./FieldTypes')}], (objectKeyCount, log, isPlainObject, isString, Error, merge, isArray, FieldTypes, compactFlatten, compactFlattenAll, w, Object, present, normalizeAllStandardValidations, mergeInto, preExpandStandardValidationProps, compact, formattedInspect) => {let namespace, standardTags, normalizeRecursivePlainObjectProps, normalizeDeprecatedProps, normalizeObjectAndArrayFieldProps, processingCustomFieldtypePath, normalizeStringFieldProp, normalizeFieldPropsStructure, _normalizeFieldProps, normalizeValidatorOptions; namespace = require("./namespace"); standardTags = {required: true, present: true}; normalizeRecursivePlainObjectProps = function(plainObjectFieldType, validatorOptions) {let temp; return ((temp = (1 === objectKeyCount(plainObjectFieldType)) ? Caf.find(plainObjectFieldType, (singleFieldValue, singleFieldName) => {let message; message = validatorOptions.getNiceErrorMessage(`ArtValidation DEPRECATED fieldProps: {${Caf.toString(singleFieldName)}: object/string}. USE: ["${Caf.toString(singleFieldName)}", object/string]`, plainObjectFieldType); if (!validatorOptions.quiet) {log.warn(message);}; return [singleFieldName, singleFieldValue];}, (singleFieldValue, singleFieldName) => standardTags[singleFieldName] && (isPlainObject(singleFieldValue) || isString(singleFieldValue))) : undefined) != null ? temp : plainObjectFieldType);}; normalizeDeprecatedProps = function(fieldProps, validatorOptions) {if (fieldProps.requiredPresent) {throw new Error(validatorOptions.getNiceErrorMessage("ArtValidation DEPRECATED fieldProps: requiredPresent. USE: present: true", fieldProps));}; return fieldProps;}; normalizeObjectAndArrayFieldProps = function(fieldProps, validatorOptions) {let fields, _array, validate, postValidate, preprocess, subValidator, normalizedArray; fields = fieldProps.fields; _array = fieldProps.array; validate = fieldProps.validate; postValidate = fieldProps.postValidate; preprocess = fieldProps.preprocess; return fields ? (_array ? (() => {throw new Error(validatorOptions.getNiceErrorMessage("Invalid fieldProps. Can only specify `array: ...` or `fields: ...`", fieldProps));})() : undefined, subValidator = new (namespace.Validator)(fields, merge(validatorOptions, {exclusive: true})), fieldProps = merge(fieldProps, {fields: subValidator.fields, dataType: "object", fieldType: "object", validate: validate != null ? validate : ((v) => isPlainObject(v) && subValidator.isValid(v)), preprocess: preprocess != null ? preprocess : ((v) => subValidator.preprocess(v))})) : _array ? (normalizedArray = _normalizeFieldProps(_array, validatorOptions), merge(fieldProps, {dataType: "array", fieldType: "array", array: normalizedArray, validate: validate != null ? validate : (normalizedArray.validate || normalizedArray.required) ? (_array) => {let from, into, to, i, from1, into1, to1, i1, temp, temp1; return isArray(_array) && (!validate || validate(_array)) && (!normalizedArray.validate || !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (v != null && !normalizedArray.validate(v)) {into = true; break;}; temp = i++;}; return temp;})()) : undefined, into)) && (!normalizedArray.required || !(from1 = _array, into1 = null, (from1 != null) ? (to1 = from1.length, i1 = 0, (() => {while (i1 < to1) {let v; v = from1[i1]; if (!(v != null)) {into1 = true; break;}; temp1 = i1++;}; return temp1;})()) : undefined, into1));} : undefined, preprocess: preprocess != null ? preprocess : normalizedArray.preprocess ? (_array) => isArray(_array) ? Caf.array(_array, (v) => normalizedArray.preprocess(v)) : _array : undefined, postValidate: postValidate != null ? postValidate : normalizedArray.postValidate ? (_array) => {let from, into, to, i, temp; return !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (!normalizedArray.postValidate(v)) {into = true; break;}; temp = i++;}; return temp;})()) : undefined, into);} : undefined})) : fieldProps;}; processingCustomFieldtypePath = []; normalizeStringFieldProp = function(fieldPropString, validatorOptions) {let customFieldType, customFieldTypeProps, namedFieldTypeProps; return (customFieldType = validatorOptions.customFieldTypes[fieldPropString]) ? (() => {try {if (Caf.in(fieldPropString, processingCustomFieldtypePath)) {throw new Error(validatorOptions.getNiceErrorMessage(`Invalid custom fields. Recursive custom field types are not supported. Recursive path: ${Caf.toString(processingCustomFieldtypePath.join(" > "))} > ${Caf.toString(fieldPropString)}`));}; processingCustomFieldtypePath.push(fieldPropString); if (isPlainObject(customFieldType) || isString(customFieldType)) {customFieldTypeProps = _normalizeFieldProps(customFieldType, validatorOptions);} else {throw new Error(validatorOptions.getNiceErrorMessage("Invalid custom field type. Expected fieldPropString or plain object", customFieldType));}; return merge(customFieldTypeProps, {fieldType: fieldPropString});} finally {processingCustomFieldtypePath.pop();};})() : (namedFieldTypeProps = FieldTypes[fieldPropString]) ? merge(namedFieldTypeProps, {fieldType: fieldPropString}) : {[fieldPropString]: true};}; normalizeFieldPropsStructure = function(fieldProps, validatorOptions) {return compactFlatten(Caf.array(compactFlattenAll(fieldProps), (element) => {let rawEnum, normalizedEnum, fieldType; return (() => {switch (false) {case !isString(element): return w(element); case !isPlainObject(element): element = normalizeRecursivePlainObjectProps(element, validatorOptions); return ((rawEnum = element.enum) != null) ? (normalizedEnum = compactFlatten(Caf.array(compactFlatten(rawEnum), (str) => {if (!(isString(str) && present(str))) {throw new Error(`Error: \`enum:\` option must provide a list of strings. ${Caf.toString({formattedInspect: {rawEnum, normalizedEnum}})}`);}; return w(str);})), (normalizedEnum.length === 0) ? (() => {throw new Error(`Error: \`enum:\` requires at east one valid enum value. ${Caf.toString({formattedInspect: {rawEnum, normalizedEnum}})}`);})() : undefined, {enum: normalizedEnum, fieldType: "enum", dataType: "string", validate: (v) => Caf.in(v, normalizedEnum)}) : (fieldType = element.fieldType) ? (FieldTypes[fieldType] || validatorOptions.customFieldTypes[fieldType]) ? [element.fieldType, element] : (() => {throw new Error(validatorOptions.getNiceErrorMessage(`Invalid, explicit fieldType. Valid fieldTypes: ${Caf.toString(Object.keys(merge(FieldTypes, validatorOptions.customFieldTypes)).sort().join(", "))}`, fieldType));})() : element; case !(element === true): return FieldTypes.any; default: return (() => {throw new Error(validatorOptions.getNiceErrorMessage("Invalid fieldProps. Expected string, plainObject, or array of strings, plainObjects and/or arrays", element));})();};})();}));}; _normalizeFieldProps = function(fieldProps, validatorOptions) {let normalizedFieldProps; Caf.each2(normalizeFieldPropsStructure(fieldProps, validatorOptions), (fieldProps) => mergeInto(normalizedFieldProps, (() => {switch (false) {case !isString(fieldProps): return normalizeStringFieldProp(fieldProps, validatorOptions); case !isPlainObject(fieldProps): fieldProps = preExpandStandardValidationProps(fieldProps, validatorOptions); fieldProps = normalizeDeprecatedProps(fieldProps, validatorOptions); return fieldProps = normalizeObjectAndArrayFieldProps(fieldProps, validatorOptions); default: return (() => {throw new Error(validatorOptions.getNiceErrorMessage("Internal failure. Should not be possible to get here.", fieldProps));})();};})()), null, normalizedFieldProps = {}); return normalizeAllStandardValidations(normalizedFieldProps, validatorOptions);}; normalizeValidatorOptions = function(validatorOptions) {let temp; return merge(validatorOptions, {customFieldTypes: ((temp = Caf.exists(validatorOptions) && validatorOptions.customFieldTypes) != null ? temp : {}), getNiceErrorMessage: function(message, invalidInput) {let joiner, inspected; joiner = ". "; return compact([message, (invalidInput && invalidInput !== this.rawFieldProps) ? (inspected = formattedInspect(invalidInput), /\n/.test(inspected) ? (joiner = "\n", inspected = "\n  " + inspected.replace(/\n/g, "\n  ")) : undefined, `Got: ${Caf.toString(inspected)}`) : undefined, this.fieldName ? `Field ${Caf.toString(this.fieldName)}:` : undefined, this.rawFieldProps ? (inspected = formattedInspect(this.rawFieldProps), /\n/.test(inspected) ? (joiner = "\n", inspected = "\n  " + inspected.replace(/\n/g, "\n  ")) : undefined, `Raw fieldProps: ${Caf.toString(inspected)}`) : undefined]).join(joiner);}});}; return {normalizeFieldProps: function(fieldProps, validatorOptions) {validatorOptions = normalizeValidatorOptions(validatorOptions); validatorOptions.rawFieldProps = fieldProps; return _normalizeFieldProps(fieldProps, validatorOptions);}, normalizeFields: function(fields, validatorOptions) {validatorOptions = normalizeValidatorOptions(validatorOptions); return Caf.object(fields, (fieldProps, fieldName) => {validatorOptions.fieldName = fieldName; validatorOptions.rawFieldProps = fieldProps; return _normalizeFieldProps(fieldProps, validatorOptions);});}};});});
//# sourceMappingURL=FieldPropNormalizer.js.map
