"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["objectKeyCount", "log", "isPlainObject", "isString", "DeprecationError", "ConfigurationError", "merge", "isArray", "joinFieldPath", "makeEmptyArraysIntoNulls", "standardInvalidMessage", "isObject", "compactFlatten", "FieldTypes", "compactFlattenAll", "w", "createEnumFieldType", "Object", "normalizeAllStandardValidations", "mergeInto", "preExpandStandardValidationProps", "compact", "formattedInspect"], [global, require('./StandardImport'), require('./StandardValidations'), require('./Enum'), require('./Tools'), {FieldTypes: require('./FieldTypes')}], (objectKeyCount, log, isPlainObject, isString, DeprecationError, ConfigurationError, merge, isArray, joinFieldPath, makeEmptyArraysIntoNulls, standardInvalidMessage, isObject, compactFlatten, FieldTypes, compactFlattenAll, w, createEnumFieldType, Object, normalizeAllStandardValidations, mergeInto, preExpandStandardValidationProps, compact, formattedInspect) => {let namespace, alwaysValid, noop, standardTags, normalizeRecursivePlainObjectProps, normalizeDeprecatedProps, normalizeRecursiveFieldProps, processingCustomFieldTypePath, normalizeStringFieldProp, normalizeFieldPropsStructure, _normalizeFieldProps, normalizeValidatorOptions; namespace = require("./namespace"); alwaysValid = function() {return true;}; noop = function(a) {return a;}; standardTags = {required: true, present: true}; normalizeRecursivePlainObjectProps = function(plainObjectFieldType, validatorOptions) {let temp; return ((temp = (1 === objectKeyCount(plainObjectFieldType)) ? Caf.find(plainObjectFieldType, (singleFieldValue, singleFieldName) => {let message; message = validatorOptions.getNiceErrorMessage(`ArtValidation DEPRECATED fieldProps: {${Caf.toString(singleFieldName)}: object/string}. USE: ["${Caf.toString(singleFieldName)}", object/string]`, plainObjectFieldType); if (!validatorOptions.quiet) {log.warn(message);}; return [singleFieldName, singleFieldValue];}, (singleFieldValue, singleFieldName) => standardTags[singleFieldName] && (isPlainObject(singleFieldValue) || isString(singleFieldValue))) : undefined) != null ? temp : plainObjectFieldType);}; normalizeDeprecatedProps = function(fieldProps, validatorOptions) {if (fieldProps.requiredPresent) {throw new DeprecationError(validatorOptions.getNiceErrorMessage("ArtValidation DEPRECATED fieldProps: requiredPresent. USE: present: true", fieldProps));}; return fieldProps;}; normalizeRecursiveFieldProps = function(fieldProps, validatorOptions) {let fields, _array, validate, postValidate, preprocess, map, subValidator, normalizedArray, elementIsValid, keys, values, validateKey, validateValue, preprocessKey, preprocessValue, postValidateKey, postValidateValue, needToPreprocess, elementIsPostValid; fields = fieldProps.fields; _array = fieldProps.array; validate = fieldProps.validate; postValidate = fieldProps.postValidate; preprocess = fieldProps.preprocess; map = fieldProps.map; if ((fields && 1 || 0) + (_array && 1 || 0) + (map && 1 || 0) > 1) {throw new ConfigurationError(validatorOptions.getNiceErrorMessage("Invalid fieldProps. Can only specify one of `array: ...`, `fields: ...` or 'object: ...'", fieldProps));}; return (() => {switch (false) {case !fields: subValidator = new (namespace.Validator)(fields, merge(validatorOptions, {exclusive: true})); return fieldProps = merge(fieldProps, {fields: subValidator.fields, getValidationErrors: (value, fieldPath, forCreate) => (!isPlainObject(value)) ? {fieldPath, value, error: "must be a plain object"} : !subValidator.isValid(value, forCreate) ? subValidator.getValidationErrors(value, fieldPath, forCreate) : undefined, dataType: "object", fieldType: "object", validate: validate != null ? validate : ((v) => isPlainObject(v) && subValidator.isValid(v)), preprocess: preprocess != null ? preprocess : ((v) => subValidator.preprocess(v))}); case !_array: normalizedArray = _normalizeFieldProps(_array, validatorOptions); elementIsValid = (v) => (normalizedArray.required && !(v != null)) ? false : (v != null && normalizedArray.validate) ? !!normalizedArray.validate(v) : true; return merge(fieldProps, {getValidationErrors: (value, fieldPath, forCreate) => {let from, into, to, i1, temp; return (!isArray(value)) ? {fieldPath, value, errorIs: "not an array"} : (from = value, into = [], (from != null) ? (to = from.length, i1 = 0, (() => {while (i1 < to) {let subValue, i, subFieldPath; subValue = from[i1]; i = i1; if (!elementIsValid(subValue)) {into.push((subFieldPath = joinFieldPath(fieldPath, i), makeEmptyArraysIntoNulls(Caf.isF(normalizedArray.getValidationErrors) && normalizedArray.getValidationErrors(subValue, subFieldPath, forCreate)) || {value: subValue, fieldPath: subFieldPath, errorIs: standardInvalidMessage(normalizedArray, subValue)}));}; temp = i1++;}; return temp;})()) : undefined, into);}, dataType: "array", fieldType: "array", array: normalizedArray, validate: validate != null ? validate : (normalizedArray.validate || normalizedArray.required) ? (_array) => {let from, into, to, i, temp; return isArray(_array) && (!validate || validate(_array)) && !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (into = !elementIsValid(v)) {break;}; temp = i++;}; return temp;})()) : undefined, into || null);} : undefined, preprocess: preprocess != null ? preprocess : normalizedArray.preprocess ? (_array) => isArray(_array) ? Caf.array(_array, (v) => normalizedArray.preprocess(v)) : _array : undefined, postValidate: postValidate != null ? postValidate : normalizedArray.postValidate ? (_array) => {let from, into, to, i, temp; return !(from = _array, into = null, (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let v; v = from[i]; if (into = !normalizedArray.postValidate(v)) {break;}; temp = i++;}; return temp;})()) : undefined, into || null);} : undefined}); case !map: keys = map.keys; values = map.values; if (!keys && !values) {throw new ConfigurationError(validatorOptions.getNiceErrorMessage("Invalid fieldProps. 'object' definition must specify 'keys' and/or 'values'", fieldProps));}; keys = keys && _normalizeFieldProps(["string", keys, {dataType: "string"}], validatorOptions); values = values && _normalizeFieldProps(values, validatorOptions); validateKey = Caf.exists(keys) && keys.validate || alwaysValid; validateValue = Caf.exists(values) && values.validate || alwaysValid; preprocessKey = Caf.exists(keys) && keys.preprocess || noop; preprocessValue = Caf.exists(values) && values.preprocess || noop; postValidateKey = Caf.exists(keys) && keys.postValidate || alwaysValid; postValidateValue = Caf.exists(values) && values.postValidate || alwaysValid; needToPreprocess = Caf.exists(values) && values.preprocess || Caf.exists(keys) && keys.preprocess; elementIsValid = (validateKey || validateValue) ? (value, key) => validateKey(key) && validateValue(value) : undefined; elementIsPostValid = (postValidateKey || postValidateValue) ? (value, key) => postValidateKey(key) && postValidateValue(value) : undefined; return {dataType: "object", fieldType: "map", object: {keys, values}, validate: validate = (value) => isObject(value) ? elementIsValid && !Caf.find(value, (v, k) => !elementIsValid(v, k)) : undefined, preprocess: preprocess = (value) => isObject(value) ? needToPreprocess ? Caf.object(value, (v, k) => preprocessValue(v), null, null, (v, k) => preprocessKey(k)) : value : undefined, postValidate: elementIsPostValid ? (value) => !Caf.find(value, (v, k) => !elementIsPostValid(v, k)) : undefined, getValidationErrors: (value, fieldPath, forCreate) => {let keyTest, valueTest, fieldTest, temp, temp1, temp2, temp3; return (!isObject(value)) ? {fieldPath, value, errorIs: "not an object"} : ((!validate(value)) ? (keyTest = ((temp = Caf.exists(keys) && keys.validate) != null ? temp : alwaysValid), valueTest = ((temp1 = Caf.exists(values) && values.validate) != null ? temp1 : alwaysValid), fieldTest = elementIsValid) : (keyTest = ((temp2 = Caf.exists(keys) && keys.postValidate) != null ? temp2 : alwaysValid), valueTest = ((temp3 = Caf.exists(values) && values.postValidate) != null ? temp3 : alwaysValid), value = preprocess(value), fieldTest = elementIsPostValid), fieldTest ? compactFlatten(Caf.array(value, (v, k) => {let path, keyPath; path = joinFieldPath(fieldPath, k); return [(!keyTest(k)) ? (keyPath = path + "(the key itself)", Caf.isF(keys.getValidationErrors) && keys.getValidationErrors(k, keyPath, forCreate) || {value: k, fieldPath: keyPath, errorIs: standardInvalidMessage(keys, k)}) : undefined, (!valueTest(k)) ? Caf.isF(values.getValidationErrors) && values.getValidationErrors(v, path, forCreate) || {value: v, fieldPath: path, errorIs: standardInvalidMessage(values, v)} : undefined];}, (v, k) => !fieldTest(v, k))) : undefined);}}; default: return fieldProps;};})();}; processingCustomFieldTypePath = []; normalizeStringFieldProp = function(fieldPropString, validatorOptions) {let customFieldType, customFieldTypeProps, namedFieldTypeProps; return (customFieldType = validatorOptions.customFieldTypes[fieldPropString]) ? (() => {try {if (Caf.in(fieldPropString, processingCustomFieldTypePath)) {throw new ConfigurationError(validatorOptions.getNiceErrorMessage(`Invalid custom fields. Recursive custom field types are not supported. Recursive path: ${Caf.toString(processingCustomFieldTypePath.join(" > "))} > ${Caf.toString(fieldPropString)}`));}; processingCustomFieldTypePath.push(fieldPropString); if (isPlainObject(customFieldType) || isString(customFieldType)) {customFieldTypeProps = _normalizeFieldProps(customFieldType, validatorOptions);} else {throw new ConfigurationError(validatorOptions.getNiceErrorMessage("Invalid custom field type. Expected fieldPropString or plain object", customFieldType));}; return merge(customFieldTypeProps, {fieldType: fieldPropString});} finally {processingCustomFieldTypePath.pop();};})() : (namedFieldTypeProps = FieldTypes[fieldPropString]) ? merge(namedFieldTypeProps, {fieldType: fieldPropString}) : {[fieldPropString]: true};}; normalizeFieldPropsStructure = function(fieldProps, validatorOptions) {return compactFlatten(Caf.array(compactFlattenAll(fieldProps), (element) => {let rawEnum, fieldType; return (() => {switch (false) {case !isString(element): return w(element); case !isPlainObject(element): element = normalizeRecursivePlainObjectProps(element, validatorOptions); return ((rawEnum = element.enum) != null) ? createEnumFieldType(element) : (fieldType = element.fieldType) ? (FieldTypes[fieldType] || validatorOptions.customFieldTypes[fieldType]) ? [element.fieldType, element] : (() => {throw new ConfigurationError(validatorOptions.getNiceErrorMessage(`Invalid, explicit fieldType. Valid fieldTypes: ${Caf.toString(Object.keys(merge(FieldTypes, validatorOptions.customFieldTypes)).sort().join(", "))}`, fieldType));})() : element; case !(element === true): return FieldTypes.any; default: return (() => {throw new ConfigurationError(validatorOptions.getNiceErrorMessage("Invalid fieldProps. Expected string, plainObject, or array of strings, plainObjects and/or arrays", element));})();};})();}));}; _normalizeFieldProps = function(fieldProps, validatorOptions) {let normalizedFieldProps; Caf.each2(normalizeFieldPropsStructure(fieldProps, validatorOptions), (fieldProps) => mergeInto(normalizedFieldProps, (() => {switch (false) {case !isString(fieldProps): return normalizeStringFieldProp(fieldProps, validatorOptions); case !isPlainObject(fieldProps): fieldProps = preExpandStandardValidationProps(fieldProps, validatorOptions); fieldProps = normalizeDeprecatedProps(fieldProps, validatorOptions); return fieldProps = normalizeRecursiveFieldProps(fieldProps, validatorOptions); default: return (() => {throw new ConfigurationError(validatorOptions.getNiceErrorMessage("Internal failure. Should not be possible to get here.", fieldProps));})();};})()), null, normalizedFieldProps = {}); return normalizeAllStandardValidations(normalizedFieldProps, validatorOptions);}; normalizeValidatorOptions = function(validatorOptions) {let temp; return merge(validatorOptions, {customFieldTypes: ((temp = Caf.exists(validatorOptions) && validatorOptions.customFieldTypes) != null ? temp : {}), getNiceErrorMessage: function(message, invalidInput) {let joiner, inspected; joiner = ". "; return compact([message, (invalidInput && invalidInput !== this.rawFieldProps) ? (inspected = formattedInspect(invalidInput), /\n/.test(inspected) ? (joiner = "\n", inspected = "\n  " + inspected.replace(/\n/g, "\n  ")) : undefined, `Got: ${Caf.toString(inspected)}`) : undefined, this.fieldName ? `Field ${Caf.toString(this.fieldName)}:` : undefined, this.rawFieldProps ? (inspected = formattedInspect(this.rawFieldProps), /\n/.test(inspected) ? (joiner = "\n", inspected = "\n  " + inspected.replace(/\n/g, "\n  ")) : undefined, `Raw fieldProps: ${Caf.toString(inspected)}`) : undefined]).join(joiner);}});}; return {normalizeFieldProps: function(fieldProps, validatorOptions) {validatorOptions = normalizeValidatorOptions(validatorOptions); validatorOptions.rawFieldProps = fieldProps; return _normalizeFieldProps(fieldProps, validatorOptions);}, normalizeFields: function(fields, validatorOptions) {validatorOptions = normalizeValidatorOptions(validatorOptions); return Caf.object(fields, (fieldProps, fieldName) => {validatorOptions.fieldName = fieldName; validatorOptions.rawFieldProps = fieldProps; return _normalizeFieldProps(fieldProps, validatorOptions);});}};});});
//# sourceMappingURL=FieldPropNormalizer.js.map
