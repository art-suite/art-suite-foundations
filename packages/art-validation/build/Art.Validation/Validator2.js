"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseObject", "Error", "compactFlatten", "merge", "toInspectedObjects", "isFunction", "isString", "parseInt", "isBoolean", "isNumber", "isRegExp", "isArray", "isPlainObject", "Object", "compactFlattenAll"], [global, require('art-standard-lib'), require('art-class-system')], (BaseObject, Error, compactFlatten, merge, toInspectedObjects, isFunction, isString, parseInt, isBoolean, isNumber, isRegExp, isArray, isPlainObject, Object, compactFlattenAll) => {let identityNormalizer, alwaysValidValidator, Validator2, validatorBuilder, validator, createUnionValidator, uuidPattern; identityNormalizer = function(value) {return value;}; alwaysValidValidator = function() {return true;}; Validator2 = Caf.defClass(class Validator2 extends BaseObject {constructor(options) {let temp, temp1, temp2, temp3; super(...arguments); if (!isFunction(options.validate)) {throw new Error("validate function required");}; if (!isString(options.jsonDataType)) {throw new Error("jsonDataType required");}; this._options = options; this._validator = options.validate; this._normalizer = ((temp = options.normalize) != null ? temp : identityNormalizer); this._postValidator = ((temp1 = options.postValidate) != null ? temp1 : alwaysValidValidator); this._validationErrorGenerator = options.getValidationErrors; this._isRequired = !!(((temp2 = options.required) != null ? temp2 : false)); this._isExclusive = !!(((temp3 = options.exclusive) != null ? temp3 : false)); this._jsonDataType = options.jsonDataType; this._defaultValue = options.defaultValue; this._structure = options.structure; this._descriptionValue = options.description; this._patternValue = options.pattern; this._enumValue = options.enum; this._formatValue = options.format;};}, function(Validator2, classSuper, instanceSuper) {this.getter("isRequired", "isExclusive", "jsonDataType", "defaultValue", "options"); this.getter("validator", "normalizer", "postValidator", "validationErrorGenerator"); this.getter("descriptionValue", "patternValue", "enumValue", "formatValue", "structure"); this.prototype.validate = function(value) {return !(value != null) ? !this.isRequired : this.validator(value) && this.normalizeAndPostValidate(value);}; this.prototype.normalize = function(value) {return this.normalizer(value);}; this.prototype.postValidate = function(value) {return this.postValidator(value);}; this.prototype.validated = function(value) {let normalized; if (!this.validate(value)) {throw new Error(`Invalid value: ${Caf.toString(value)}`);}; if (!(value != null)) {return value;}; normalized = this.normalize(value); if (!this.postValidate(normalized)) {throw new Error(`Invalid value: ${Caf.toString(value)} (post-validator failed)`);}; return normalized;}; this.prototype.getValidationErrors = function(value, parentFieldPath) {return compactFlatten((() => {switch (false) {case !(this.isRequired && !(value != null)): return [{value, fieldPath: parentFieldPath, errorIs: "required"}]; case !this.validationErrorGenerator: return this.validationErrorGenerator(value, parentFieldPath); case !(!this.validate(value)): return [{value, fieldPath: parentFieldPath, errorIs: "invalid"}]; case !(!this.normalizeAndPostValidate(value)): return [{value, fieldPath: parentFieldPath, errorIs: "invalid under post-validation"}]; default: return [];};})());}; this.prototype.normalizeAndPostValidate = function(value) {return this.postValidator(this.normalizer(value));}; this.getter({inspectedObjects: function() {return merge({isRequired: this.isRequired, isExclusive: this.isExclusive, jsonDataType: this.jsonDataType, defaultValue: this.defaultValue, descriptionValue: this.descriptionValue, patternValue: this.patternValue, enumValue: this.enumValue, formatValue: this.formatValue}, {structure: toInspectedObjects(this.structure)});}}); this.getter({optional: function() {return new Validator2(merge(this.options, {required: false}));}, required: function() {return new Validator2(merge(this.options, {required: true}));}}); this.prototype.withOptions = function(options) {return this.new(Validator2(merge(this.options, options)));}; this.prototype.withReplacedNormalizer = function(normalize) {return this.withOptions({normalize});}; this.prototype.withReplacedPostValidator = function(postValidate) {return this.withOptions({postValidate});}; this.prototype.addNormalizer = function(normalize) {return this.withOptions({normalize: (value) => normalize(this.normalize(value))});}; this.prototype.addPostValidator = function(postValidate) {return this.withOptions({postValidate: (value) => this.postValidate(value) && postValidate(value)});}; this.prototype.min = function(min) {return this.addPostValidator((value) => value >= min);}; this.prototype.max = function(max) {return this.addPostValidator((value) => value <= max);}; this.prototype.bound = function(min, max) {return this.addPostValidator((value) => value >= min && value <= max);}; this.prototype.minLength = function(min) {return this.addPostValidator((value) => value.length >= min);}; this.prototype.maxLength = function(max) {return this.addPostValidator((value) => value.length <= max);}; this.prototype.boundLength = function(min, max) {return this.addPostValidator((value) => value.length >= min && value.length <= max);}; this.prototype.trimmed = function() {return this.addNormalizer((value) => value.trim());}; this.prototype.description = function(description) {return this.withOptions({description});}; this.prototype.format = function(format) {return this.withOptions({format});}; this.prototype.pattern = function(pattern) {return this.withOptions({pattern});}; this.prototype.examples = function(examples) {return this.withOptions({examples});}; this.prototype.example = function(example) {return this.withOptions({examples: [example]});}; this.prototype.enum = function(values) {return this.withOptions({enum: values});}; this.prototype.default = function(defaultValue) {return this.withOptions({defaultValue});};}); validatorBuilder = (structure, options = {}) => {let exclusive, validate, regexp, subValidator, fieldValidators, fieldNames; return (Caf.is(structure, Validator2)) ? structure : (exclusive = options.exclusive, new Validator2(merge({structure}, (() => {switch (false) {case !(Caf.in(structure, ["string", "number", "boolean", "integer"])): return {jsonDataType: structure, normalize: (Caf.is(structure, "integer")) ? parseInt : identityNormalizer, validate: validate = (() => {switch (structure) {case "string": return isString; case "boolean": return isBoolean; default: return isNumber;};})(), getValidationErrors: (value, parentFieldPath) => validate(value) ? [] : [{value, fieldPath: parentFieldPath, errorIs: "an invalid-type"}]}; case !isRegExp(regexp = structure): return {jsonDataType: "string", pattern: regexp.source, validate: (value) => isString(value) && regexp.test(value), getValidationErrors: (value, parentFieldPath) => !isString(value) ? [{value, fieldPath: parentFieldPath, errorIs: "not a string"}] : !regexp.test(value) ? [{value, fieldPath: parentFieldPath, errorIs: `does not match ${Caf.toString(structure)}`}] : []}; case !isArray(structure): subValidator = (() => {switch (false) {case !(structure.length === 1): return validator(structure[0], {exclusive}); case !(structure.length > 1): return (() => {throw new Error("validator array definitions can have zero or one element");})();};})(); return {jsonDataType: "array", validate: validate = !subValidator ? isArray : (anArray) => isArray(anArray) && anArray.every((v) => subValidator.validate(v)), getValidationErrors: (value, parentFieldPath) => {let from, into, to, i1, temp; return !isArray(value) ? [{value, fieldPath: parentFieldPath, errorIs: "not an array"}] : subValidator ? (from = value, into = [], (from != null) ? (to = from.length, i1 = 0, (() => {while (i1 < to) {let element, i; element = from[i1]; i = i1; into.push(subValidator.getValidationErrors(element, `${Caf.toString(parentFieldPath)}[${Caf.toString(i)}]`)); temp = i1++;}; return temp;})()) : undefined, into) : [];}}; case !isPlainObject(structure): fieldValidators = Caf.object(structure, (v) => validator(v, {exclusive})); fieldNames = Object.keys(fieldValidators); return {jsonDataType: "object", validate: (value) => isPlainObject(value) && !Caf.find(fieldValidators, (validator, key) => true, (validator, key) => !validator.validate(value[key])) && (!exclusive || Object.keys(value).every((key) => !!fieldValidators[key])), getValidationErrors: (value, parentFieldPath) => !isPlainObject(value) ? [{value, fieldPath: parentFieldPath, errorIs: "not an object"}] : compactFlattenAll(Caf.array(fieldValidators, (v, key) => v.getValidationErrors(value[key], parentFieldPath ? `${Caf.toString(parentFieldPath)}.${Caf.toString(key)}` : key)), exclusive ? Caf.array(value, (v, key) => {return {value: value[key], fieldPath: parentFieldPath ? `${Caf.toString(parentFieldPath)}.${Caf.toString(key)}` : key, errorIs: "an unexpected field"};}, (v, key) => !fieldValidators[key]) : undefined)}; default: return (() => {throw new Error("Invalid validation-definition structure");})();};})())));}; validator = function(structure) {return validatorBuilder(structure);}; validator.inclusive = function(structure) {return validatorBuilder(structure);}; validator.exclusive = function(structure) {return validatorBuilder(structure, {exclusive: true});}; validator.custom = function(options) {return new Validator2(options);}; validator.required = function(s) {return validator(s).required;}; validator.optional = function(s) {return validator(s).optional;}; createUnionValidator = function(exclusive) {return (...validatorStructures) => {let validators; validators = Caf.array(validatorStructures, (structure) => validatorBuilder(structure, {exclusive})); return validator.custom({validate: (value) => Caf.find(validators, (v, k) => true, (v, k) => v.validate(value)), jsonDataType: validators[0].jsonDataType});};}; validator.union = createUnionValidator(false); validator.union.inclusive = createUnionValidator(false); validator.union.exclusive = createUnionValidator(true); validator.enum = function(...legalValues) {return validator("string").addPostValidator((value) => Caf.in(value, legalValues)).enum(legalValues);}; uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i; validator.string = validator("string"); validator.number = validator("number"); validator.boolean = validator("boolean"); validator.integer = validator("integer"); return {validator};});});
//# sourceMappingURL=Validator2.js.map
