"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "normalizeFieldProps", "pushIfNotPresent", "log", "Promise", "Error", "ErrorWithInfo", "present", "shallowClone"], [global, require('art-standard-lib'), require('art-class-system'), require('./DataTypes'), require('./Lib'), {FieldTypes: require('./FieldTypes'), DataTypes: require('./DataTypes')}], (BaseClass, normalizeFieldProps, pushIfNotPresent, log, Promise, Error, ErrorWithInfo, present, shallowClone) => {let Validator; return Validator = Caf.defClass(class Validator extends BaseClass {constructor(fieldDeclarationMap, options) {super(...arguments); if (options) {this.exclusive = options.exclusive; this.context = options.context; this._customFieldTypes = options.customFieldTypes;}; this._fieldProps = {}; this._requiredFields = []; this.addFields(fieldDeclarationMap);};}, function(Validator, classSuper, instanceSuper) {let validateCreate, validateUpdate, preprocessFields; this.normalizeFields = function(fields, customFields) {return Caf.object(fields, (f) => normalizeFieldProps(f, customFields));}; this.normalizeFieldProps = normalizeFieldProps; this.property("exclusive"); this.prototype.addFields = function(fieldDeclarationMap) {Caf.each2(fieldDeclarationMap, (fieldOptions, field) => {fieldOptions = this._addField(field, fieldOptions); return (fieldOptions.required || fieldOptions.present) ? pushIfNotPresent(this._requiredFields, field) : undefined;}); return null;}; this.getter("customFieldTypes", {fields: function() {return this._fieldProps;}, inspectedObjects: function() {return {Validator: this._fieldProps};}}); this.prototype.preCreate = function(fields, options) {log.error("Validator.preCreate is DEPRICATED. Use .validate or .validateCreate"); return Promise.resolve(fields).then((fields) => this.preCreateSync(fields, options));}; this.prototype.preUpdate = function(fields, options) {log.error("Validator.preUpdate is DEPRICATED. Use .validateUpdate"); return Promise.resolve(fields).then((fields) => this.preUpdateSync(fields, options));}; this.prototype.validateSync = function() {return (() => {throw new Error("DEPRICATED: use validate");})();}; this.prototype.preCreateSync = function(fields = {}, options) {log.error("preCreateSync is DEPRICATED. use .validateCreate or just .validate"); return this.validateCreate(fields, options);}; this.prototype.preUpdateSync = function(fields = {}, options) {log.error("preUpdateSync is DEPRICATED. use validateUpdate"); return this.validateUpdate(fields, options);}; this.prototype.validateCreate = validateCreate = function(fields = {}, options) {let processedFields, error; processedFields = null; return (() => {try {return this.requiredFieldsPresent(fields) && this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocess(fields, true));} catch (error1) {error = error1; return log.error({Validator: {error_in: {validateCreate: {fields, options, this: [this, error]}}}});};})() || this._throwError(fields, processedFields, options, true);}; this.prototype.validate = validateCreate; this.prototype.validateUpdate = validateUpdate = function(fields = {}, options) {let processedFields, error; return (() => {try {return this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocess(fields));} catch (error1) {error = error1; return log.error({Validator: {error_in: {validateUpdate: {fields, options, this: [this, error]}}}});};})() || this._throwError(fields, processedFields, options);}; this.prototype._throwError = function(fields, processedFields, options, forCreate) {let info, errors, messageFields, message, temp; info = {errors: errors = {}}; messageFields = []; Caf.array(this.invalidFields(fields), (f) => {errors[f] = "invalid"; return (this.exclusive && !this._fieldProps[f]) ? `unexpected '${Caf.toString(f)}' field` : `invalid ${Caf.toString(f)}`;}, null, messageFields); Caf.array(this.postInvalidFields(processedFields), (f) => {errors[f] = "invalid"; return `invalid processed ${Caf.toString(f)}`;}, null, messageFields); forCreate && Caf.array(this.missingFields(fields), (f) => {errors[f] = "missing"; return `missing ${Caf.toString(f)}`;}, null, messageFields); message = `${Caf.toString(((temp = Caf.exists(options) && options.context) != null ? temp : this.context))} ${Caf.toString(forCreate ? "create" : "update")}-validation failed. Invalid fields: ${Caf.toString(messageFields.join(", "))}`; info.fields = fields; return (() => {throw new ErrorWithInfo(message.trim(), info);})();}; this.prototype.presentFieldPostValid = function(fields, fieldName, value) {let fieldProps, postValidate; return (fieldProps = this._fieldProps[fieldName]) ? (({postValidate} = fieldProps), !postValidate || !(value != null) || value === null || value === undefined || postValidate(value, fieldName, fields)) : true;}; this.prototype.presentFieldValid = function(fields, fieldName, value) {let fieldProps, validate; return (fieldProps = this._fieldProps[fieldName]) ? (validate = fieldProps.validate, (fieldProps.present && !present(value)) ? false : !validate || !(value != null) || value === null || value === undefined || validate(value, fieldName, fields)) : !this.exclusive;}; this.prototype.requiredFieldPresent = function(fields, fieldName) {let fieldProps; return !(fieldProps = this._fieldProps[fieldName]) ? true : (fieldProps.required && !(fields[fieldName] != null)) ? false : (fieldProps.present && !present(fields[fieldName])) ? false : true;}; this.prototype.presentFieldsValid = function(fields) {return !Caf.find(fields, (fieldValue, fieldName) => !this.presentFieldValid(fields, fieldName, fieldValue));}; this.prototype.requiredFieldsPresent = function(fields) {return !Caf.find(this._fieldProps, (fieldValue, fieldName) => !this.requiredFieldPresent(fields, fieldName));}; this.prototype.postValidateFields = function(fields) {return !Caf.find(fields, (fieldValue, fieldName) => !this.presentFieldPostValid(fields, fieldName, fieldValue)) && fields;}; this.prototype.preprocess = preprocessFields = function(fields, applyDefaults) {let processedFields, temp; processedFields = null; if (applyDefaults) {fields != null ? fields : fields = {};}; fields && Caf.each2(this._fieldProps, (props, fieldName) => {let value, incomingValue; value = (undefined !== (incomingValue = fields[fieldName])) ? incomingValue : applyDefaults && props.default; if (props.preprocess && value != null) {value = props.preprocess(value, applyDefaults);}; return (value !== incomingValue) ? (processedFields != null ? processedFields : processedFields = shallowClone(fields), processedFields[fieldName] = value) : undefined;}); return ((temp = processedFields != null ? processedFields : fields) != null ? temp : {});}; this.prototype.preprocessFields = preprocessFields; this.prototype.invalidFields = function(fields) {return Caf.array(fields, (v, k) => k, (v, k) => !this.presentFieldValid(fields, k, v));}; this.prototype.postInvalidFields = function(fields) {return Caf.array(fields, (v, k) => k, (v, k) => !this.presentFieldPostValid(fields, k, v));}; this.prototype.missingFields = function(fields) {return Caf.array(this._requiredFields, (k) => k, (k) => !this.requiredFieldPresent(fields, k));}; this.prototype._addField = function(field, fieldProps) {return this._fieldProps[field] = normalizeFieldProps(fieldProps, this.customFieldTypes);};});});});
//# sourceMappingURL=Validator.js.map
