"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["BaseClass", "normalizeFields", "normalizeFieldProps", "pushIfNotPresent", "log", "Promise", "DeprecationError", "compactFlattenAll", "joinFieldPath", "makeEmptyArraysIntoNulls", "standardInvalidMessage", "peek", "ValidationError", "getDefaultValue", "present", "shallowClone"], [global, require('./StandardImport'), require('./DataTypes'), require('./FieldPropNormalizer'), require('./Tools'), require('./ErrorTypes'), {FieldTypes: require('./FieldTypes'), DataTypes: require('./DataTypes')}], (BaseClass, normalizeFields, normalizeFieldProps, pushIfNotPresent, log, Promise, DeprecationError, compactFlattenAll, joinFieldPath, makeEmptyArraysIntoNulls, standardInvalidMessage, peek, ValidationError, getDefaultValue, present, shallowClone) => {let Validator; return Validator = Caf.defClass(class Validator extends BaseClass {constructor(fieldDeclarationMap, validatorOptions) {super(...arguments); if (validatorOptions) {this._validatorOptions = validatorOptions; this.exclusive = validatorOptions.exclusive; this.context = validatorOptions.context; this.customFieldTypes = validatorOptions.customFieldTypes; this.customTags = validatorOptions.customTags;}; this._fieldProps = {}; this._requiredFields = []; this.addFields(fieldDeclarationMap);};}, function(Validator, classSuper, instanceSuper) {let validateCreate, isValidCreate, validateUpdate, preprocessFields; this.normalizeFields = normalizeFields; this.normalizeFieldProps = normalizeFieldProps; this.property("exclusive", "context", "customFieldProps", "customTags"); this.prototype.addFields = function(fieldDeclarationMap) {return Caf.each2(fieldDeclarationMap, (fieldOptions, field) => {fieldOptions = this._addField(field, fieldOptions); return (fieldOptions.required || fieldOptions.present) ? pushIfNotPresent(this._requiredFields, field) : undefined;});}; this.getter({fields: function() {return this._fieldProps;}, inspectedObjects: function() {return {Validator: this._fieldProps};}}); this.prototype.preCreate = function(fields, options) {log.error("Validator.preCreate is DEPRECATED. Use .validate or .validateCreate"); return Promise.resolve(fields).then((fields) => this.preCreateSync(fields, options));}; this.prototype.preUpdate = function(fields, options) {log.error("Validator.preUpdate is DEPRECATED. Use .validateUpdate"); return Promise.resolve(fields).then((fields) => this.preUpdateSync(fields, options));}; this.prototype.validateSync = function() {return (() => {throw new DeprecationError("DEPRECATED: use validate");})();}; this.prototype.preCreateSync = function(fields = {}, options) {log.error("preCreateSync is DEPRECATED. use .validateCreate or just .validate"); return this.validateCreate(fields, options);}; this.prototype.preUpdateSync = function(fields = {}, options) {log.error("preUpdateSync is DEPRECATED. use validateUpdate"); return this.validateUpdate(fields, options);}; this.prototype.validateCreate = validateCreate = function(fields = {}, options) {let processedFields, error; processedFields = null; return (() => {try {return this.requiredFieldsPresent(fields) && this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocess(fields, true));} catch (error1) {error = error1; return log.error({Validator: {error_in: {validateCreate: {fields, options, this: [this, error]}}}});};})() || this._throwError(fields, processedFields, options, true);}; this.prototype.validate = function(fields, options, forCreate = true) {return forCreate ? this.validateCreate(fields, options) : this.validateUpdate(fields, options);}; this.prototype.isValidCreate = isValidCreate = function(fields) {return this.requiredFieldsPresent(fields) && this.presentFieldsValid(fields) && this.postValidateFields(this.preprocess(fields, true));}; this.prototype.isValidUpdate = function(fields) {let processedFields; return this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocess(fields));}; this.prototype.isValid = function(fields, forCreate = true) {return forCreate ? this.isValidCreate(fields) : this.isValidUpdate(fields);}; this.prototype.validateUpdate = validateUpdate = function(fields = {}, options) {let processedFields, error; return (() => {try {return this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocess(fields));} catch (error1) {error = error1; return log.error({Validator: {error_in: {validateUpdate: {fields, options, error, this: this}}}});};})() || this._throwError(fields, processedFields, options);}; this.prototype.getValidationErrors = function(fields, parentFieldPath, forCreate = true) {return compactFlattenAll((forCreate && !this.requiredFieldsPresent(fields)) ? Caf.array(this.getMissingFields(fields), (fieldName) => {return {value: fields[fieldName], fieldPath: joinFieldPath(parentFieldPath, fieldName), errorIs: "missing"};}) : undefined, Caf.array(this.getInvalidFields(fields), (fieldName) => {let value, fieldPath, base; value = fields[fieldName]; fieldPath = joinFieldPath(parentFieldPath, fieldName); return (this.exclusive && !this._fieldProps[fieldName]) ? {fieldPath, value, errorIs: "not one of the allowed fields"} : makeEmptyArraysIntoNulls(Caf.isF((base = this.fields[fieldName]).getValidationErrors) && base.getValidationErrors(value, fieldPath, forCreate)) || {fieldPath, value, errorIs: standardInvalidMessage(this.fields[fieldName], value)};}));}; this.prototype.getValidationErrorStrings = function(fields) {return this._getValidationErrorStrings(this.getValidationErrors(fields, "", true));}; this.prototype.getValidationErrorsString = function(fields) {return this._getValidationErrorsString(this.getValidationErrors(fields, "", true));}; this.prototype.getValidationErrorsInfo = function(fields) {return this._getValidationErrorsInfo(this.getValidationErrors(fields, "", true));}; this.prototype._getValidationErrorsInfo = function(validationErrors) {let from, into, to, i, temp; return {message: this._getValidationErrorsString(validationErrors), fields: (from = validationErrors, into = [], (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let fieldPath; ({fieldPath} = from[i]); into.push(fieldPath); temp = i++;}; return temp;})()) : undefined, into), errors: Caf.object(validationErrors, ({errorIs, fieldPath}) => errorIs, null, null, ({errorIs, fieldPath}) => fieldPath), invalidValues: Caf.object(validationErrors, ({value, fieldPath}) => value, null, null, ({value, fieldPath}) => fieldPath)};}; this.prototype._getValidationErrorStrings = function(validationErrors) {let from, into, to, i, temp; return (from = validationErrors, into = [], (from != null) ? (to = from.length, i = 0, (() => {while (i < to) {let fieldPath, errorIs; ({fieldPath, errorIs} = from[i]); into.push(`${Caf.toString(fieldPath)} is ${Caf.toString(errorIs)}`); temp = i++;}; return temp;})()) : undefined, into);}; this.prototype._getValidationErrorsString = function(validationErrors) {let invalidFieldLongForm, last, most; return (validationErrors.length > 0) ? (invalidFieldLongForm = this._getValidationErrorStrings(validationErrors), (invalidFieldLongForm.length > 1) ? (last = peek(invalidFieldLongForm), most = invalidFieldLongForm.slice(0, invalidFieldLongForm.length - 1), `${Caf.toString(most.join(", "))} and ${Caf.toString(last)}`) : invalidFieldLongForm[0]) : undefined;}; this.prototype._throwError = function(fields, processedFields, options, forCreate) {let info, temp; info = this._getValidationErrorsInfo(this.getValidationErrors(fields, "", forCreate)); return (() => {throw new ValidationError(`${Caf.toString(((temp = Caf.exists(options) && options.context) != null ? temp : this.context))} ${Caf.toString(forCreate ? "validation" : "update-validation")} failed: ${Caf.toString(info.message)}`.trim(), info);})();}; this.prototype.presentFieldPostValid = function(fields, fieldName, value) {let fieldProps, postValidate; return (fieldProps = this._fieldProps[fieldName]) ? (postValidate = fieldProps.postValidate, !postValidate || !(value != null) || postValidate(value, fieldName, fields)) : true;}; this.prototype.presentFieldValid = function(fields, fieldName, value) {let fieldProps, validate; return (fieldProps = this._fieldProps[fieldName]) ? (validate = fieldProps.validate, (fieldProps.required && !(value != null)) ? false : !validate || !(value != null) || validate(value, fieldName, fields)) : !this.exclusive;}; this.prototype.requiredFieldPresent = function(fields, fieldName) {let fieldProps, value, temp; return !(fieldProps = this._fieldProps[fieldName]) ? true : (value = ((temp = fields[fieldName]) != null ? temp : getDefaultValue(fieldName, fieldProps)), (fieldProps.required && !(value != null)) ? false : (fieldProps.present && !present(value)) ? false : true);}; this.prototype.presentFieldsValid = function(fields) {return !Caf.find(fields, (fieldValue, fieldName) => !this.presentFieldValid(fields, fieldName, fieldValue));}; this.prototype.requiredFieldsPresent = function(fields) {return !Caf.find(this._fieldProps, (fieldValue, fieldName) => !this.requiredFieldPresent(fields, fieldName));}; this.prototype.postValidateFields = function(fields) {return !Caf.find(fields, (fieldValue, fieldName) => !this.presentFieldPostValid(fields, fieldName, fieldValue)) && fields;}; this.prototype.preprocess = preprocessFields = function(fields, applyDefaults) {let processedFields, temp; processedFields = null; if (applyDefaults) {fields != null ? fields : fields = {};}; fields && Caf.each2(this._fieldProps, (props, fieldName) => {let value, incomingValue; value = (undefined !== (incomingValue = fields[fieldName])) ? incomingValue : applyDefaults ? getDefaultValue(fieldName, props) : undefined; if (props.preprocess && value != null) {value = props.preprocess(value, applyDefaults);}; return (value !== incomingValue) ? (processedFields != null ? processedFields : processedFields = shallowClone(fields), processedFields[fieldName] = value) : undefined;}); return ((temp = processedFields != null ? processedFields : fields) != null ? temp : {});}; this.prototype.preprocessFields = preprocessFields; this.prototype.getInvalidFields = function(fields) {return Caf.array(fields, (v, k) => k, (v, k) => !this.presentFieldValid(fields, k, v) || !this.presentFieldPostValid(fields, k, v));}; this.prototype.getMissingFields = function(fields) {return Caf.array(this._requiredFields, (k) => k, (k) => !this.requiredFieldPresent(fields, k));}; this.prototype._addField = function(field, fieldProps) {return this._fieldProps[field] = normalizeFieldProps(fieldProps, this._validatorOptions);};});});});
//# sourceMappingURL=Validator.js.map
