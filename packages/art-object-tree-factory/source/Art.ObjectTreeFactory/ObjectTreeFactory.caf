import &ArtStandardLib

mergeIntoBasic = (_into, source) ->
  object from-object source into _into

class ObjectTreeFactory

  ###
    IN: any order of args which are:
      plainObject-options: (optional)
        mergePropsInto: (intoProps, fromProps) ->
          function to merge arguments 1 on into props
          default: mergeIntoBasic

        inspectedName: string
          for introspection:
            Factory.getName() == inspectedName

        class: a class
          if specified, additioanl properties will be set on the Factory function:
            Factory.class = class
            Factory._name = class.getName() + "Factory"

            all concrete class-methods are made available in the Factory
            (see BaseObject.abstractClass)

        bind: string or array of strings
          NODE: class must be set
          list of method-names to bind from class onto the factory

        preprocessElement: (element, Factory) -> element
          can do custom preprocssing of each argument to the factory.

          defualt: preprocessElementBasic (no-op)

      function-nodeFactory: (optional) ->
        IN:
          props:    plain object mapping props to prop-values
          children: flat, compacted array of children nodes
        OUT:
          node

      class-nodeClass: class Foo extends BaseObject

    OUT: objectTreeFactory = ->
      IN:
        Arguments are compacted and flattened
        The resulting list of arguments can be any combination of:
          plainObjects for props (merged in the order they appear)
          other objects which become the 'children'

      OUT:
        object-tree-node generated by the nodeFactory
  preprocessElementBasic = (a) -> a
  @createObjectTreeFactory = (args...) =>
    options = klass = nodeFactory = null
    each a in args when a?
      switch
      when isClass a        then klass        = a
      when isFunction a     then nodeFactory  = a
      when isPlainObject a  then options      = a

    options extract?
      mergePropsInto, name, inspectedName = name, preprocessElement
      class as klass

    nodeFactory ?= if true
      log.warn "DEPRICATED: either 'nodeFactory' or 'class' is now required" unless klass?
      klass ?= class TreeFactoryNode extends &ArtClassSystem.BaseClass
        constructor: (@props, @children) ->

      (props, children) -> new klass props, children

    _bindFactoryInfo
      _createFactory nodeFactory, preprocessElement, mergePropsInto
      inspectedName
      klass
      options?.bind

  ###
    IN:
      options: (optional; omit if not used)
      list: a string or abitrary structure of arrays, nulls and strings
        each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
      nodeFactory: (nodeTypeName, props, children) -> node
        IN:
          nodeTypeName: node-type name
          props:    plain object mapping props to prop-values
          children: flat, compacted array of children nodes
        OUT:
          node
    OUT:
      map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory

    TODO:
      PERFORMANCE TEST:
        createObjectTreeFactoriesFromFactories
        vs
        createObjectTreeFactoriesFromFactoryFactories

        The latter is probably faster. It is also more powerful and generally cleaner.
  @createObjectTreeFactories: (options, list, nodeFactory) =>
    unless nodeFactory
      [list, nodeFactory] = [options, list]
      options = {}

    if nodeFactory.length == 1
      @_createObjectTreeFactoriesFromFactoryFactories options, list, nodeFactory
    else
      @_createObjectTreeFactoriesFromFactories options, list, nodeFactory

  @_createObjectTreeFactoriesFromFactories: (options, list, nodeFactory) =>
    suffix = options.suffix || ''

    out = {}
    each nodeTypeName in compactFlattenObjectTreeNodeNames list
      do (nodeTypeName) =>
        options.inspectedName = nodeTypeName
        out[upperCamelCase(nodeTypeName) + suffix] = @createObjectTreeFactory options,
          (props, children) -> nodeFactory nodeTypeName, props, children
    out

  nodeNameRegexp = /[a-z0-9_]+/ig
  @_compactFlattenObjectTreeNodeNames: compactFlattenObjectTreeNodeNames = (list) ->
    return list.match nodeNameRegexp if isString list

    out = []
    each str in compactFlattenFast list
      out = out.concat str.match nodeNameRegexp
    out

  @_createObjectTreeFactoriesFromFactoryFactories: (options, list, nodeFactoryFactory) =>
    suffix = options.suffix || ''

    out = {}
    each nodeTypeName in compactFlattenObjectTreeNodeNames list
      nodeFactory = nodeFactoryFactory nodeTypeName
      name = upperCamelCase(nodeTypeName) + suffix
      options.inspectedName = name
      out[name] = @createObjectTreeFactory options, nodeFactory
    out

  ########################
  # PRIVATE
  ########################

  _createFactory = (nodeFactory, preprocessElement, mergePropsInto)->
    mergePropsInto    ?= mergeIntoBasic
    preprocessElement ?= preprocessElementBasic

    _children = _props = _oneProps = undefined

    applyArg = (element) ->
      if rubyTrue element = preprocessElement element, Factory
        switch element.constructor
        when Object
          unless _oneProps
            _oneProps = element

          else
            unless _props
              mergePropsInto
                _props = {}
                _oneProps

            mergePropsInto _props, element

        when Array
          each el2 from-array element
            applyArg el2

        else
          _children ?= []
          .push element

      null

    Factory = (elements...)->
      _children = _props = _oneProps = undefined

      each element from-array elements
        applyArg element

      nodeFactory _props || _oneProps, _children

  _bindFactoryInfo = (Factory, name, klass, bindList) ->
    if klass
      name ?= klass.getName?()

      Factory.class = klass
      klass.Factory = Factory

      abstractClass = klass.getAbstractClass?() || Object
      bindList = compactFlattenFast []
        array v, k from-object klass when !abstractClass[k] && isFunction v
          k
        bindList

      name ?= klass.getName() + :Factory

      each k in bindList
        Factory[k] = fastBind klass[k], klass

    Factory._name = name ?= :ObjectTreeFactory

    # show nice output when inspected
    Factory.inspect = -> "<#{name}>"

    Factory
