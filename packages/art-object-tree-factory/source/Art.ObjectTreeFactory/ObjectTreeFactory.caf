import &ArtStandardLib

mergeIntoBasic = (_into, source) ->
  object from-object source into _into

preprocessElementBasic = (a) -> a
class ObjectTreeFactory

  ### createObjectTreeFactory
    IN: any order of args which are:
      plainObject-options: (optional)
        mergePropsInto: (intoProps, fromProps) ->
          function to merge arguments 1 on into props
          default: mergeIntoBasic

        inspectedName: string
          for introspection:
            Factory.getName() == inspectedName

        class: a class
          if specified, additioanl properties will be set on the Factory function:
            Factory.class = class
            Factory._name = class.getName() + "Factory"

            all concrete class-methods are made available in the Factory
            (see BaseObject.abstractClass)

        bind: string or array of strings
          NODE: class must be set
          list of method-names to bind from class onto the factory

        preprocessElement: (element, Factory) -> element
          can do custom preprocssing of each argument to the factory.

          defualt: preprocessElementBasic (no-op)

      function-nodeFactory: (optional) ->
        IN:
          props:    plain object mapping props to prop-values
          children: flat, compacted array of children nodes
        OUT:
          node

      class-nodeClass: class Foo extends BaseObject

    OUT: objectTreeFactory = ->
      IN:
        Arguments are compacted and flattened
        The resulting list of arguments can be any combination of:
          plainObjects for props (merged in the order they appear)
          other objects which become the 'children'

      OUT:
        object-tree-node generated by the nodeFactory
  @createObjectTreeFactory = (args...) =>
    options = klass = nodeFactory = null
    each a in args when a?
      switch
      when isClass a        then klass        = a
      when isFunction a     then nodeFactory  = a
      when isPlainObject a  then options      = a

    options extract?
      mergePropsInto
      preprocessElement
      name
      inspectedName = name
      bind as bindList

    klass ?= options?.class

    unless nodeFactory? != klass?
      throw new Error "" Must pass exactly one Function or one Class

    @_bindFactoryInfo
      _makeCreateFactory()
        nodeFactory ? (props, children) -> new klass props, children
        preprocessElement ? preprocessElementBasic
        mergePropsInto ? mergeIntoBasic
      inspectedName
      klass
      bindList

  ### createObjectTreeFactories
    IN: <in any order, any arbitrary array nesting - i.e. it uses a TreeFactory itself!>
      options: all plain-objects are merged into 'options'
        passed to createObjectTreeFactory (see above)

      strings: all strings are parsed into words and concatinated into the factory-names list
        used as the nodeTypeName to create a Tree-factory

      function: zero or one function
        nodeFactory: (nodeTypeName, props, children) -> node
        OR
        nodeFactoryFactory: (nodeTypeName) -> (props, children) -> node

    OUT:
      map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory

    TODO:
      PERFORMANCE TEST:
        createObjectTreeFactoriesFromFactories
        vs
        createObjectTreeFactoriesFromFactoryFactories

        The latter is probably faster. It is also more powerful and generally cleaner.
  @createObjectTreeFactories: null # defined below

  ########################
  # PRIVATE
  ########################

  # NOTE - for some reason, Chrome, Safary and Firefox are all 20-50% faster if I
  # create a whole new _createFactory function every time...
  _makeCreateFactory = -> eval
    ""
      (function(e,l,n){let f,u,r,t,i=(e=>{let a,c,s,h;e=l(e,f);if(e!=null&&e!==false){switch(e.constructor){case Object:if(r==null){r=e}else{if(u==null){n(u={},r)}n(u,e)}break;case Array:a=e;c=a;if(a!=null){s=a.length;h=0;while(h<s){let e;e=a[h];i(e);h++}}c;break;default:(t!=null?t:t=[]).push(e)}}return null});return f=((...l)=>{let n,f,a,c;t=u=r=undefined;n=l;f=n;if(n!=null){a=n.length;c=0;while(c<a){let e;e=n[c];i(e);c++}}f;return e(u||r,t)})});

  ## _createFactory = (nodeFactory, preprocessElement, mergePropsInto)->
    _children = _props = _oneProps = undefined

    applyArg = (element) ->
      element = preprocessElement element, Factory
      if element? && element != false
        switch element.constructor
        when Object
          unless _oneProps?
            _oneProps = element

          else
            unless _props?
              mergePropsInto
                _props = {}
                _oneProps

            mergePropsInto _props, element

        when Array
          each el2 from-array element
            applyArg el2

        else
          _children ?= []
          .push element

      null

    Factory = (elements...)->
      _children = _props = _oneProps = undefined

      each element from-array elements
        applyArg element

      nodeFactory _props || _oneProps, _children

  @_bindFactoryInfo: (Factory, name, klass, bindList) ->
    if klass
      name ?= klass.getName?()

      Factory.class = klass
      klass.Factory = Factory

      abstractClass = klass.getAbstractClass?() || Object
      bindList = compactFlattenFast []
        array v, k from-object klass when !abstractClass[k] && isFunction v
          k
        bindList

      name ?= klass.getName() + :Factory

      each k in bindList
        Factory[k] = fastBind klass[k], klass

    Factory._name = name ?= :ObjectTreeFactory

    # show nice output when inspected
    Factory.inspect = -> "<#{name}>"

    Factory

  ###############################
   DOGFOOD
  ###############################
  @createObjectTreeFactories: @createObjectTreeFactory
    mergePropsInto: (a, b) ->
      a.names = compactFlattenAllFast a.names, b.names
      object v, k from b into a when k != :names

    preprocessElement: (element) ->
      if isString element then names: w element
      else element

    (props, children) =>
      [nodeFactory] = children if children

      switch
      when isClass nodeClass = nodeFactory
        @_createObjectTreeFactoriesFromFactories
          props
          props.names
          (name, props, children) -> new nodeClass name, props, children

      when nodeFactory.length == 1
        @_createObjectTreeFactoriesFromFactoryFactories props, props.names, nodeFactory

      else
        @_createObjectTreeFactoriesFromFactories        props, props.names, nodeFactory

  ########################
  # PRIVATE
  ########################

  @_createObjectTreeFactoriesFromFactories: (options, list, nodeFactory) =>
    suffix = options.suffix || ''

    out = {}
    each nodeTypeName in list
      do (nodeTypeName) =>
        options.inspectedName = nodeTypeName
        out[upperCamelCase(nodeTypeName) + suffix] = @createObjectTreeFactory options,
          (props, children) -> nodeFactory nodeTypeName, props, children
    out

  @_createObjectTreeFactoriesFromFactoryFactories: (options, list, nodeFactoryFactory) =>
    suffix = options.suffix || ''

    out = {}
    each nodeTypeName in list
      nodeFactory = nodeFactoryFactory nodeTypeName
      name = upperCamelCase(nodeTypeName) + suffix
      options.inspectedName = name
      out[name] = @createObjectTreeFactory options, nodeFactory
    out
