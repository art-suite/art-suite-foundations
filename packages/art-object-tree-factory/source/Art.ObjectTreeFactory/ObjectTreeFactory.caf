import &ArtStandardLib

mergeIntoBasic = (_into, source) ->
  object from-object source into _into

preprocessElementBasic = (a) -> a

class ObjectTreeFactory

  ### createObjectTreeFactory
    IN: any order of args which are:
      plainObject-options: (optional)
        mergePropsInto: (intoProps, fromProps) ->
          function to merge arguments 1 on into props
          default: mergeIntoBasic

        inspectedName: string
          for introspection:
            Factory.getName() == inspectedName

        class: a class
          if specified, additioanl properties will be set on the Factory function:
            Factory.class = class
            Factory._name = class.getName() + "Factory"

            all concrete class-methods are made available in the Factory
            (see BaseObject.abstractClass)

        bind: string or array of strings
          NODE: class must be set
          list of method-names to bind from class onto the factory

        preprocessElement: (element, Factory) -> element
          can do custom preprocssing of each argument to the factory.

          defualt: preprocessElementBasic (no-op)

      function-nodeFactory: (optional) ->
        IN:
          props:    plain object mapping props to prop-values
          children: flat, compacted array of children nodes
        OUT:
          node

      class-nodeClass: class Foo extends BaseObject

    OUT: objectTreeFactory = ->
      IN:
        Arguments are compacted and flattened
        The resulting list of arguments can be any combination of:
          plainObjects for props (merged in the order they appear)
          other objects which become the 'children'

      OUT:
        object-tree-node generated by the nodeFactory
  @createObjectTreeFactory = (args...) =>
    options = klass = nodeFactory = null
    each a in args when a?
      switch
      when isClass a        then klass        = a
      when isFunction a     then nodeFactory  = a
      when isPlainObject a  then options      = a

    options extract?
      mergePropsInto
      preprocessElement
      name
      inspectedName = name
      bind as bindList
      class as klass

    nodeFactory ?= if true
      log.warn "DEPRICATED: either 'nodeFactory' or 'class' is now required" unless klass?
      klass ?= class TreeFactoryNode extends &ArtClassSystem.BaseClass
        constructor: (@props, @children) ->

      (props, children) -> new klass props, children

    @_bindFactoryInfo
      @_createFactory nodeFactory, preprocessElement, mergePropsInto
      inspectedName
      klass
      bindList

  ### createObjectTreeFactories
    IN: <in any order, any arbitrary array nesting - i.e. it uses a TreeFactory itself!>
      options: all plain-objects are merged into 'options'
        passed to createObjectTreeFactory (see above)

      strings: all strings are parsed into words and concatinated into the factory-names list
        used as the nodeTypeName to create a Tree-factory

      function: zero or one function
        nodeFactory: (nodeTypeName, props, children) -> node
        OR
        nodeFactoryFactory: (nodeTypeName) -> (props, children) -> node

    OUT:
      map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory

    TODO:
      PERFORMANCE TEST:
        createObjectTreeFactoriesFromFactories
        vs
        createObjectTreeFactoriesFromFactoryFactories

        The latter is probably faster. It is also more powerful and generally cleaner.
  @createObjectTreeFactories: null # defined below

  ########################
  # PRIVATE
  ########################
  nodeNameRegexp = /[a-z0-9_]+/ig
  @_compactFlattenObjectTreeNodeNames: (list) ->
    return list.match nodeNameRegexp if isString list

    out = []
    each str in compactFlattenFast list
      out = out.concat str.match nodeNameRegexp
    out

  @_createObjectTreeFactoriesFromFactories: (options, list, nodeFactory) =>
    suffix = options.suffix || ''

    out = {}
    each nodeTypeName in @_compactFlattenObjectTreeNodeNames list
      do (nodeTypeName) =>
        options.inspectedName = nodeTypeName
        out[upperCamelCase(nodeTypeName) + suffix] = @createObjectTreeFactory options,
          (props, children) -> nodeFactory nodeTypeName, props, children
    out

  @_createObjectTreeFactoriesFromFactoryFactories: (options, list, nodeFactoryFactory) =>
    suffix = options.suffix || ''

    out = {}
    each nodeTypeName in @_compactFlattenObjectTreeNodeNames list
      nodeFactory = nodeFactoryFactory nodeTypeName
      name = upperCamelCase(nodeTypeName) + suffix
      options.inspectedName = name
      out[name] = @createObjectTreeFactory options, nodeFactory
    out

  @_createFactory: (nodeFactory, preprocessElement, mergePropsInto)->
    mergePropsInto    ?= mergeIntoBasic
    preprocessElement ?= preprocessElementBasic

    _children = _props = _oneProps = undefined

    applyArg = (element) ->
      if rubyTrue element = preprocessElement element, Factory
        switch element.constructor
        when Object
          unless _oneProps
            _oneProps = element

          else
            unless _props
              mergePropsInto
                _props = {}
                _oneProps

            mergePropsInto _props, element

        when Array
          each el2 from-array element
            applyArg el2

        else
          _children ?= []
          .push element

      null

    Factory = (elements...)->
      _children = _props = _oneProps = undefined

      each element from-array elements
        applyArg element

      nodeFactory _props || _oneProps, _children

  @_bindFactoryInfo: (Factory, name, klass, bindList) ->
    if klass
      name ?= klass.getName?()

      Factory.class = klass
      klass.Factory = Factory

      abstractClass = klass.getAbstractClass?() || Object
      bindList = compactFlattenFast []
        array v, k from-object klass when !abstractClass[k] && isFunction v
          k
        bindList

      name ?= klass.getName() + :Factory

      each k in bindList
        Factory[k] = fastBind klass[k], klass

    Factory._name = name ?= :ObjectTreeFactory

    # show nice output when inspected
    Factory.inspect = -> "<#{name}>"

    Factory

  ###############################
   DOGFOOD
  ###############################
  @createObjectTreeFactories: @createObjectTreeFactory
    mergePropsInto: (a, b) ->
      a.names = compactFlattenAllFast a.names, b.names
      object v, k from b into a when k != :names

    preprocessElement: (element) ->
      if isString element then names: w element
      else element

    (props, children) =>
      [nodeFactory] = children if children

      if nodeFactory.length == 1
        @_createObjectTreeFactoriesFromFactoryFactories props, props.names, nodeFactory
      else
        @_createObjectTreeFactoriesFromFactories props, props.names, nodeFactory

