// Generated by CoffeeScript 1.12.7

/*

TODO:
  handlEvent alternate signature:
    (type, functionReturningEventElement) ->

  The function would only be invoked if there are actually event handlers for the specified type.
 */

(function() {
  var BaseClass, Event, EventManager, Log, arrayWith, clone, defineModule, inspect, isFunction, nextTick, rawErrorLog, ref, throwErrorOutOfStack,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, Log = ref.Log, nextTick = ref.nextTick, isFunction = ref.isFunction, inspect = ref.inspect, clone = ref.clone, arrayWith = ref.arrayWith, throwErrorOutOfStack = ref.throwErrorOutOfStack;

  BaseClass = require('art-class-system').BaseClass;

  Event = require("./Event");

  rawErrorLog = Log.rawErrorLog;

  defineModule(module, EventManager = (function(superClass) {
    extend(EventManager, superClass);

    function EventManager(parent) {
      this.parent = parent;
      this.eventHandlers = {};
    }

    EventManager.prototype.hasHandler = function(type) {
      var handlers;
      return !!((handlers = this.eventHandlers[type]) && handlers.length > 0);
    };

    EventManager.prototype.on = function(handlerMap) {
      var action, results, type;
      results = [];
      for (type in handlerMap) {
        action = handlerMap[type];
        if (!(action)) {
          continue;
        }
        if (!isFunction(action)) {
          throw new Error("EventManager: action is not a function for " + (inspect(type)) + " event handler. (action: " + (inspect(action)) + ", parent: " + (inspect(this.parent)) + ")");
        }
        results.push(this.eventHandlers[type] = arrayWith(this.eventHandlers[type], {
          action: action,
          oneTime: false
        }));
      }
      return results;
    };

    EventManager.prototype.removeListeners = function(handlerMap) {
      var action, beforeCount, count, handler, handlers, type;
      count = 0;
      for (type in handlerMap) {
        action = handlerMap[type];
        if (!(handlers = this.eventHandlers[type])) {
          continue;
        }
        beforeCount = handlers.length;
        this.eventHandlers[type] = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = handlers.length; i < len; i++) {
            handler = handlers[i];
            if (handler.action !== action) {
              results.push(handler);
            }
          }
          return results;
        })();
        count = beforeCount - this.eventHandlers[type].length;
      }
      return count;
    };

    EventManager.prototype.onNext = function(handlerMap) {
      var action, base, results, type;
      results = [];
      for (type in handlerMap) {
        action = handlerMap[type];
        if ((base = this.eventHandlers)[type] == null) {
          base[type] = [];
        }
        results.push(this.eventHandlers[type].push({
          action: action,
          oneTime: true
        }));
      }
      return results;
    };

    EventManager.prototype.countOneTimeHandlersFor = function(eventType) {
      var count, handler, handlers, i, len;
      count = 0;
      if (handlers = this.eventHandlers[eventType]) {
        for (i = 0, len = handlers.length; i < len; i++) {
          handler = handlers[i];
          if (handler.oneTime) {
            count++;
          }
        }
      }
      return count;
    };

    EventManager.prototype.handleEvent = function(event) {
      if (typeof event === "string") {
        event = new Event(event);
      }
      return this.sendToHandlers(event.type, event);
    };

    EventManager.prototype.handleEvents = function(events) {
      var event, i, len, results;
      results = [];
      for (i = 0, len = events.length; i < len; i++) {
        event = events[i];
        results.push(this.handleEvent(event));
      }
      return results;
    };

    EventManager.prototype.sendToHandlers = function(eventType, event) {
      var action, error, firedOneTimeHandler, handler, handlers, i, len;
      handlers = this.eventHandlers[eventType];
      if (!(handlers && handlers.length > 0)) {
        return;
      }
      firedOneTimeHandler = false;
      for (i = 0, len = handlers.length; i < len; i++) {
        handler = handlers[i];
        try {
          if (handler.oneTime) {
            handler.remove = firedOneTimeHandler = true;
          }
          action = handler.action;
          action(event);
        } catch (error1) {
          error = error1;
          this.handleErrorInHandler(handler, event, error);
        }
      }
      if (firedOneTimeHandler) {
        return this.eventHandlers[event.type] = (function() {
          var j, len1, ref1, results;
          ref1 = this.eventHandlers[eventType];
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            handler = ref1[j];
            if (!handler.remove) {
              results.push(handler);
            }
          }
          return results;
        }).call(this);
      }
    };

    EventManager.prototype.handleErrorInHandler = function(handler, event, error) {
      if (event.type === "eventException") {
        rawErrorLog("exception in eventException handler.\nEvent:" + (inspect(event, 1)) + ".\n\nError:\n" + error.stack);
        return throwErrorOutOfStack(error);
      } else if (this.eventHandlers["eventException"]) {
        return this.handleEvent(new Event("eventException", {
          event: clone(event),
          exception: error,
          handler: handler
        }));
      } else {
        rawErrorLog("exception in handler AND no eventException handler. Error:");
        rawErrorLog(error);
        rawErrorLog("Event: " + (inspect(event, 1)));
        rawErrorLog("Stack:\n" + error.stack);
        return throwErrorOutOfStack(error);
      }
    };

    return EventManager;

  })(BaseClass));

}).call(this);

//# sourceMappingURL=EventManager.js.map
