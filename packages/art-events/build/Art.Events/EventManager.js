"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["Log", "BaseClass", "isFunction", "Error", "inspect", "arrayWith", "isString", "Event", "throwErrorOutOfStack", "clone"], [global, require('art-standard-lib'), require('art-class-system'), {Event: require('./Event')}], (Log, BaseClass, isFunction, Error, inspect, arrayWith, isString, Event, throwErrorOutOfStack, clone) => {let rawErrorLog, EventManager; rawErrorLog = Log.rawErrorLog; return EventManager = Caf.defClass(class EventManager extends BaseClass {constructor(parent) {super(...arguments); this.parent = parent; this.eventHandlers = {};};}, function(EventManager, classSuper, instanceSuper) {this.prototype.hasHandler = function(type) {let handlers; return !!((handlers = this.eventHandlers[type]) && handlers.length > 0);}; this.prototype.on = function(handlerMap) {return Caf.each2(handlerMap, (action, type) => {if (!isFunction(action)) {throw new Error(`EventManager: action is not a function for ${Caf.toString(inspect(type))} event handler. (action: ${Caf.toString(inspect(action))}, parent: ${Caf.toString(inspect(this.parent))})`);}; return this.eventHandlers[type] = arrayWith(this.eventHandlers[type], {action, oneTime: false});}, (action, type) => action);}; this.prototype.removeListeners = function(handlerMap) {let count; count = 0; Caf.each2(handlerMap, (action, type) => {let handlers, beforeCount; handlers = this.eventHandlers[type]; beforeCount = handlers.length; this.eventHandlers[type] = Caf.array(handlers, null, (handler) => handler.action !== action); return count = beforeCount - this.eventHandlers[type].length;}, (action, type) => this.eventHandlers[type]); return count;}; this.prototype.onNext = function(handlerMap) {return Caf.each2(handlerMap, (action, type) => {let temp, base; ((temp = (base = this.eventHandlers)[type]) != null ? temp : base[type] = []); return this.eventHandlers[type].push({action, oneTime: true});});}; this.prototype.countOneTimeHandlersFor = function(eventType) {let count, handlers; count = 0; if (handlers = this.eventHandlers[eventType]) {Caf.each2(handlers, (handler) => count++, (handler) => handler.oneTime);}; return count;}; this.prototype.handleEvent = function(event) {if (isString(event)) {event = new Event(event);}; return this.sendToHandlers(event.type, event);}; this.prototype.handleEvents = function(events) {return Caf.each2(events, (event) => this.handleEvent(event));}; this.prototype.sendToHandlers = function(eventType, event) {let handlers, firedOneTimeHandler; handlers = this.eventHandlers[eventType]; if (!(handlers && handlers.length > 0)) {return;}; firedOneTimeHandler = false; Caf.each2(handlers, (handler) => {let action, error; return (() => {try {if (handler.oneTime) {handler.remove = firedOneTimeHandler = true;}; action = handler.action; return action(event);} catch (error1) {error = error1; return this.handleErrorInHandler(handler, event, error);};})();}); return firedOneTimeHandler ? this.eventHandlers[event.type] = Caf.array(this.eventHandlers[eventType], null, (handler) => !handler.remove) : undefined;}; this.prototype.handleErrorInHandler = function(handler, event, error) {return (event.type === "eventException") ? (rawErrorLog(`exception in eventException handler.\nEvent:${Caf.toString(inspect(event, 1))}.\n\nError:\n${Caf.toString(error.stack)}`), throwErrorOutOfStack(error)) : this.eventHandlers["eventException"] ? this.handleEvent(new Event("eventException", {event: clone(event), exception: error, handler})) : (rawErrorLog("exception in handler AND no eventException handler. Error:"), rawErrorLog(error), rawErrorLog(`Event: ${Caf.toString(inspect(event, 1))}`), rawErrorLog(`Stack:\n${Caf.toString(error.stack)}`), throwErrorOutOfStack(error));};});});});
//# sourceMappingURL=EventManager.js.map
