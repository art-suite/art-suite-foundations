"use strict"
let Caf = require('caffeine-script-runtime');
Caf.defMod(module, () => {return Caf.importInvoke(["EventedMixinCaf", "BaseClass", "test", "assert", "Promise", "Event", "Error", "nextTick"], [global, require('./StandardImport')], (EventedMixinCaf, BaseClass, test, assert, Promise, Event, Error, nextTick) => {let MyEventedObject; MyEventedObject = Caf.defClass(class MyEventedObject extends EventedMixinCaf(BaseClass) {}); test("event(), when no handler, returns false", function() {let eo; eo = new MyEventedObject; return assert.eq(false, eo.queueEvent("foo"));}); test("removeListeners", function() {let eo, listeners; eo = new MyEventedObject; eo.on(listeners = {foo: () => {}}); assert.eq(1, eo.eventManager.eventHandlers.foo.length); eo.removeListeners(listeners); assert.eq(0, eo.eventManager.eventHandlers.foo.length); return assert.eq(false, eo.queueEvent("foo"));}); test("event(), when there is a handler, returns the queued event object", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({foo: () => done()}); return assert.eq(true, eo.queueEvent("foo"));});}); test("handled event happens on nextTick", function() {return new Promise((done) => {let eo, count; eo = new MyEventedObject; count = 0; eo.on({foo: () => {assert.eq(count, 1); return done();}}); assert.eq(true, eo.queueEvent("foo")); return count++;});}); test("event creator function", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({foo: (e) => {assert.eq(e.props.bar, 123); return done();}}); return assert.eq(true, eo.queueEvent("foo", () => new Event("foo", {bar: 123})));});}); test("events handled in order they occured", function() {return new Promise((done) => {let eo, count; eo = new MyEventedObject; count = 0; eo.on({bar: () => {assert.eq(count, 2); return done();}}); eo.on({foo: () => {assert.eq(count, 1); return count++;}}); eo.queueEvent("foo"); eo.queueEvent("bar"); return count++;});}); test("show warning when queueing events when handling events", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({foo: () => eo.queueEvent("bar")}); eo.on({bar: () => done()}); return eo.queueEvent("foo");});}); test("show warning when handling events outside of an epoch", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({foo: () => done()}); return eo.handleEvent(new Event("foo"));});}); test("handleEvents", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({bar: () => {}, foo: done}); return eo.eventManager.handleEvents([new Event("bar"), new Event("foo")]);});}); test("handle event that throws an error", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({foo: () => (() => {throw new Error("myError");})(), eventException: done}); return eo.handleEvent(new Event("foo"));});}); test("handle unknown event returns false", function() {let eo; eo = new MyEventedObject; return assert.eq(false, eo.handleEvent(new Event("foo")));}); test("events queued at other times are OK", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.on({foo: () => nextTick(() => eo.queueEvent("bar"))}); eo.on({bar: () => done()}); return eo.queueEvent("foo");});}); return test("sequence of oneTime handlers", function() {return new Promise((done) => {let eo; eo = new MyEventedObject; eo.onNext({birthday: () => {eo.onNext({birthday: () => done()}); return eo.queueEvent("birthday");}}); return eo.queueEvent("birthday");});});});});
//# sourceMappingURL=EventedMixinCaf.test.js.map
