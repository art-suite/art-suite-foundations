// Generated by CoffeeScript 1.12.7
(function() {
  var Event, defineModule, eventEpoch, inspect, isFunction, isPlainObject, isString, log, ref, throwErrorOutOfStack,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('art-standard-lib'), defineModule = ref.defineModule, isString = ref.isString, isFunction = ref.isFunction, log = ref.log, isPlainObject = ref.isPlainObject, inspect = ref.inspect, throwErrorOutOfStack = ref.throwErrorOutOfStack;

  Event = require('./Event');

  eventEpoch = require('./EventEpoch').eventEpoch;


  /*
  to be used as a mixin via BaseObject's @include method
  
  If this class is included directly, you must also implement the methods
    listed in "TO IMPLEMENT" below.
   */

  defineModule(module, function() {
    return function(superClass) {
      var EventedBaseMixin;
      return EventedBaseMixin = (function(superClass1) {
        var typeFromEventOrType;

        extend(EventedBaseMixin, superClass1);

        function EventedBaseMixin() {
          return EventedBaseMixin.__super__.constructor.apply(this, arguments);
        }

        EventedBaseMixin.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
          return eventOrType && (eventOrType.type || eventOrType);
        };


        /*
        EFFECT: Queues an event to be handled next eventEpoch
        IN:
          eventOrType can be:
           * an instanceof Event or
           * a string representing the "type" of the event
              (a new Event will be created)
        
          eventPropertiesOrCreator can be:
           * null: only if eventOrType is an instanceof Event
           * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
           * Function: returns null (indicating a noop) or a new instanceof Event
        
        OUT:
          true:   The event was queued.
          false:  There is no handler for the event. The event was ignored (discarded).
         */

        EventedBaseMixin.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
          var eventType;
          eventType = typeFromEventOrType(eventOrType);
          if (eventType && this._hasEventHandler(eventType)) {
            eventEpoch.queue((function(_this) {
              return function() {
                return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
              };
            })(this));
            return true;
          } else {
            return false;
          }
        };


        /*
        EFFECT:
          If there is no handler for the specified event-type:
            returns immediately without further processing.
          else
            event is normalized and handled immediately
        
        IN: SEE: normalizeEvent
        
        OUT: true if the event was actually handled
        
        IMPORTANT: This should only be called during an eventEpoch.
          This means:
            Usually, just don't call this directly. Use @queueEvent.
            If you need to call this directly, only do it from within an event handler.
          Examples reasons to call directly:
            - to do custom event routing
            - send a new event triggered from the first
         */

        EventedBaseMixin.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
          var e, event, eventType;
          eventType = typeFromEventOrType(eventOrType);
          if (!(eventType && this._hasEventHandler(eventType) && (event = this.normalizeEvent(eventOrType, eventPropertiesOrCreator)))) {
            return false;
          }
          event.target = this;
          try {
            this._sendToEventHandler(event);
          } catch (error1) {
            e = error1;
            this._handleErrorInHandler(event, "unknown", e);
          }
          event.target = null;
          return true;
        };


        /*
        IN:
          (event)
            event: Event instance
        
          OR
        
          (eventType, eventPropertiesOrCreator)
            eventType: string
        
            eventPropertiesOrCreator:
              function, invoked immediately:
                () ->
                  OUT:
                    event instance
                    OR
                    plain object - passed to Event constructor
              OR
                plain object - passed to Event constructor
              OR
                null
        
        OUT: Event instance or null
         */

        EventedBaseMixin.prototype.normalizeEvent = function(eventOrType, eventPropertiesOrCreator) {
          var e, eventCreator, eventType;
          if (eventOrType instanceof Event) {
            return eventOrType;
          } else {
            if (!isString(eventType = eventOrType)) {
              throw new Error("expected event or event-type-string");
            }
            if (isFunction(eventCreator = eventPropertiesOrCreator)) {
              e = eventCreator();
              switch (false) {
                case !(e instanceof Event):
                  return e;
                case !isPlainObject(e):
                  return new Event(eventType, e);
                case e == null:
                  throw new Error("expecting event or plain-object");
                  break;
                default:
                  return null;
              }
            } else {
              return new Event(eventType, eventPropertiesOrCreator);
            }
          }
        };


        /*
        inputs: eventType is a string
        outputs: true if there is a handler for the specified type
         */

        EventedBaseMixin.prototype._hasEventHandler = function(eventType) {
          throw new Error("must implement");
        };


        /*
        inputs: an Event object with event.target set to @
        output: ignored
        
        - Called exclusively from handleEvent. Don't call manually.
        - This is where the event handler is actually called.
        - Only called during an eventEpoch.
        - Only called if @_hasEventHandler returned true for event.type
         */

        EventedBaseMixin.prototype._sendToEventHandler = function(event) {
          throw new Error("must implement");
        };

        EventedBaseMixin.prototype._handleErrorInHandler = function(event, handler, error) {
          console.log("EventedObjectBase: exception in handler. Error:", error);
          console.log("Event: " + (inspect(event, 1)));
          console.log("Handler:", handler);
          console.log("Stack:", error.stack);
          return throwErrorOutOfStack(error);
        };

        return EventedBaseMixin;

      })(superClass);
    };
  });

}).call(this);

//# sourceMappingURL=EventedBaseMixin.js.map
