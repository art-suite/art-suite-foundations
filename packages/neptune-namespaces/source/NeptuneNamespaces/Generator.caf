import &StandardImport, &Generators, &PackageRoot, {} &NamespaceStructure

class Generator

  ############################
  ############################
    CLASS
  ############################
  ############################

  @standardRoots:
    :source
    :test
    :performance
    :src
    :perf

  @generatedFilenameRegexp: /(^|\/)(namespace|index)\.(coffee|js)$/

  @extensions: :js :coffee :caffeine :caf

  @findVersionFile: (path) ->
    if packageRoot = getPackageRoot path
      Path.join packageRoot, "package.json"

  @infoLog: (root, args...) ->
    root = Path.basename root
    args = args.join()
    args = args.split "\n"
    each arg in args
      console.log if arg == ""
        ""
      else
        "Neptune.#{upperCamelCase root}: ".grey + arg

  @watch: (root, options = {}) ->
    @infoLog root, "watching...".green
    generator = null
    fsp.watch
      root
      {} options.persistent, recursive: true
      (event, filename) ->
        if event != :change && !filename.match @generatedFilenameRegexp
          @infoLog
            root
            "" watch event: ".bold.yellow + "#{event} #{filename.yellow}

          options.lastGenerator = generator if generator
          generator = new Generator root, options
          generator.generate()

  @generate: (globRoot, options = {}) ->
    Klass = @
    glob globRoot
    .then (roots) ->
      promiseSequence array root in roots when fsp.statSync(root).isDirectory()
        ->
          generator = new Klass root, options

          generator.generate()
          .then -> Generator.watch root, merge options, lastGenerator: generator if options.watch
          .catch (error) -> log error.stack

  ############################
  ############################
    INSTANCE
  ############################
  ############################

  constructor: (@root, options) ->
    throw new Error "root required" unless @root is String

    if options
      each option in :pretend :verbose :lastGenerator :force :quiet
        @[option] = options[option]

    @versionFile = @constructor.findVersionFile @root
    @rootPrefix = getParentPath @root

  infoLog:    (args...) -> @constructor.infoLog @_getRelativePath(), args.join() unless @quiet
  verboseLog: (args...) -> @infoLog args... if @verbose
  warningLog: (args...) -> @infoLog args... if @verbose # toString().yellow.bold

  generate: ->
    @constructor extract extensions
    @verboseLog "" \nscanning root: #{@root.yellow}

    glob "#{@root}/**/*.{#{extensions.join ','}}", dot: true
    .then (files) ->
      if files.length == 0
            @warningLog "" no .#{extensions.join ', .'} files found
      else  @generateFromFiles files

  showNamespaceStructure: (namespaces) ->
    @infoLog "generating namespace structure:"
    @infoLog "  Neptune".yellow
    each namespacePath in Object.keys(namespaces).sort()
      @infoLog "  #{namespacePath}".yellow
      each moduleName in namespaces[namespacePath].getModuleNames()
        @infoLog "    #{moduleName}".grey

  generateFiles: (namespaces) ->
    @generatedFiles = {}
    each namespace, namespacePath in namespaces
      {path} = namespace

      relativePath = @_getRelativePath path

      if @versionFile
        relativeVersionFile = Path.relative normalizeDirectory(path), @versionFile

      @_generateHelper
        relativePath: relativePath
        path: path
        name: :namespace
        code: @getNamespaceGenerator().generate namespace, relativeVersionFile

      @_generateHelper
        relativePath: relativePath
        path: path
        name: :index
        code: @getIndexGenerator().generate namespace

  getIndexGenerator:      -> IndexJsGenerator
  getNamespaceGenerator:  -> NamespaceJsGenerator

  ### generateFromFiles
    IN:
      files: Strings[]
        list of files with full paths
  generateFromFiles: (files) ->
    @_cleanup files

    {namespaces} = new NamespaceStructure {} @root, files

    @showNamespaceStructure namespaces if @verbose

    @generateFiles namespaces

    if @pretend
      Promise.resolve {} @generatedFiles, namespaces
    else
      @_writeFiles()

  ########################
    PRIVATE
  ########################

  _cleanup: (files) ->
    regex = /// ($|\/)(index|namespace).coffee$
    each file in files when regex.test file
      contents = (fsp.readFileSync file).toString()
      if /generated by neptune namespaces/i.test contents
        log "rm #{file}"
        fsp.unlinkSync file

  _writeFiles: ->
    filesWritten = 0
    filesTotal = 0
    Promise.all array code, name in @generatedFiles
      filesTotal++
      logFileString = @_getLogFileString name

      if @lastGenerator?.generatedFiles[name] == code
        @infoLog "no change: #{logFileString}".grey if @verbose

      else
        Promise.resolve if fsp.existsSync name
          fsp.readFile name, 'utf8'

        .then (currentContents) ->
          if @force || currentContents != code
            filesWritten++
            @infoLog "writing: #{logFileString.yellow}"
            fsp.writeFile name, code

        .catch (error) ->
          @infoLog "error reading #{logFileString}".red, error

    .then ->
      @infoLog "#{filesTotal - filesWritten}/#{filesTotal} files current" if filesWritten < filesTotal
      @infoLog "#{filesWritten}/#{filesTotal} files #{if @lastGenerator then 'changed' else 'written'}" if filesWritten > 0


  _getRelativePath: (path = @root) ->
    getRelativePath @rootPrefix, path

  _getLogFileString: (file) ->
    getRelativePath process.cwd(), file

  _generateHelper: ({path, relativePath, name, code}) ->
    name += :.js

    if @pretend
      @infoLog "\ngenerated: #{@_getLogFileString(name).yellow}"
      @infoLog indent code.green

    commentStart = ://
    code =
      """
        #{commentStart} #{generatedByStringBare}
        #{commentStart} file: #{relativePath}/#{name}

        #{code}

    @generatedFiles["#{path}/#{name}"] = code
