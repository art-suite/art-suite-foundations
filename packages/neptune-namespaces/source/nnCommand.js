// Generated by CoffeeScript 1.12.7
(function() {
  var Commander, Generator, NeptuneNamespaces, compactFlatten, log, promiseSequence, ref, root, run, standardRoots, version, withoutTrailingSlash;

  NeptuneNamespaces = require("./NeptuneNamespaces");

  ref = NeptuneNamespaces.MiniFoundation, log = ref.log, withoutTrailingSlash = ref.withoutTrailingSlash, promiseSequence = ref.promiseSequence, compactFlatten = ref.compactFlatten;

  version = NeptuneNamespaces.version, Generator = NeptuneNamespaces.Generator;

  standardRoots = (function() {
    var i, len, ref1, results;
    ref1 = Generator.standardRoots;
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      root = ref1[i];
      results.push(root + "/*");
    }
    return results;
  })();

  Commander = require("commander").version(version).usage('[options] <root ...>').option('-r, --root', 'list one or more --root arguments').option('-w, --watch', 'stay running, watch for changes, and automatically update').option('-v, --verbose', 'enable verbose output').option('-q, --quiet', 'suppress all output').option('-j, --js', 'output .js files instead of .coffee (experimental)').option('--cleanup', 'cleanup .coffee files if generating .js or visa-versa').option('-f, --force', 'overwrite all index and namespace files').option('-s, --std', "include the standard roots: " + (standardRoots.join(', '))).on("--help", function() {
    return console.log("Generates 'namespace.(js|coffee)' and 'index.(js|coffee)' files to bind each specified root to the global Neptune namespace at runtime. \n\nRun with -v to see everything NN is doing.");
  }).parse(process.argv);

  run = function(targetPaths, arg) {
    var cleanup, force, js, quiet, targetPath, todoList, verbose, watch;
    watch = arg.watch, verbose = arg.verbose, quiet = arg.quiet, force = arg.force, js = arg.js, cleanup = arg.cleanup;
    if (verbose) {
      console.log("neptune-namespaces (" + version + ")\n\nroots: " + (targetPaths.join(', ')));
      log({
        watch: watch,
        verbose: verbose,
        quiet: quiet,
        force: force,
        js: js,
        cleanup: cleanup
      });
    }
    todoList = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = targetPaths.length; i < len; i++) {
        targetPath = targetPaths[i];
        results.push((function(targetPath) {
          var doWork;
          targetPath = withoutTrailingSlash(targetPath);
          doWork = function() {
            return Generator.generate(targetPath, {
              verbose: verbose,
              force: force,
              quiet: quiet,
              watch: watch,
              cleanup: cleanup,
              js: js,
              persistent: true
            });
          };
          return doWork;
        })(targetPath));
      }
      return results;
    })();
    return promiseSequence(todoList);
  };

  root = Commander.args || [];

  if (Commander.std) {
    root = root.concat(standardRoots);
  }

  if (root.length === 0) {
    console.error("no roots specified (run with -h for help)");
  } else {
    run(root, Commander);
  }

}).call(this);
