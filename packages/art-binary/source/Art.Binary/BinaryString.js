// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, Binary, BinaryString, ClassSystem, InspectedObjectLiteral, Promise, StandardLib, Utf8, compactFlatten, encodings, inspect, isFunction, isNode, isPlainArray, isString, log, merge, min, pad, readFileAsArrayBuffer, readFileAsDataUrl,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Binary = require("./namespace");

  Utf8 = require("./Utf8");

  StandardLib = require('art-standard-lib');

  ClassSystem = require('art-class-system');

  merge = StandardLib.merge, isString = StandardLib.isString, isFunction = StandardLib.isFunction, isPlainArray = StandardLib.isPlainArray, log = StandardLib.log, min = StandardLib.min, inspect = StandardLib.inspect, readFileAsDataUrl = StandardLib.readFileAsDataUrl, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, compactFlatten = StandardLib.compactFlatten, pad = StandardLib.pad, InspectedObjectLiteral = StandardLib.InspectedObjectLiteral, Promise = StandardLib.Promise, isNode = StandardLib.isNode;

  BaseObject = ClassSystem.BaseObject, inspect = ClassSystem.inspect;

  encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  module.exports = BinaryString = (function(superClass) {
    var binary;

    extend(BinaryString, superClass);

    BinaryString.isBinary = function(arg) {
      var ref;
      return arg && ((arg instanceof BinaryString) || arg.constructor === ArrayBuffer || ((ref = arg.buffer) != null ? ref.constructor : void 0) === ArrayBuffer);
    };

    BinaryString.binary = binary = function(arg) {
      if (arg instanceof BinaryString) {
        return arg;
      } else {
        return new BinaryString(arg);
      }
    };

    BinaryString.binaryFromBlob = function(blob) {
      return readFileAsArrayBuffer(blob).then(function(ab) {
        return binary(ab);
      });
    };

    BinaryString.cloneUint8Array = function(srcU8A) {
      var dstU8A;
      dstU8A = new Uint8Array(new ArrayBuffer(src.length));
      dstU8A.set(srcU8A);
      return dstU8A;
    };

    function BinaryString(arg) {
      this.bytes = (function() {
        if (arg == null) {
          return new Uint8Array;
        } else if (arg instanceof BinaryString) {
          return BinaryString.cloneUint8Array(arg.bytes);
        } else if (isFunction(arg != null ? arg.uint8Array : void 0)) {
          return arg.uint8Array();
        } else if (isPlainArray(arg)) {
          return new Uint8Array(arg);
        } else if (arg instanceof ArrayBuffer) {
          return new Uint8Array(arg);
        } else if (arg instanceof Uint8Array) {
          return arg;
        } else if (arg.buffer instanceof ArrayBuffer) {
          return new Uint8Array(arg.buffer);
        } else if (isString(arg)) {
          return Utf8.toBuffer(arg);
        } else if (isFunction(arg.toString)) {
          return Utf8.toBuffer(arg.toString());
        } else {
          throw new Error("invalid Binary string constructor argument: " + (inspect(arg)));
        }
      })();
      this.length = this.bytes.length;
    }

    BinaryString.prototype.slice = function(a, b) {
      return new BinaryString(this.bytes.slice(a, b));
    };

    BinaryString.fromBase64 = function(base64encoding) {
      var byteString, i, j, len, ref, uint8Array;
      if (isNode) {
        return new BinaryString(Buffer.from(base64encoding, "base64"));
      } else {
        byteString = atob(base64encoding);
        len = byteString.length;
        uint8Array = new Uint8Array(new ArrayBuffer(len));
        for (i = j = 0, ref = len; j < ref; i = j += 1) {
          uint8Array[i] = byteString.charCodeAt(i);
        }
        return new BinaryString(uint8Array);
      }
    };

    BinaryString.prototype.toDataUri = function(mimeType, sync) {
      var v;
      if (isNode) {
        v = "data:" + (mimeType != null ? mimeType : '') + ";base64," + (this.toBase64(true));
        if (sync) {
          return v;
        } else {
          return Promise.resolve(v);
        }
      } else {
        return readFileAsDataUrl(this.toBlob(mimeType));
      }
    };

    BinaryString.fromDataUri = function(dataURI) {
      var base64encoding, splitDataURI;
      splitDataURI = dataURI.split(',');
      base64encoding = splitDataURI[1];
      return this.fromBase64(base64encoding);
    };

    BinaryString.prototype.toString = function() {
      return Utf8.toString(this.bytes);
    };

    BinaryString.prototype.getString = function() {
      return this.toString();
    };

    BinaryString.prototype.toArrayBuffer = function() {
      return this.bytes.buffer;
    };

    BinaryString.prototype.toBlob = function(mimeType) {
      return new Blob([this.bytes], merge({
        type: mimeType
      }));
    };

    BinaryString.prototype.eq = function(b) {
      return this.compare(b) === 0;
    };

    BinaryString.prototype.compare = function(b) {
      var bytesA, bytesB, diff, i, j, ref;
      bytesA = this.bytes;
      bytesB = b.bytes;
      for (i = j = 0, ref = min(this.length, b.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (0 !== (diff = bytesA[i] - bytesB[i])) {
          return diff;
        }
      }
      return this.length - b.length;
    };

    BinaryString.prototype.inspect = function() {
      return this.getInspectedString();
    };

    BinaryString.getter({
      uint8Array: function() {
        return this.bytes;
      },
      buffer: function() {
        var oldBytes;
        if (this.bytes.buffer.byteLength !== this.bytes.byteLength) {
          oldBytes = this.bytes;
          this.bytes = new Uint8Array(new ArrayBuffer(oldBytes.byteLength));
          this.bytes.set(oldBytes);
        }
        return this.bytes.buffer;
      },
      arrayBuffer: function() {
        return this.buffer;
      },
      nodeBuffer: function() {
        return Buffer.from(this.bytes);
      },
      blob: function() {
        return new Blob([this.bytes]);
      },
      plainArray: function() {
        var b, j, len1, ref, results;
        ref = this.bytes;
        results = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          b = ref[j];
          results.push(b);
        }
        return results;
      },
      byteLength: function() {
        return this.length;
      },
      inspectedObjects: function() {
        var lenStr;
        lenStr = this.length >= 10 * 1024 * 1024 ? (Math.floor(this.length / 1024 * 1024)) + "m" : this.length >= 10 * 1024 ? (Math.floor(this.length / 1024)) + "k" : this.length + "b";
        return new InspectedObjectLiteral("<BinaryString length: " + lenStr + ">");
      },
      inspectedString: function(stride, maxBytes) {
        var characters, count, line, offset;
        if (stride == null) {
          stride = 8;
        }
        if (maxBytes == null) {
          maxBytes = 64;
        }
        count = 0;
        characters = [];
        if (this.length < maxBytes) {
          maxBytes = this.length;
        }
        line = new Array(stride);
        return compactFlatten([
          "BinaryString length: " + this.length + " bytes", maxBytes < this.length ? "First " + maxBytes + " bytes:" : void 0, (function() {
            var j, ref, ref1, results;
            results = [];
            for (offset = j = 0, ref = maxBytes, ref1 = stride; ref1 > 0 ? j < ref : j > ref; offset = j += ref1) {
              results.push(this._inspectLine(offset, stride, maxBytes));
            }
            return results;
          }).call(this)
        ]).join('\n');
      }
    });

    BinaryString.prototype._inspectLine = function(offset, length, maxBytes) {
      var b, characters, end, hexCharacters, i, y;
      end = min(this.length, offset + length);
      if (maxBytes >= 0) {
        end = min(end, maxBytes);
      }
      characters = (function() {
        var j, ref, ref1, results;
        results = [];
        for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
          b = this.bytes[i];
          if (b >= 31 && b <= 127) {
            results.push(String.fromCharCode(b));
          } else {
            results.push('â€¢');
          }
        }
        return results;
      }).call(this);
      hexCharacters = (function() {
        var j, ref, ref1, results;
        results = [];
        for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
          b = this.bytes[i];
          y = b.toString(16);
          if (y.length < 2) {
            y = "0" + y;
          }
          results.push(y);
        }
        return results;
      }).call(this);
      return (pad(hexCharacters.join(' '), length * 3)) + " '" + (characters.join('')) + "'";
    };


    /*
    toBase64 performance
    see: http://localhost:8080/webpack-dev-server/perf?grep=BinaryString
    as-of 2016-02-14, the manual string manipulation version is surprisingly the best on average for FF, Chrome and Safari
      For shorter lengths, toBase64Custom is by far the fastest, but
      toBase64ToDataUri starts to be faster at longer lengths.
     */

    BinaryString.prototype.toBase64 = function(sync) {
      var v;
      if (sync == null) {
        sync = false;
      }
      if (isNode) {
        v = Buffer.from(this.bytes).toString('base64');
        if (sync) {
          return v;
        } else {
          return Promise.resolve(v);
        }
      } else if (this.length > 16 * 1024) {
        return this.toBase64ToDataUri();
      } else {
        return this.toBase64Custom();
      }
    };

    BinaryString.prototype.toBase64ToDataUri = function() {
      return this.toDataUri().then(function(dataUri) {
        return dataUri.split(',')[1];
      });
    };

    BinaryString.prototype.toBase64Custom = function() {
      var a, b, base64, byteLength, byteRemainder, bytes, c, chunk, d, i, j, mainLength, ref;
      bytes = this.bytes;
      base64 = '';
      byteLength = bytes.byteLength;
      byteRemainder = byteLength % 3;
      mainLength = byteLength - byteRemainder;
      for (i = j = 0, ref = mainLength - 1; j <= ref; i = j += 3) {
        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        a = (chunk & 16515072) >> 18;
        b = (chunk & 258048) >> 12;
        c = (chunk & 4032) >> 6;
        d = chunk & 63;
        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
      }
      return Promise.resolve((function() {
        switch (byteRemainder) {
          case 0:
            return base64;
          case 1:
            chunk = bytes[mainLength];
            a = (chunk & 252) >> 2;
            b = (chunk & 3) << 4;
            return base64 + encodings[a] + encodings[b] + '==';
          case 2:
            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
            a = (chunk & 64512) >> 10;
            b = (chunk & 1008) >> 4;
            c = (chunk & 15) << 2;
            return base64 + encodings[a] + encodings[b] + encodings[c] + '=';
        }
      })());
    };

    return BinaryString;

  })(BaseObject);

}).call(this);
