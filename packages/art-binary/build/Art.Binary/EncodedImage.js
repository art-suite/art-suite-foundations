// Generated by CoffeeScript 1.12.7
(function() {
  var EncodedImage, ErrorWithInfo, HTMLImageElement, Image, Promise, StandardLib, binary, escapeRegExp, isBinary, isNode, isObject, isString, log, readFileAsDataUrl, ref, sameOrigin, toDataUri;

  StandardLib = require('art-standard-lib');

  toDataUri = require('./DataUri').toDataUri;

  isNode = StandardLib.isNode, log = StandardLib.log, Promise = StandardLib.Promise, readFileAsDataUrl = StandardLib.readFileAsDataUrl, ErrorWithInfo = StandardLib.ErrorWithInfo, isString = StandardLib.isString, escapeRegExp = StandardLib.escapeRegExp, isObject = StandardLib.isObject, sameOrigin = StandardLib.sameOrigin;

  ref = require('./BinaryString'), isBinary = ref.isBinary, binary = ref.binary;

  if (!global.Image) {
    try {
      global.HTMLImageElement = global.Image = (global.HTMLCanvasElement = eval('require')("canvas")).Image;
    } catch (error) {}
  }

  Image = global.Image, HTMLImageElement = global.HTMLImageElement;

  module.exports = EncodedImage = (function() {
    var get;

    function EncodedImage() {}


    /*
    IN:
      first arg:
        String: url
        or
        Binary: image data
        or
        HTMLImageElement
    
      second arg:
        options: (object)
          options for RestClient.getArrayBuffer
          NOTE: if options is provided, image-data is fetched using
            RestClient.getArrayBuffer
          This seems to work to endrun TAINT.
    
        crossOrigin: true/false/null/undefined
          false: DO NOT make crossorigin request
          null/undefined: AUTO
            crossOrigin is set to 'anonymous' if the request is indeed cross-origin
          true: crossOrigin is always set to 'anonymous'
    
      CORS/TAINT
        To avoid taint, either set the second option to {} or true.
        AND - make sure the server is returning the correct headers.
    
    OUT:
      promise.then (fullyLoadedHtmlImage) ->
      , (htmlImageOnerrorEvent) ->
    
    
    CORS NOTES
      crossOrigin = "Anonymous" required to getImageData and avoid this error
        "The canvas has been tainted by cross-origin data."
    
      performance???
        I don't think there is a performance hit for making the crossOrigin request.
        - SBD March-2018
    
      crossOrigin should only be set for HTTP requests - since it can only be
      fulfilled with HTTP response headers. Some browsers (safari) get cranky
      if you use it with file or data URIs:
    
        file: urls break with crossOrigin in WkWebKit
        data: urls break with crossOrigin in Safari
     */

    EncodedImage.get = get = function(source, b) {
      var complete, crossOrigin, image, naturalWidth, options;
      if (isObject(b)) {
        options = b;
      } else {
        crossOrigin = b != null ? !!b : void 0;
      }
      if (source == null) {
        return Promise.reject();
      }
      if (source.constructor === HTMLImageElement || source.constructor === Image) {
        image = source;
        complete = source.complete, naturalWidth = source.naturalWidth;
        return new Promise(function(resolve, reject) {
          if (complete && (naturalWidth > 0 || isNode)) {
            return resolve(source);
          } else {
            image.onload = function() {
              return resolve(image);
            };
            return image.onerror = function(event) {
              return reject(new ErrorWithInfo("image load error", event));
            };
          }
        });
      } else {
        return Promise.then(function() {
          if (isBinary(source)) {
            if (Neptune.isNode) {
              return binary(source).nodeBuffer;
            } else {
              return toDataUri(source);
            }
          } else if (isString(source)) {
            if (isObject(options)) {
              return Neptune.Art.RestClient.getArrayBuffer(source, options).then(function(arrayBuffer) {
                return readFileAsDataUrl(new Blob([arrayBuffer]));
              });
            } else {
              return source;
            }
          } else {
            throw new Error("expected arg #1 to be string or binary");
          }
        }).then(function(url) {
          image = new Image;
          if (!isNode) {
            if (crossOrigin != null ? crossOrigin : !sameOrigin(url) && /^https?:/i.test(url)) {
              image.crossOrigin = "anonymous";
            }
          }
          image.src = url;
          return get(image);
        });
      }
    };

    EncodedImage.toImage = function(encodedImageData) {
      return toDataUri(encodedImageData).then((function(_this) {
        return function(dataUri) {
          return get(dataUri);
        };
      })(this));
    };

    return EncodedImage;

  })();

}).call(this);

//# sourceMappingURL=EncodedImage.js.map
