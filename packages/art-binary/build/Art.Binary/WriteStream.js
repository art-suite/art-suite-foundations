// Generated by CoffeeScript 1.12.7
(function() {
  var BaseObject, ClassSystem, Promise, StandardLib, WriteStream, binary, bound, bufferSize, log, readFileAsArrayBuffer,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  StandardLib = require('art-standard-lib');

  ClassSystem = require('art-class-system');

  binary = require("./BinaryString").binary;

  Promise = StandardLib.Promise, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, bound = StandardLib.bound;

  BaseObject = ClassSystem.BaseObject, log = ClassSystem.log;

  bufferSize = 1024;

  module.exports = WriteStream = (function(superClass) {
    extend(WriteStream, superClass);

    function WriteStream() {
      this._written = [];
      this._writeBuffer = new Uint8Array(bufferSize);
      this._pos = 0;
      this._writtenLength = 0;
    }

    WriteStream.prototype.writeByte = function(byte) {
      if (this._pos === bufferSize) {
        this._commitHead();
      }
      return this._writeBuffer[this._pos++] = byte;
    };

    WriteStream.prototype.writeAsi = function(number) {
      var nextByte, results;
      if (!(number >= 0)) {
        throw new Error("expected number >= 0");
      }
      results = [];
      while (true) {
        nextByte = number & 0x7F;
        number >>= 7;
        if (number > 0) {
          results.push(this.writeByte(nextByte | 0x80));
        } else {
          this.writeByte(nextByte);
          break;
        }
      }
      return results;
    };

    WriteStream.prototype.write = function(string) {
      var binaryString;
      binaryString = binary(string);
      if (this._pos + binaryString.length <= bufferSize) {
        this._writeBuffer.set(binaryString.uint8Array, this._pos);
        return this._pos += binaryString.length;
      } else {
        this._commitHead();
        this._writtenLength += binaryString.length;
        return this._written.push(binaryString.uint8Array);
      }
    };

    WriteStream.prototype.writeAsiString = function(string) {
      var binaryString;
      binaryString = binary(string);
      this.writeAsi(binaryString.length);
      return this.write(binaryString);
    };

    WriteStream.getter({
      arrayBufferPromise: function() {
        return this._compact().then(function(uint8Array) {
          return uint8Array.buffer;
        });
      },
      binaryStringPromise: function() {
        return this.arrayBufferPromise.then(function(ab) {
          return binary(ab);
        });
      },
      length: function() {
        return this._pos + this._writtenLength;
      }
    });


    /*
    Using new Blob is much faster, thus we use Promises since it is async
      http://jsperf.com/appending-arraybuffers
    
    OUT: promise.then (compactedUint8Array) ->
    EFFECT:
      head was committed
      if @_written.length <= 1 then it isn't changed
      else @_written = [compactedUint8Array]
     */

    WriteStream.prototype._compact = function() {
      var i, j, k, len, len1, len2, out, outI, ref, ref1, totalLength, typedArray, v;
      this._commitHead();
      switch (this._written.length) {
        case 0:
          return Promise.resolve(new Uint8Array(0));
        case 1:
          return Promise.resolve(this._written[0]);
        case global.Blob:
          return readFileAsArrayBuffer(new Blob(this._written)).then((function(_this) {
            return function(ab) {
              _this._written = [new Uint8Array(ab)];
              return _this._written[0];
            };
          })(this));
        default:
          totalLength = 0;
          ref = this._written;
          for (i = 0, len = ref.length; i < len; i++) {
            typedArray = ref[i];
            totalLength += typedArray.length;
          }
          out = new Uint8Array(totalLength);
          outI = 0;
          ref1 = this._written;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            typedArray = ref1[j];
            for (k = 0, len2 = typedArray.length; k < len2; k++) {
              v = typedArray[k];
              out[outI++] = v;
            }
          }
          return Promise.resolve(out);
      }
    };

    WriteStream.prototype._commitHead = function() {
      if (!(this._pos > 0)) {
        return;
      }
      this._writtenLength += this._pos;
      this._written.push(this._writeBuffer.slice(0, this._pos));
      return this._pos = 0;
    };

    return WriteStream;

  })(BaseObject);

}).call(this);

//# sourceMappingURL=WriteStream.js.map
